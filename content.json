[{"title":"清白家风","date":"2017-01-29T13:17:35.000Z","path":"2017/01/29/清白家风/","text":"作者：子沫 现在是最关注教育的年代，也可以说是最没有教育的年代，因为分数代替了教育，疯狂追求效果的快餐社会，让家风和家教都荡然无存。这不能不说是一个大的缺憾。前段时间，重读寿岳章子的京都系列之一《千年繁华》，一个日本的女教授，从出生到去世，一直生活在京都古城，写这本书时，她住在父母留下的一栋老房子里已五十四年了，这栋房子盖得非常好，通风状况不错，夏天可以不用空调。这书是她回忆自己在京都生活的点点滴滴。我喜欢这本书，很大程度上却是被她的家风和家教所打动。在一个小城，满满当当小家情怀和世间情谊。 她说，我的双亲并非生性奢华，但对饮食非常讲究。如何吃表现寿岳家的生活精神。 她家里六席榻榻米中间摆了一张矮饭课，代表着家里的某精神象征。无论是吃饭还是喝茶，全家人都会聚拢在这张餐桌周围。开心地谈天说地。有时候，只需一张桌就可聚拢一家人，可是，很多人家里有豪华的餐桌，却常常失去了温馨的氛围，这是钱买不来的。 “家里很多年一直用火盆，生火是父亲的拿手绝活，将前一天晚上埋入灰烬里的火种稍微翻弄一下，添少许木炭，黑炭会慢慢烧红，热水壶也跟着发出腾的响声。烤土司面包，年糕，鱼干，孩子们围绕在母亲身边，也常常烤海苔，一有香味传出，父亲就会从书房走出来：煮什么东西？算我一份吧。”这样的场景真是令人神往。一家人动手做点什么，吃是一件共同的事，一件循序渐进的事，一个过程。 她说起一道母亲常做的料理“山药泥”，这个段落我看了几遍。“母亲去世后，我动手做过两三回，每次我总是边做边流泪。从前这可是一道充满欢乐的料理。山药放在大研钵里研磨一两千下，再加入高汤，从这步骤开始就是全家总动员，四个人都到厨房集合，研钵放在厨房地板上，我或弟弟负责扶稳研钵，母亲一点一点将一大早就熬好的汤，沿着钵体的边缘缓缓加入。使用大量昆布和柴鱼煮出来的高汤比清汤味道浓些，如果一开始全部倒入，山药泥和高汤的美味无法自然调和在一起，将高汤缓缓倒入研钵后，听到父亲指示，再打一颗蛋到研钵里，使用研磨棒时不可以粗鲁地碰撞到研钵体的边缘或底部，正确的力道是让棒轻轻游走在山药泥间。这道料里是父亲的家族传承下来的，制作工程相当复杂。”做好后，每个人的白米饭里浇上山药泥，一家人一起品尝，胃口大开，欢声笑语。这个过程，怎么看都像是一种神圣的仪式，父母能够给孩子留下什么？钱？房子？海外留学？统统不是，这些太过表像，很多年后，能够留下的只是某种对事对物的珍重和珍惜。我们在丢失什么？情怀，耐心，还有万事万物的敬畏。 “关于要不要在家吃饭这件事，如果说好要在家吃饭就绝对要遵守约定，这在我们家可是铁的纪律。有一次母亲发了很大脾气，就是因为父亲不回吃饭没打招呼：从结婚那天开始，我跟你父亲一起生活的时日就一天天减少，所以每一天都是非常珍贵的。正因为如此，我才想和心爱的人多点时间一起用餐，但是他却不明白我的心意，所以，我才会这么生气。”这句话让章子记忆深刻，也真的让我震惊，家也是要有纪律的，每个家都要有精神，这个精神是别人怎么变，我们家仍然在坚持属于我们的纪律。 寿岳家的餐桌就像是心灵交流的场所。 每个季节的佳肴，初夏时节，白萝卜的叶子细嫩铺满白米饭，初秋时的细姜丝淋上麻油。四季流转。情怀分明。在餐桌间细细流淌。 还有一些被人忽略的细节，而这些细节也是真正的教养所在。有人说，这是个有教育没有教养的社会，所以才会出现越来越多的问题儿童，问题中年，问题老年。 有一个削苹果的细节：“母亲要求削苹果时手不能碰果肉，切成两半，果蒂切成小三角形，切半的水果再对切，即可去皮，将切成四分之一大小的水果端出，手碰到果肉，就犯了母亲的大忌。现在，每当我看到别人切水果，就会用不怀好意的眼神观察”。只是一个削苹果的细节，却能观察一个人的教养。就像我看到有的女人把“不抖腿”列入了孩子的家教，一个人，最容易引起别人反感的也是一些细节不到位吧。一个人成不成功并不重要，重要是不要成为令人讨厌的人。 “每天使用的抹布一定要煮沸消毒好几次，厨房要彻底打扫干净，洗菜和洗碗的地方不可混用。钱不可以直接放餐桌上”他们家还有很多诸如此类的生活纪律。“若非长途旅行，绝不会在电车上吃东西，不仅吃相难看，最重要是非常不卫生。现在年轻妈妈们太漫不经心了。出租车司机说小孩把冰淇淋，巧克力弄得到处是；餐厅里小孩胡乱碰盘子，玩弄食物，没有一点用餐的卫生观念，这是我母亲最不喜欢看到的。对于这件事，专注且全心全意。绝对遵守餐桌礼仪。”这才是家风，从小就要求做到的，长大再去做就成了自然而然的事。我在想，为什么有些人看上去那低调谦和，舒适如沫春风，都是有道理的。他们活在一个良好的家教环境里，这个也是与钱无关的。餐桌就是一种家教，只不过被太多人忽略或认为不重要罢了。 “我们常用外出踏青，母亲带出来的爱心便当，特别收藏的糖果盒里，撒上黑芝麻的饭团。多层餐盒里则是竹笋，水煮蛋，木盒的沉香味。我们从不跑太远去旅行，顶多是回父亲的故乡。旅行的大半乐趣来自于母样亲手做的饭团便当。”真好，木盒的沉香味，这样有爱心便当的旅行，让孩子们明白了家的乐趣，而不是钱的乐趣。旅行只是换个地方用餐罢了，并不是你到过什么很高大上的地方，吃什么昂贵的大餐，一家人在一起就很开心了，在免费的绿水青山中，晒晒太阳，呼吸新鲜的空气就好，很多东西真的是钱买不来的。人与人最大的区别是钱买不来的东西你拥有多少？ 还有一个关于全家大扫除的情景让我记忆深刻。“一家人的大扫除可说是精彩万分。父亲带头，上半身披上一条大浴巾，下半身一件短衬裤，威风凛凛地出场。用旧棉布制作掸子，用旧毛巾缝制作抹布，毛巾折三折，大针脚夫缝合起来，我目前积存了两百条亲手做的抹布。除了一般湿抹布外，还有好几条干用抹布，擦走廓的，桌子，橱柜的，分门别类到有点复杂的程度。”连抹布都是亲手制作，都能留有回忆，一家人齐齐动手去做一件事。这样的事某种程度上已成了一个家庭事件。真是精彩，有滋有味。 我记得章子提到的这样的场景：“春天的时候，母亲开始在院子里晒布，缝衣。我也永远忘不了母亲在茶室中，面向南面窗户缝制和服的背影，同样的背影也会出现在书房，她在书房中做翻译，或替父亲的诗集上色。总之，我家的家风就是勤奋，认真地生活。” 勤奋，认真并不是过时的词，它才是最好的清白家风。他们只是普通人家，却有着平实的家风。这种家风才是孩子们最重要的成长养料。 细雨的夜晚，这个住在古城里几辈子的人家深深地打动了我。他们也只是普通人。","tags":[{"name":"读者","slug":"读者","permalink":"http://yutaiwei.github.io/tags/读者/"},{"name":"子沫","slug":"子沫","permalink":"http://yutaiwei.github.io/tags/子沫/"}]},{"title":"前端开发常用插件","date":"2017-01-20T13:43:53.000Z","path":"2017/01/20/前端开发常用插件/","text":".jpg) 前言最近在阅读公司官网的前端代码，使用了很多插件。挨个百度，简单记录下，看看他们都是干什么的。 jQuery UIjQuery UI API中文文档http://www.css88.com/jquery-ui-api/ SwiperSwiper是纯javascript打造的滑动特效插件，面向手机、平板电脑等移动终端。 Swiper能实现触屏焦点图、触屏Tab切换、触屏多图切换等常用效果。Swiper开源、免费、稳定、使用简单、功能强大，是架构移动终端网站的重要选择！ Swiper中文网http://www.swiper.com.cn/ 官网http://www.idangero.us/swiper/ BlockUIjQuery BlockUI Pluginhttp://malsup.com/jquery/block/ blockui githubhttps://github.com/malsup/blockui/ jQuery遮罩插件jQuery.blockUI.js简介http://bookshadow.com/weblog/2014/09/26/jquery-blockui-js-introduction/ email-autocompleteemail-autocompletehttps://github.com/10w042/email-autocomplete jQuery-AutocompletejQuery-Autocompletehttps://github.com/devbridge/jQuery-Autocomplete chosenchosenhttps://github.com/harvesthq/chosen Chosen (v1.4.2)http://harvesthq.github.io/chosen/ ajaxfileuploadjQuery插件之ajaxFileUploadhttp://www.cnblogs.com/kissdodog/archive/2012/12/15/2819025.html html2canvashtml2canvashttp://www.bootcdn.cn/html2canvas/ 百度地图百度地图APIhttp://lbsyun.baidu.com/ momentJavaScript 日期处理类库 Moment.js中文网http://momentjs.cn/ paginationjQuery Pagination pluginhttp://esimakin.github.io/twbs-pagination/ placeholderjquery-placeholderhttps://github.com/mathiasbynens/jquery-placeholder romeromehttp://spmjs.io/package/rome validationvalidation官方文档http://jqueryvalidation.org/documentation zeptoZepto is a minimalist JavaScript library for modern browsers with a largely jQuery-compatible API. zepto中文网http://www.zeptojs.cn/ tooltipsterA powerful, flexible jQuery plugin enabling you to easily create semantic, modern tooltips enhanced with the power of CSS. 官网http://iamceege.github.io/tooltipster/ lazyloadLazy Load Plugin for jQueryhttp://www.appelsiini.net/projects/lazyload lazyload项目地址：https://github.com/tuupola/jquery_lazyload MasonryMasonry官网http://masonry.desandro.com/ mosonry项目地址：https://github.com/desandro/masonry imageLoadedimagesLoaded官网http://imagesloaded.desandro.com/ imagesloaded项目地址：https://github.com/desandro/imagesloaded touch.jsTouch.js官网http://touch.code.baidu.com/ iscrolliScroll官网http://cubiq.org/iscroll-5 iScroll文档http://iscrolljs.com/ iScroll项目地址https://github.com/cubiq/iscroll 【iScroll源码学习00】模拟iScrollhttp://www.cnblogs.com/yexiaochai/p/3489676.html 后记优点：开发成本低、时间短；稳定性、兼容性良好。缺点：不懂原理，遇到问题不好解决。 提供给开发者的 20 款最棒的 jQuery Bootstrap 插件http://www.oschina.net/translate/20-best-jquery-bootstrap-plugins-for-developers","tags":[{"name":"前端","slug":"前端","permalink":"http://yutaiwei.github.io/tags/前端/"},{"name":"插件","slug":"插件","permalink":"http://yutaiwei.github.io/tags/插件/"}]},{"title":"解决iscroll.js上拉下拉刷新手指划出屏幕页面无法回弹问题","date":"2017-01-17T12:41:50.000Z","path":"2017/01/17/解决iscroll-js上拉下拉刷新手指划出屏幕无法弹回问题/","text":".jpg) 使用过iscroll.js的上拉下拉刷新效果的朋友应该都碰到过这个问题：在iOS的浏览器中，上拉或下拉刷新时，当手指划出屏幕后，页面无法弹回。很多人因为解决不了这个问题，干脆就那样不解决了，还有的直接就不用HTML了，使用原生代替HTML页面。 相信很多朋友也有自己的解决办法，只是没写出来，所以网上都搜不到解决方案。在很多QQ群里面也有很多人在问该怎么解决这个问题，所以我写这篇文章记录一下我的解决方案，希望对一些朋友有所帮助。 上拉下拉刷新的主要代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344myScroll = new iScroll('wrapper', &#123; vScrollbar: false, useTransition: true, topOffset: pullDownOffset, onRefresh: function () &#123; if (pullDownEl.className.match('loading')) &#123; pullDownEl.className = ''; pullDownEl.querySelector('.pullDownLabel').innerHTML = 'Pull down to refresh...'; &#125; else if (pullUpEl.className.match('loading')) &#123; pullUpEl.className = ''; pullUpEl.querySelector('.pullUpLabel').innerHTML = 'Pull up to load more...'; &#125; &#125;, onScrollMove: function () &#123; if (this.y &gt; 5 &amp;&amp; !pullDownEl.className.match('flip')) &#123; pullDownEl.className = 'flip'; pullDownEl.querySelector('.pullDownLabel').innerHTML = 'Release to refresh...'; this.minScrollY = 0; &#125; else if (this.y &lt; 5 &amp;&amp; pullDownEl.className.match('flip')) &#123; pullDownEl.className = ''; pullDownEl.querySelector('.pullDownLabel').innerHTML = 'Pull down to refresh...'; this.minScrollY = -pullDownOffset; &#125; else if (this.y &lt; (this.maxScrollY - 5) &amp;&amp; !pullUpEl.className.match('flip')) &#123; pullUpEl.className = 'flip'; pullUpEl.querySelector('.pullUpLabel').innerHTML = 'Release to refresh...'; this.maxScrollY = this.maxScrollY; &#125; else if (this.y &gt; (this.maxScrollY + 5) &amp;&amp; pullUpEl.className.match('flip')) &#123; pullUpEl.className = ''; pullUpEl.querySelector('.pullUpLabel').innerHTML = 'Pull up to load more...'; this.maxScrollY = pullUpOffset; &#125; &#125;, onScrollEnd: function () &#123; if (pullDownEl.className.match('flip')) &#123; pullDownEl.className = 'loading'; pullDownEl.querySelector('.pullDownLabel').innerHTML = 'Loading...'; pullDownAction(); &#125; else if (pullUpEl.className.match('flip')) &#123; pullUpEl.className = 'loading'; pullUpEl.querySelector('.pullUpLabel').innerHTML = 'Loading...'; pullUpAction(); &#125; &#125;&#125;); 页面无法弹回的原因在于：手指划出屏幕后touchend事件无法触发，回弹动画就无法执行。解决办法就是：当手指接近屏幕边缘的时候，手动触发动画方法。 在onScrollMove方法中插入判断代码： 1234567891011onScrollMove: function () &#123; if((this.y &lt; this.maxScrollY) &amp;&amp; (this.pointY &lt; 1))&#123; this.scrollTo(0, this.maxScrollY, 400); return; &#125; else if (this.y &gt; 0 &amp;&amp; (this.pointY &gt; window.innerHeight - 1)) &#123; this.scrollTo(0, 0, 400); return; &#125; ......&#125; 下面解释一下这段代码的意思。 this.y是页面已经滚动的垂直距离，this.maxScrollY是最大垂直滚动距离，this.pointY手指当前的垂直坐标。 当this.y &lt; this.maxScrollY，就是已经处于上拉的过程，当(this.y &lt; this.maxScrollY) &amp;&amp; (this.pointY &lt; 1)时，处于上拉且手指已经触及屏幕边缘，这时候手动触发this.scrollTo(0, this.maxScrollY, 400)，页面就开始回弹。 下拉过程也可以同理分析。 欢迎留下你的解决方法。","tags":[{"name":"iscroll.js","slug":"iscroll-js","permalink":"http://yutaiwei.github.io/tags/iscroll-js/"},{"name":"无法回弹","slug":"无法回弹","permalink":"http://yutaiwei.github.io/tags/无法回弹/"},{"name":"上拉下拉刷新","slug":"上拉下拉刷新","permalink":"http://yutaiwei.github.io/tags/上拉下拉刷新/"}]},{"title":"横向滚动效果","date":"2017-01-14T09:57:50.000Z","path":"2017/01/14/横向滚动效果/","text":"html部分：1234567891011&lt;div class=\"tab-body\"&gt; &lt;ul&gt; &lt;li data-key=\"0\"&gt;全部&lt;/li&gt; &lt;li data-key=\"1\"&gt;攻略&lt;/li&gt; &lt;li data-key=\"2\"&gt;案例&lt;/li&gt; &lt;li data-key=\"3\"&gt;故事会&lt;/li&gt; &lt;li data-key=\"4\"&gt;特别策划&lt;/li&gt; &lt;li data-key=\"5\"&gt;喜舍杯&lt;/li&gt; &lt;li data-key=\"6\"&gt;家居轶事&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; css部分：123456789101112131415161718192021.tab-body&#123; background: #fff; overflow-x: scroll; ul&#123; width: 1000%; li&#123; display: inline-block; vertical-align: top; height: 3.5rem; line-height: 3.5rem; font-size: 1.3rem; color: #666; padding: 0 .8rem 0 .8rem; margin-right: 1.8rem; &amp;.active&#123; border-bottom: 4px solid #FF5500; color: #FF5500; &#125; &#125; &#125;&#125; js部分：12345678910111213141516171819202122232425262728293031323334// 初始type是全部$('.tab-body li').first().addClass('active');var type = 0;// 设置导航条宽度var totalWidth = 0;$('.tab-body li').each(function(index, el) &#123; totalWidth += $(el).width()+parseInt($(el).css('margin-right'));&#125;);$('.tab-body ul').css(&#123; 'width': (totalWidth + 50)+ 'px'&#125;);// 切换type$('.tab-body li').on('click',function()&#123; $('.tab-body li').removeClass('active'); $(this).addClass('active'); type = $(this).attr('data-key'); var param = &#123; articleType: type, pageNo: 1, pageSize: 4 &#125; $.ajax(&#123; url: '/inspiration/home/api', type: 'POST', dataType: 'json', data: param, success: function(data)&#123; //把新获得的数据插入到页面 &#125;, error: function(xhr)&#123; console.log(xhr) &#125; &#125;); &#125;); 效果图","tags":[{"name":"前端","slug":"前端","permalink":"http://yutaiwei.github.io/tags/前端/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yutaiwei.github.io/tags/JavaScript/"}]},{"title":"Cookie、localStorage和sessionStorage","date":"2017-01-03T03:18:09.000Z","path":"2017/01/03/Cookie、localStorage和sessionStorage/","text":".jpg) 前言在《使用accessToken记录登录状态》一文中，已经讨论了Cookie的增删查改。本文详细探讨一下Cookie、localStorage和sessionStorage的概念差别，以及localStorage的用法。 CookieCookie的特点是小，只有4k，常用来存储辨别用户信息的数据，比如accessToken。而且，Cookie有数量限制，每个特定的域名下，最多生成50个Cookie（IE7+）。最大的优势是几乎所有的浏览器都支持。 localStoragelocalStorage 是 HTML5 标准中新加入的技术，拥有5M的存储空间，主流浏览器都支持。 存储123456789101112if(window.localStorage)&#123; var x = window.localStorage.userInfo? JSON.parse(window.localStorage.userInfo):&#123;&#125;; if((x.unionid == undefined) || (x.unionid == \"undefined\"))&#123; var temp = &#123; unionid: $('#unionid').val(), openid: $('#openid').val(), nickname: $('#nickname').val(), headimgurl:$ ('#headimgurl').val() &#125;; window.localStorage.userInfo = JSON.stringify(temp); &#125;&#125; 读取123var temp = (window.localStorage &amp;&amp; window.localStorage.userInfo)?JSON.parse(window.localStorage.userInfo):&#123;&#125;var unionid = temp.unionid;console.log(unionid); sessionStoragesessionStorage和localStorage非常相似，最主要的差别，是生命周期。localStorage除非被清除，否则永久保存；sessionStorage关闭页面或浏览器后被清除。 异同 特性 Cookie localStorage sessionStorage 数据的生命期 可设置失效时间，默认是关闭浏览器后失效 除非被清除，否则永久保存 仅在当前会话下有效，关闭页面或浏览器后被清除 存放数据大小 4K左右 一般为5MB 一般为5MB 与服务器端通信 每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题 仅在客户端（即浏览器）中保存，不参与和服务器的通信 仅在客户端（即浏览器）中保存，不参与和服务器的通信 易用性 需要程序员自己封装，源生的Cookie接口不友好 源生接口可以接受，亦可再次封装来对Object和Array有更好的支持 源生接口可以接受，亦可再次封装来对Object和Array有更好的支持 书签详说 Cookie, LocalStorage 与 SessionStoragehttps://segmentfault.com/a/1190000002723469 HTML5 localStorage本地存储实际应用举例 谈谈本地存储利弊Cookie、localStorage、sessionStoragehttp://www.tuicool.com/articles/fM32ier","tags":[{"name":"前端","slug":"前端","permalink":"http://yutaiwei.github.io/tags/前端/"},{"name":"cookie","slug":"cookie","permalink":"http://yutaiwei.github.io/tags/cookie/"},{"name":"localstorage","slug":"localstorage","permalink":"http://yutaiwei.github.io/tags/localstorage/"},{"name":"sessionstorage","slug":"sessionstorage","permalink":"http://yutaiwei.github.io/tags/sessionstorage/"}]},{"title":"程序猿笑话，放松一下","date":"2016-12-28T10:15:20.000Z","path":"2016/12/28/程序猿笑话，放松一下/","text":".jpg) 原文来自：http://www.itjhwd.com/cxyxiaohua-2/ 1、新春对联上联：为系统而生，为框架而死，为debug奋斗一辈子下联：吃符号的亏，上大小写的当，最后死在需求上！横批：杯具程序员。2、程序员其实可痛苦的了……需求一做一改，一个月就过去了；嚎~需求再一改一调，一季度就过去了；嚎~程序员最痛苦的事儿是啥，知道不？就是，程序没做完，需求又改了；程序员最最痛苦的事儿是啥，知道不？ 就是，系统好不容易做完了，方案全改了；程序员最最最痛苦的事儿是啥，知道不？ 就是，系统做完了，狗日的客户跑了；程序员最最最最最痛苦的事儿是啥，知道不？ 就是，狗日的客户又回来了,程序给删没了！ 3、男：我是程序猿。女：哦，程先生，你好。男：客气了，叫我序猿就好~ 4、我是你的什么，你是我的程序猿，啊？？原来我是猴子啊，酱紫我就可以让你耍coding啦！！！ 5、怎么使用面向对象的方式变得富有？继承。 6、一男子在路边一根接着一根地抽烟。一个女士走过来对他说：“嘿，你不知道你是在慢性自杀吗？注意看看烟盒上的警告信息。”“没关系”，男子悠然自得地又吸了一口：“我是个程序猿。”“嗯？这和你是程序猿有什么关系？”“我们一点儿也不在乎警告（warning），我们只在乎错误（error）。” 7、问：程序员最讨厌康熙的哪个儿子。答：胤禩。因为他是八阿哥（bug）。 8、换一个电灯泡需要几个程序员？一个也不要，这是硬件问题 9、危楼高百尺，手可写代码；举头望明月，低头写代码；王师北定中原日，家祭无忘写代码； 10、孤帆远影碧空尽，唯见代码眼前流 11、十个顶尖软件工程师参加培训管理人员的课程。老师提出了这样一个问题：“假如你供职的公司是为航空电子设备提供软件的。有一天你乘飞机出差，当你上了飞机后你发现一个牌子上写着这个飞机用的是你的团队开发的Beta版软件，你会下飞机吗？”九个软件工程师举了手。老师看着第十个问道：“你为什么愿意留在飞机上？”这人回答说：“如果是我的团队写的这个软件，飞机根本无法起飞，根本谈不上坠毁。” 12、换一个电灯泡需要几个C++程序员？你还在用面向过程的思维考虑问题。一个设计良好的电灯泡类必然封装了换灯泡的方法，所以你要做的就是调用“换电灯泡”方法 13、电脑是高速的笨蛋，程序员是低速的笨蛋。 14、爱情观爱情就是死循环，一旦执行就陷进去了。爱上一个人，就是内存泄漏–你永远释放不了。真正爱上一个人的时候，那就是常量限定，永远不会改变。女朋友就是私有变量，只有我这个类才能调用。情人就是指针用的时候一定要注意，要不然就带来巨大的灾难。 15、笑话二：女人篇有的女人就是Windows虽然很优秀，但是安全隐患太大。有的女人就是MFC她条件很好，然而不是谁都能玩的起。有的女人就是C#长的很漂亮，但是家务活不行。有的女人就是C++,她会默默的为你做很多的事情。有的女人就是汇编虽然很麻烦，但是有的时候还得求它。有的女人就是SQL，她会为你的发展带来莫大的帮助。 17、世界上最遥远的距离不是生与死，而是你亲手制造的BUG就在你眼前，你却怎么都找不到她。。。 18、杀一个程序员不需要用枪，改三次需求就可以了 19、十行代码九个警告八个错误竟然敢说七日精通六天学会五湖四海也不见如此三心二意之项目经理简直一等下流。 20、网络聊天的时候，想表达对方是猪，一般人会打“xxx你这个猪。”，程序员会打 xxx.isPig = TRUE。 21、假如生活欺骗了你，找50个程序员问问为什么编程；假如生活让你想死，找50个程序员问问BUG改完了没有；假如你觉得生活拮据，找50个程序员问问工资涨了没有；假如你觉得活着无聊，找50个程序员问问他们一天都干了什么！ 22、c程序员看不起c++程序员，c++程序员看不起java程序员，java程序员看不起c#程序员，c#程序员看不起美工，周末了，美工带着妹子出去约会了…一群傻X程序员还在加班！ 23、一个合格的程序员是不会写出诸如“摧毁地球”这样的程序的，他们会写一个函数叫“摧毁行星”而把地球当一个参数传进去。 24、Borland说我很有前途，Sun笑了；Sun说我很有钱，IBM笑了；IBM说我很专业，Sybase笑了；Sybase说我数据库很牛，Oracle笑了；Oracle说我是开放的，Linux笑了；Linux说我要打败Unix，微软笑了；微软说我的系统很稳定，我们都笑了。 25、一程序员告老还乡，想安度晚年，于是决定在书法上有所造诣。省略数字……，准备好文房4宝，挥起毛笔在白纸上郑重的写下：Hello World 26、真正的程序员喜欢兼卖爆米花，他们利用CPU散发出的热量做爆米花，可以根据米花爆裂的速度听出正在运行什么程序。 27、【程序猿的三重境界】第一重：无尽bug常作客，困闷调试伴不眠。第二重：千行代码过，bug不沾身。第三重：编码间，bug灰飞烟灭。 28、程序猿xx遭遇车祸成植物人，医生说她活下来的希望只有万分之一，唤醒更为渺茫。她的同事和亲人没放弃，并根据程xx对testing痴迷的作风，每天都在她身边念：“你测的模块上线后回滚了…”奇迹发生了，程xx醒来第一句话：确认那模块是我测的？ 29、学&lt;数据结构&gt;的童鞋注意了，告诉大家一个真相，中国实行计划生育最终目的是为了能够用二叉树进行统计管理，因为二叉树最多可以生两个孩子，多了就超生。 30、程序员找不到对象，一般有三种情况：1、 C# JAVA都有对象，但是经常找不到对象。2、ASM C直接没有对象。3、javascript都是伪对象，最多算暧昧。但C++日子一直都好过，因为C++是多继承，富二代呀！！！ 31、一群男程序员酒后乱逛，正要集体侵犯一个女子。女子见势不妙，问：那你们说最好的编程语言是什么？程序员们就地讨论了三天三夜不欢而散，女子趁机顺利脱身。 32、开着MyEclipse，独自彷徨在悠长、悠长又寂寥的雨巷，我希望逢着一个和我一样的调试代码的姑娘。她是有需求一样的凌乱，设计一样的荒唐，测试一样的忧愁，在代码里哀怨，哀怨又彷徨；她彷徨在这寂寥的雨巷。 33、某小偷潜入某IT公司欲行窃，没想到始终有人，他只好等啊等啊等，结果始终有一大拨人在加班。过了一个月，小偷终于逮到机会溜出来，同伙问：去哪了？小偷：在IT公司呆了一个月。同伙：收获不错吧？小偷苦笑：别TM提了，三十个大夜下来，我现在已经学会写程序了。 34、真的猛士，敢于直面混乱的程序，敢于正视变幻的需求。 35、《未来的云计算服务》张总在办公室下载了苍井空，按下CTRL+X后就回家了。晚上躺在床上按下CTRL+V继续观看，旁边的小蜜惊呆了，张总淡淡的说：云剪贴。 36、如果你的朋友最近没和你联系，要理解！只有三种可能：第一，他死了；第二，他改行当程序猿了；第三，需求又改了！ 37、某日和同学聊起对象问题，我答道：哥最不缺的就是对象了，要知道哥是程序员，每天不知道要new多少个对象出来，而且想要啥类型就有啥类型。如果你想要，哥给你来个for循环嵌套，new上她千个百个 38、我是个程序员，一天我坐在路边一边喝水一边苦苦检查bug。 这时一个乞丐在我边上坐下了，开始要饭，我觉得可怜，就给了他1块钱。 然后接着调试程序。他可能生意不好，就无聊的看看我在干什么，然后过了一会，他缓缓地指着我的屏幕说，这里少了个分号… 39、锄禾日当午，不如coding苦，对着C++，一调一下午；锄禾日当午，不如coding苦，调了一下午，BUG还得补； 锄禾日当午，不如coding苦，Bug刚补完，结构需重组；锄禾日当午，哪有coding苦，Bug改不完，无言见列祖。 40、最后祝大家在以后的日子里：男生象Oracle般健壮，女生象win7般漂亮，桃花运象IE中毒般频繁，钱包如Gmail容量般壮大，升职速度赶上微软打补丁，追女朋友像木马一样猖獗，生活像重装电脑后一样幸福，写程序敲代码和聊天一样有激情。","tags":[{"name":"程序员","slug":"程序员","permalink":"http://yutaiwei.github.io/tags/程序员/"},{"name":"笑话","slug":"笑话","permalink":"http://yutaiwei.github.io/tags/笑话/"}]},{"title":"沿着最初的理想走下去","date":"2016-12-19T02:22:06.000Z","path":"2016/12/19/沿着最初的理想走下去/","text":".jpg) 作者：沈杰辉 电影《10件或更少》中，女主人公是一位年轻貌美、聪慧能干的西班牙女郎，但与她终日相伴的是一家郊区小超市的“10件以下商品收银台”——她深深厌恶着那里机械而繁重的工作，以及自己无比失败的婚姻。后来某天一位老牌演员忽然闯入女主人公的生活场域，并同行整日，以其豁达性情与深厚阅历为这个25岁女孩一洗心头蒙尘，让她看见其实自己的生活没那么糟糕。整部电影节奏温柔、文艺，且抛出一个相当有趣的数字游戏：说出10件以下你喜欢或讨厌的事情。影片告诉你，真正活得积极有味的灵魂，喜欢的事情会远远多于10件。 寻常市井中，如片中老演员那般“乐活”的姿态实属寥若晨星，多的是女主人公式平凡奋斗的年轻人群，在纷扰都市里搏未来生存的日子毋庸置疑要和无尽辛劳与烦忧形影相伴：疲于奔命、薪水不高、压力过大、工作单调、闲暇稀少……努力不去抱怨已属高度乐观，强颜欢笑从少有的闲适感里挖出10件喜欢之事显然过于梦幻。 令我们真正在意的事不多，10件或更少。我觉得对于在大都市闯荡打拼的年轻人而言，生活的天平其实并不需要那么多砝码，即使你此刻手里仅简简单单攥着一两个前行的理由，维系心灵的平衡和有序才是你应当在意的事情。何时何地，同自己的心和平相处，比什么都重要。 朋友圈里有不少刚离开大学校园、投身社会一年半载的职场新鲜人，与他们交流的若干片段剪辑在一起完全是一部反映青年心态的纪录片，一个经典的情节便是职场新人频频换工作，而其中心境平和者屈指可数。“没意思”“不耐烦”是常见的解释理由，不少人的状态全然表现为一种持续奔波的茫然，他们对自己驻扎过的每一任东家都心存不满，抱怨职业与个人志趣不合，或者自怜明珠暗投被繁琐杂事消耗青春，或者全程一无所获未得到明显技能培养……打游击式换工作一大圈，消极状态却一如从前。这一类职场新人起步时喜好不明，却格外看重自己每一步前行有什么收获，时时计算一份工作给予内心满足感的砝码分量，可谓“步步惊心”。然而反复计较砝码的得失，却不知回头审视和调整内心天平的平衡，导致年纪轻轻竟暮气沉沉，聊起工作即如怨妇。 想说说与众不同的一个。朋友J小姐自中学起便有志于媒体，高三当其他人抱着数理化题库和高考作文指南按部就班备考，她“不务正业”地挤出所有闲暇阅读报刊上的优质新闻报道。上大学担任校刊主编，在宿舍通宵达旦写稿排版，假期通通用于各大社会媒体的实习。毕业季新闻系同学都一窝蜂涌向公务员和外企，她上海的家里也托人给安排了妥舒适稳定的工作，男友留校读研，她却执拗一人拖着行李箱一路北上——那家知名媒体仅提供实习机会并没有承诺offer，“我就是喜欢做新闻，活这么多年唯有这件事带给我快乐。”背对着千里之外家人忧心忡忡的目光，J小姐白日里在偌大的北京城为了一纸新闻四处奔波，晚上回到“蜗居”租房还要对付永远堵塞的下水管道，摆弄不太娴熟的厨艺准备隔日餐食。 大学班级微信群里渐渐涌现各种晒优越感的签约消息，也有人褒贬不明地嘀咕一句：瞧，咱们班也就北漂的那位同学还有新闻理想呢。J小姐淡淡一笑，打开WORD文档继续编辑采访稿。那家知名媒体最终破例给了她offer，还记得她签三方后和我说，最喜欢杨德昌导演的《一一》，因为拍得透彻、明亮，人不可能看到生活的另一面，所以为了避免患得患失，遵从内心的喜好去选择总是没错的，心安为上。 这是几年前的事了，最近一次联系J小姐，她居然人在香港，听筒中依稀可辨四周熙熙攘攘的市井声，没想到她跑去了更远的异乡追随梦想的感召。听到故人问候，J小姐语气里满是激动，吐了一串“好开心”。聊起前程，压力大，异地恋，但暂时不打算回来。“沿着最初的理想走下去，生活的确更累了，不过精神也更安定了。”时光轻飘飘溜走好些年，J小姐生活的天平上始终只有两个砝码——喜欢，理想，可就是少得可怜的两个抽象理由让她心灵世界的运转井然有序，不汲汲于眼前得失，活得骄傲、平和而自在。 说起工作，许多青年将其理解为选择的问题。的确，如今职业选择的范围和自由度都变大了，在一处干得不如意还有若干出口和门路。但这不应成为青年逃避矛盾的万能借口，丰富的选择是为了让每个人更明晰内心真实的喜爱和在乎的人生志向，收获属于自己的生活平衡。 生活不如意事常八九，而人心自有平衡的法则。朋友J小姐执着地追随初心，安然迎接每一场征程赋予的阳光或风雪，然后更加热情有力地拥抱命运在下一个路口的安排。电影《10件或更少》中，老演员教导西班牙女孩，要不顾一切争取抓紧自己在意的任何人生砝码——比如果断甩掉沉闷的小超市去建筑公司面试——但更关键的一点是，无论故事的结尾何种选择降临，你都要学会乐在其中，享受轻重疾徐的步调，不去抱怨。这，就是我们心灵平衡的要义。 人心当有平衡的法则，生活不纠结，世道再难，也能呼吸顺畅。","tags":[{"name":"读者","slug":"读者","permalink":"http://yutaiwei.github.io/tags/读者/"},{"name":"励志","slug":"励志","permalink":"http://yutaiwei.github.io/tags/励志/"},{"name":"理想","slug":"理想","permalink":"http://yutaiwei.github.io/tags/理想/"}]},{"title":"讲故事写小说","date":"2016-12-09T02:35:19.000Z","path":"2016/12/09/讲故事写小说/","text":".jpg) 原作者不详，yutaiwei整理。 小说其实就是给读者讲故事，讲好一个故事，也就写好了一部小说。 对于新人来说，在讲故事以及编故事方面，都有一些生涩之处，今天这个帖子里，会单就编故事方面，写一些我总结出来的经验。一家之言，多有偏颇，抛砖引玉，欢迎讨论。 故事的概念，没必要用一些很虚无缥缈的解释来进行曲解，故事就是故事，只是多个人物共同演绎出来的一段有趣的事件而已。故事本身的定义是简单的，真正的难的是如何编好编故事。 在编故事写提纲方面，网文同道已经有许多人总结过一些经验，其中有两个方法最为简单实用，第一个方法是七要素，在设计故事的时候，全都围绕“奇遇、升级、寻宝、泡妞、发财、欺人、助人”这七个要素来展开设计；第二个方法是九线，这种方案是围绕“1、主角智慧性格2、配角炮灰3、技能4、伙伴5、装备6、冒险7、身世8、势力9、后宫”这九种要素来展开设计。 七要素跟九线的设计思路是一致的，只不过是考虑的要素不同而已，这两种技巧以前已经有人写过了，好奇的可以去百度，我就不赘述了。 除了网络写手总结的这两套经验之外，传统小说的一些编故事的技巧，实际上也是非常好用的，比如说语文课本上关于“起点，经过，结果”的记述。这正是一个故事完整的结构，由此为出发点，同样能编出有意思的故事。 在编故事方面，编剧也是此中的行家里手，也有许多关于编故事的技巧跟方法，我研究了一些编剧的指南，其中有位资深老编剧提供的一种方法也非常不错，这里也重点提一下。这位老编剧所推崇的方法是“人物构建法”，这种方法是先确立一整套人物关系，将每个人物之间的矛盾想好，然后让这些人物动起来，思考这些人物在面临各种情况下会如何处理，让这些人物进行碰撞，不断碰撞的过程中，故事自然也就出来了，当碰撞到极限，有了结果时，故事也就随之结束。 人物构建法在网文中是很少有人应用的，但是影视剧中很多人在用。在网络小说中，有许多路人甲角色，往往存在的意义就是领便当，出场极短。在影视剧当中，虽然也有路人甲，但数量要远远低于网络小说，每个人物都很重要。所以影视剧很重视人物关系以及人物的作用，会下大力气进行设计。 人物构建法是个颇为精深的技巧，没个几千字是交代不清楚的，我这里只详述其中一个关键性技巧，用好这一个技巧，就很厉害了。 在小说的人物关系之中，为了凸出矛盾，人物之间不是敌方就是我方，十分明显，但这种设定太过简单了，而且也无法摩擦出巧妙的故事，所以在设计的时候，可以多多考虑双重关系，让人物之间的关系变得复杂起来。 举例来讲，主角有个杀父仇人，但不知道这个仇人到底是谁，后来主角爱上了一个女人，结果这个女人正是主角的杀父仇人。这样的复杂关系，会让主角对女主角又爱又恨，进而演绎出一段相爱相杀的虐恋。 这个例子是比较虐的，但只要技巧在手，无论怎么运用都可以，将这个技巧用在爽上面是一样的。 举例二，主角有个敌人，实力不如对方，一直处于下风，直到某天主角学了一门医术，而这么医术正好能治这位敌人父亲的病，敌人为了求主角给父亲治病，只能各种讨好，以及甘愿当牛当马，受人驱使，甚至还得把宝宝妹妹介绍给主角……这个就是以爽快为出发点的例子了。 关系一旦对调并复杂化，马上就会产生许多乐趣，这便是设计人物关系的精髓所在。 以上，都是别人总结的技巧，接下来，才是我总结的一种技巧，这才是这个帖子的重点讲解对象。 七要素跟九线，固然是很实用的编故事技巧，不过局限性很大，全都围绕着一些固定的要素来写，就会产生固定思路，很难跳脱出去。 起点、经过、结果，固然是故事的正确结构，可是光知道结构，对于编故事方面的帮助却收效甚微。 人物构建法能创造出很棒的人物关系，但运用起来的难度较大，一来容易因为戏份分摊导致主角形象降低，二来会导致反派人物太深入人心不方便干掉，三来容易导致人物关系过于复杂，无法处理清楚，四来容易造成人物关系纠结成网，无法跳转新副本，导致滞留在一处，五来如果女人太聪明，就无法开后宫了……总而言之，我在运用以上几种技巧编故事的时候，全都遇到了各种难处，觉得不甚好用，所以自己苦思了一段时间，还真想出了一个新办法出来。 我给这个这个新办法取名为“事件组合法”。 顾名思义，这个办法就是利用大大小小的事件组成一个完整的提纲出来，大事件套着小事件，小事件连着小事件，众多小事件组成大事件。 事件的概念是什么？ 事件……就是事件，并非什么深奥的东西。 在这点上还是举例来讲，一举例大家就全明白了。 逃课的男主角在街上闲逛时，遇到了请病假的女主角，两人恰好今天都没有去上课，感觉很有意思，在街上聊了几句，然后去看了场电影，吃了顿饭——这就是一个小事件。 男主角遭遇退婚，受到羞辱，经过一番修炼之后，杀上女方的家里找场子——这就是一个大事件，很长线的大事件。 大事件全都是由小事件组成的，一步步推演发展，铺垫渲染，最终达到整个事件的最高潮。 用这种方法来编写提纲的时候，就是思考许多个事件，然后将事件组合起来。在此过程中，还得结合人物关系，小说风格，题材分类，主角外挂，力量体系等元素进行思考，光拿事件进行拼凑是不行的。 比如要编写一个以重生为外挂的玄幻小说，风格定位为传统爽文，力量体系为斗气，在确立了这些东西之后，就可以展开思考了。 前期第一个大事件是门派被灭，主角重生后的目的是阻止这件事情的发生，以这个大事件为前期主线，开始对小事件进行设计。 第一个小事件是主角被同门欺负，导致昏迷，醒来后已经是重生者了，将此来做为开头，稳扎稳打。第二个事件是同门小师妹来问长问短，给主角送药。第三个事件是从门派隐秘处挖一根灵草，修复身体，提升功力……以此类推，逐步推进剧情。 之前提过了，用事件进行组合得结合多方面进行思考，不能生搬硬套，否则只会不伦不类。 在刚才那个例子当中，设定的是玄幻题材，玄幻题材经过这些年的发展，已经产生了许多常见的事件，用这些事件来编故事，才能编出带有玄幻风味的故事，如果采用跨题材事件来编故事，很容易导致故事走形。 玄幻的事件，修真的事件，都市的事件，历史的事件……全都各有其特色，彼此之间有一些可以通用，有一些不能通用，需要分清楚。 搞笑的事件，悲伤的事件，热血的事件，紧张的事件……在风格方面，事件也有其另一番面貌，也需要重点加以考虑，只有各方面完美结合，才能创造出一个合格的好故事。 编故事是一个浩大的工程，无论是再好的技巧，也无法让这变成一个轻松的活儿，我提供的这个事件组合法，也只是一个思考问题的出发点而已。 想要真正做到念头通达，挥洒自如，还是得多积累，多磨练。","tags":[{"name":"小说","slug":"小说","permalink":"http://yutaiwei.github.io/tags/小说/"}]},{"title":"Express入门","date":"2016-12-05T14:09:59.000Z","path":"2016/12/05/Express入门/","text":".jpg) Express是node的后台快速开发框架 创建http服务 12345678910111213141516171819let http = require('http');let fs = require('fs');let url = require('url');http.createServer(function (req,res) &#123; var urlObj = url.parse(req.url,true); var pathname = urlObj.pathname; if (pathname == '/')&#123; res.end('首页') &#125; else if(pathname == '/user')&#123; res.end('用户') &#125; else &#123; res.statusCode = 404; res.end('Not Found') &#125;&#125;).listen(3000,function () &#123; console.log('3000端口成功监听')&#125;); 也可以写成12345let express = require('express');let app = express();app.listen(8080,function()&#123; console.log('8080端口已经成功启动，服务器监听正常')&#125;) express 是一个node模块12- npm install express//安装express方法 注意文件夹名字不能与module模块名字相同 1234567891011121314151617let express = require('express');let app = express();app.get('/',function (req,res) &#123; res.end('首页');&#125;);app.get('user',function (req,res) &#123; res.end('用户');&#125;);app.get('*',function (req,res) &#123; res.end('页面未找到'); //*代表所有路径&#125;);//get方法对应http的方法名 /对应于根路径express.listen(9090,function () &#123; console.log('9090监听成功')&#125;); 中间件 中间件的含义： 是一个函数,可以设置一些公共的逻辑，对所有的路由生效，next也是一个函数，调用它表示继续向下执行 中间件的作用：进行权限判断，添加一些公共的方法 1234app.use(function (req,res，next) &#123; res.setHeader('Content-Type','text/html,charset:utf-8'); next();&#125;); 路由中间件 是一个中间件，但是里面包含了路由规则，把路由进行分类，把不同的路由写在不同的模块里例如 12345678let express = require('express');let app = express();let user = require('./routes/user');let article = require('./routes/article');app.use('/user',user);app.use('/article',article);app.listen(9090);// 有请求到来的时候，先匹配路径前缀 如果匹配才交由后面的路由中间件来处理 ==使用cmd命令模拟发送post请求==1curl -v http://www.baidu.com node实现页面跳转(重定向) 返回到来时的页面 1res.redirect('back'); 跳到指定的页面 1234app.post('/signup',function(req,res)&#123; res.redirect('/signin'); //参数是一个URL地址，不是文件路径&#125;); express 中经常用到的模块汇总请求体解析模块——body-parser 可以将前台get方法传过来的路径内容，或者post方法传过来的参数直接解析 1234567891011npm install body-parser --savelet bodyParser = require('body-parser');app.use(bodyParser.urlencoded(&#123;extended:true&#125;));//extended:true 当extended为false的时候，键值对中的值就为'String'或'Array'形式，为true的时候，则可为任何数据类型。//请求体解析还有这种写法app.use(bodyParser.json());//urlencoded解析body中的urlencoded字符， 只支持utf-8的编码的字符,也支持自动的解析gzip和 zlib，.json这个方法返回一个仅仅用来解析json格式的中间件，能接受任何body中任何Unicode编码的字符。 ==一般请求中有json发送的时候就需要调用bodyParser.json的方法==以上内容写完之后，可以直接在如果是get方法传进来的参数可以用1res.qurey.xxx中获取到 如果是post方法传进来的参数可以用1res.body.xxx中获取到 1234567可以获取的请求内容console.log(req.method); console.log(req.url); console.log(req.path);// req.path = pathname console.log(req.query); console.log(req.headers); console.log(req.body); ==node还可以通过自带的req.params来获取请求url中的参数值== 路径解析模块——path 处理有关文件路径的内容 1let path = require('path'); 绝对路径：==path.resolve== 123456789path.resolve('foo/bar', '/tmp/file/', '..', 'a/../subfile');// 返回 /tmp/subfile// 此方法的参数类似于命令行中的cd命令eg:cd foo/barcd /tmp/file/cd ..cd a/../subfile// cd ..返回上一层 使用适合当前系统的链接符号，连接多个路径：==path-join== 12345console.log(path.join(__dirname,'path.js'));//参数只能是字符串eg：var str = path.join('./path/./', './upload', '/file', '123.jpg');console.log(str); // path/upload/file/123.jpg 路径整理：==path.normalize== 123var str = path.normalize('./path//upload/data/../file/./123.jpg');console.log(str); // path/upload/file/123.jpg//将杂乱的路径例如： path//upload/../file/./123.jpg整理为 path/upload/file/123.jpg正常路径 解析路径：==path.parse== 把一个路径解析为一个 {root:’’, dir:’’, base:’’, ext:’’, name:’’} 这样的对象。 123456789path.parse('/home/user/dir/file.txt')// returns&#123; root : \"/\", dir : \"/home/user/dir\", base : \"file.txt\", ext : \".txt\", name : \"file\"&#125; 更多path模块的使用方法参见：http://www.cnblogs.com/52cik/p/learn-node-path.html 在node环境中每个模块下，都可以通过1234__dirname// 获取当前文件所在的目录的绝对路径__filename//当前文件所在的绝对路径 express路由：Router 可以通过router配置路由 123456789101112131415let router = express.Router();eg:let express = require('express');//router也是一个容器，此容器下面可以配置路由let router = express.Router();router.get('/signup',function(req,res)&#123; res.end('注册');&#125;);router.get('/signin',function(req,res)&#123; res.end('登录');&#125;);router.get('/signout',function(req,res)&#123; res.end('退出');&#125;);module.exports = router; express控制cooike：cookie-parsercookie可以应用在很多场景，例如保存未登录账户的用户的购物车信息引入cookie-parser1let cookiePaser = require('cookie-parser'); 使用cookie-parser需要传入一个秘钥1app.use(cookieParser('mima')); 向客户端写cooike1res.cookie('name','zfpx') 读取客户端的cooike1req.cookies 通过domain来设置向哪个域名发送此次写入的cookie1res.cookie('path-name','zfpx',&#123;domain:'a.zfpx.cn'&#125;); path路径是指向哪个路径发请求的时候会发送此cookie1res.cookie('path-name','zfpx',&#123;path:'/read1'&#125;); 获取服务器时间12expires的参数是一个绝对的时间 2017年1月15日12:33:29res.cookie('expire-name','zfpx',&#123;expires:new Date(Date.now()+10*1000)&#125;); 设置cooike的生命周期12开始倒计时，到10秒后销毁此cookieres.cookie('maxAge-name','zfpx',&#123;maxAge:10*1000&#125;); eg：利用express实现一个访问量统计12345678910let express = require('express');let cookieParser = require('cookie-parser');let app = express();app.use(cookieParser());app.get('/visit',function(req,res)&#123; var visit = isNaN(req.cookies.visit)?1:parseInt(req.cookies.visit)+1; res.cookie('visit',visit); res.send(`欢迎您第$&#123;visit&#125;次访问`);&#125;);app.listen(3333); express的静态资源节点 static通过设置中间件的方式，将客户端发送来的静态资源请求找到设置的对应的文件路径，并将该路径下找到的同名文件返回给客户端。1234567eg:app.use(express.static(path.join(__dirname, 'public')));//解析public文件夹在服务器上的绝对路径，并将客户端发送的所有静态文件请求都从public上查找，并将找到的同名文件返回给客户端eg2:var resolve =file=&gt;path.resolve(__dirname, file);app.use('/dist',express.static(resolve('./dist')));//客户端访问时，带有/dist的路径的进行解析，并将/dist路径下的同名文件进行返回。","tags":[]},{"title":"Mongodb的使用","date":"2016-11-29T14:03:55.000Z","path":"2016/11/29/Mongodb的使用/","text":".jpg) 一个基于分布式文件储存的开源数据库 设置一个数据库的启动路径 12345mongod --dbpath=D:\\mangodata//mongod 为启动服务的可执行命令//-path 指定数据存放目录//此目录一定要提前创建好//如果显示waiting for connections on port 27017即为成功 MAC用户 http://www.zhufengpeixun.cn/doc/html/node%E5%91%A8%E6%9C%AB%E5%A4%A7%E7%BA%B2/5.mongodb.html 客户端命令 切换数据库 1use zfpx2017 查看当前数据库 1db 插入文档 1db.stu.insert(&#123;name:'zfpx'&#125;) 查找 1db.stu.find() 主键 一个文档中，最主要的键，是全局唯一的，永远不会变的—身份证号 node下使用 1234567891011let mongoose = require('mongoose');mongoose.Promise=Promise;//连接数据库 mongodb://ip:端口号/数据库名字mongoose.connect('mongodb://127.0.0.1/201612node');//定义数据库的模型骨架 不能直接操作数据库let PersonSchema = new mongoose.Schema(&#123; name:String, age:Number&#125;);//定义一个模型 Person-&gt;person-&gt;转复数形式 值就是集合的名称的来源let Person = mongoose.model('Person',PersonSchema); node下增加一条数据 123456Person.create(&#123;name:'zfpx',age:8&#125;,function(err,result)&#123; console.log(result);&#125;);Person.create(&#123;name:'zfpx',age:8&#125;).then(function(result)&#123; console.log(result);&#125;); node下查找一条数据 12345678910111213141516171819202122232425262728293031323334/** * find 查询所有符合条件的文档 [] undefined * findOne 查询最多一条符合条件的文档 对象 undefined */Person.findOne(&#123;_id: '5882d3272198e02a605a6e2f'&#125;,function(err,result)&#123; console.log(result);&#125;);//find方法也可以添加参数，限制查询的条件//控制返回的字段数量 name// 1 表示包含 ，只显示此字段，其他字段都不要// 0 表示排除 排除此字段，其他的都要Person.find(&#123;&#125;,&#123;name:0,age:0&#125;,function(err,docs)&#123; console.log(err); console.log(docs);&#125;);//也可以直接根据ID查询//根据ID查询对象Person.findById('5882e22c4c2d3b2d88067ed5',function(err,doc)&#123; console.log(doc);&#125;);//查询分页/** * 1.每页3条 * 2.查询第二页的数据 * 3.根据年龄倒序排列 */let pageSize = 3;let pageNum = 3;//排序 -1 倒序 1 表示升序//对服务器的数据请求是在exec的发出 的Person.find(&#123;&#125;).skip(pageSize*(pageNum-1)).limit(pageSize).sort(&#123;age:-1&#125;).exec(function(err,result)&#123; console.log(result);// 2 3 4 4 3 2&#125;) node下修改一条数据 1234567//&#123; ok: 1, nModified: 1, n: 1 &#125;// n匹配的条数 nModified实际更新的条数// 更新的时候，最多只会更新一条// multi 匹配多少条 更新多少条 3 4 默认是falsePerson.update(&#123;name:/g/&#125;,&#123;age:100&#125;,&#123;multi:true&#125;,function(err,result)&#123; console.log(result);&#125;); node下删除一条数据 123 Person.remove(&#123;&#125;,function(err,result)&#123; console.log(result.result);&#125;);","tags":[]},{"title":"Node基础开发框架","date":"2016-11-25T06:15:26.000Z","path":"2016/11/25/Node基础开发框架/","text":".jpg) 前言测试新功能，开发新项目，按照本人的懒惰程度推算，八成会在原有项目的基础上开发。既然如此，抽出来一个node基础框架，似乎是一个很好的想法。本框架保留了毕设的主体代码，删除了一些无关代码，并且会继续增减代码，逐渐完善。 nodebasea node framework designed for myselfversion: v1.0.0url: https://github.com/voidking/nodebase.git 作者相关author: haojin(voidking)e-mail: voidking@qq.comsite: http://www.voidking.com 开发环境说明1、安装5.6.0以上Node2、安装mongodb，不要配置密码3、安装sass4、全局安装bower5、全局安装supervisor6、全局安装node-inspector7、全局安装puer8、运行前执行命令12npm installbower install node实时调试命令12node-inspector --web-port=8888node --debug app.js 运行命令node app.js，访问http://localhost","tags":[{"name":"node","slug":"node","permalink":"http://yutaiwei.github.io/tags/node/"}]},{"title":"node中exports和module.exports的区别和联系","date":"2016-11-19T08:43:25.000Z","path":"2016/11/19/node中exports和module.exports的区别和联系/","text":".jpg) 前言 exports只是module.exports的辅助方法。你的模块最终返回module.exports给调用者，而不是exports。exports所做的事情是收集属性，如果module.exports当前没有任何属性的话，exports会把这些属性赋予module.exports。如果module.exports已经存在一些属性的话，那么exports中所用的东西都会被忽略。最初时，exports是module.exports的一个引用。(exports=global.exports)=(self.exports=module.exports) exports正常导出1234// caculate.jsexports.add = function (a, b) &#123; return a+b;&#125; 1234567// main.jsvar caculate = require('./caculate');exports.runAdd = function(req, res)&#123; var num = caculate.add(5,4); console.log(num);&#125; 在main模块中，可以正常调用caculate模块中的add函数。因为exports是module.exports的一个引用，所以exports.add=function(){}这个操作，把add函数加到了module.exports指向的对象（函数也是对象）中。而main模块中获取到的，就是caculate的module.exports指向的对象，自然也获取到了add函数。 exports错误导出1234// caculate.jsexports = function (a, b) &#123; return a+b;&#125; 12345678// main.jsvar caculate = require('./caculate');exports.runAdd = function(req, res)&#123; console.log(caculate); //var num = caculate(5, 4); //console.log(num);&#125; 如上的导出方法是错误的，我们可以看到打印出的caculate是一个空对象{}。因为exports原本是module.exports的一个引用，后来指向了一个函数。而module.exports的指向的对象，初始值就是空对象{}，自始至终都没有这个空对象添加属性或函数。所以，当main模块中获取到caculate的module.exports指向的对象时，依然是一个空对象{}。 module.exports导出123456789101112131415// caculate.jsexports.add = function (a, b) &#123; return a+b;&#125;var caculate = &#123; delete: function(a, b)&#123; return a-b; &#125;, multiple: function(a, b)&#123; return a*b; &#125;&#125;;module.exports = caculate; 12345678// main.jsvar caculate = require('./caculate');exports.runDelete = function(req, res)&#123; //var num = caculate.add(5, 4); var num = caculate.delete(5, 4); console.log(num);&#125; 如上导出方法，在caculate的module.exports指向的对象中，不会包含add函数。虽然exports.add=function(){}向module.exports指向的空对象{}中添加了一个add函数，但是紧接着，module.exports指向的对象改变了！变成了caculate对象。 seajs中module.exports和returnseajs中的exports和module.exports的关系，和Node中相同。 在进行插件CMD模块化时，发现module.exports和return基本相同。下面写个小例子：1234567// plugin.jsdefine(function(require, exports, module)&#123; module.exports = function(jQuery)&#123; // require('another-plugin')(jQuery); // 依赖jQuery的插件代码 &#125;&#125;) 1234567// plugin.jsdefine(function(require, exports, module)&#123; return function(jQuery)&#123; // require('another-plugin')(jQuery); // 依赖jQuery的插件代码 &#125;&#125;) 123seajs.use(['jquery','plugin'],function($,plugin)&#123; plugin($);//初始化&#125;); 书签Modules Node.js v6.3.0 Manual &amp; Documentationhttps://nodejs.org/api/modules.html#modules_the_module_object module.exports 还是 exports？http://zihua.li/2012/03/use-module-exports-or-exports-in-node/ nodejs中export与module.export的区别 SeaJS 中的 exports 和模块加载http://www.tuicool.com/articles/Y3qmAj","tags":[{"name":"node","slug":"node","permalink":"http://yutaiwei.github.io/tags/node/"},{"name":"exports","slug":"exports","permalink":"http://yutaiwei.github.io/tags/exports/"}]},{"title":"Node.js学习笔记（二）","date":"2016-11-12T11:30:27.000Z","path":"2016/11/12/Node.js学习笔记（二）/","text":".jpg) 整理自：慕课网 伪造模板数据跑通前后端交互流程本篇博客用到的代码，小伙伴们直接复制粘贴就可以了，你们可知道小编一行行敲得多么辛苦T_T，复制粘贴前给个赞啊！ 工程结构1234567891011121314helloworld/ -bower_components/ -node_modules/ -views/ -includes/ -head.jade -header.jade -pages/ -index.jade -detail.jade -admin.jade -list.jade -layout.jade -app.js 操作步骤我们在上次helloworld工程的基础上接着做！1、在views文件夹下新建文件夹includes和pages2、在views文件夹下，删除index.jade，新建layout.jade，输入内容：123456789doctypehtml head meta(charset=\"utf-8\") title #&#123;title&#125; include ./includes/head body include ./includes/header block content 3、在includes文件夹下，新建文件head.jade和header.jade，分别输入内容：123link(href=\"/bootstrap/dist/css/bootstrap.min.css\",rel=\"stylesheet\")script(src=\"/jquery/dist/jquery.min.js\")script(src=\"/bootstrap/dist/js/bootstrap.min.js\") 12345.container .row .page-header h1 #&#123;title&#125; small 天印电影 4、在pages文件夹下，新建文件index.jade、detail.jade、admin.jade和list.jade，分别输入内容：1234567891011121314extends ../layoutblock content .container .row each item in movies .col-md-2 .thumbnail a(href=\"/movie/#&#123;item._id&#125;\") img(src=\"#&#123;item.poster&#125;\",alt=\"#&#123;item.title&#125;\") .caption h3 #&#123;item.title&#125; p: a.btn.btn-primary(href=\"/movie/#&#123;item._id&#125;\",role=\"button\") 观看预告片 123456789101112131415161718192021extends ../layoutblock content .container .row .col-md-7 embed(src=\"#&#123;movie.flash&#125;\",allowFullScreen=\"true\",quality=\"high\",width=\"720\",height=\"500\",align=\"middle\",type=\"application/x-shock\") .col-md-5 dl.dl-horizontal dt 电影名字 dd= movie.title dt 导演 dd= movie.doctor dt 国家 dd= movie.country dt 语言 dd= movie.language dt 上映年份 dd= movie.year dt 简介 dd= movie.summary 1234567891011121314151617181920212223242526272829303132333435363738394041424344extends ../layoutblock content .container .row form.form-horizontal(method=\"post\",action=\"/admin/movie/new\") .form-group label.col-sm-3.control-label(for=\"inputTitle\") 电影名字 .col-sm-10 input#inputTitle.form-control(type=\"text\",name=\"movie[title]\",value=\"#&#123;movie.title&#125;\") .form-group label.col-sm-3.control-label(for=\"inputDoctor\") 导演 .col-sm-10 input#inputTitle.form-control(type=\"text\",name=\"movie[doctor]\",value=\"#&#123;movie.doctor&#125;\") .form-group label.col-sm-3.control-label(for=\"inputCountry\") 国家 .col-sm-10 input#inputTitle.form-control(type=\"text\",name=\"movie[country]\",value=\"#&#123;movie.country&#125;\") .form-group label.col-sm-3.control-label(for=\"inputLanguage\") 语言 .col-sm-10 input#inputTitle.form-control(type=\"text\",name=\"movie[language]\",value=\"#&#123;movie.language&#125;\") .form-group label.col-sm-3.control-label(for=\"inputYear\") 上映年份 .col-sm-10 input#inputTitle.form-control(type=\"text\",name=\"movie[year]\",value=\"#&#123;movie.year&#125;\") .form-group label.col-sm-3.control-label(for=\"inputSummary\") 简介 .col-sm-10 input#inputTitle.form-control(type=\"text\",name=\"movie[summary]\",value=\"#&#123;movie.summary&#125;\") .form-group label.col-sm-3.control-label(for=\"inputPoster\") 海报地址 .col-sm-10 input#inputTitle.form-control(type=\"text\",name=\"movie[poster]\",value=\"#&#123;movie.poster&#125;\") .form-group label.col-sm-3.control-label(for=\"inputFlash\") 片源地址 .col-sm-10 input#inputTitle.form-control(type=\"text\",name=\"movie[flash]\",value=\"#&#123;movie.flash&#125;\") .form-group .col-sm-offset-2.col-sum-10 button.btn.btn-default(type=\"submit\") 录入 12345678910111213141516171819202122232425262728extends ../layoutblock content .container .row table.table.table-hover.table-bordered thead tr th 电影名称 th 导演 th 国家 th 上映年份 //- th 录入时间 th 查看 th 修改 th 删除 tbody each item in movies tr(class=\"item-id-#&#123;item._id&#125;\") td #&#123;item.title&#125; td #&#123;item.doctor&#125; td #&#123;item.country&#125; td #&#123;item.year&#125; //- td #&#123;moment(item.meta.createdAt).format('MM/DD/YYYY')&#125; td: a(target=\"_blank\",href=\"../movie/#&#123;item._id&#125;\") 查看 td: a(target=\"_blank\",href=\"../admin/update/#&#123;item._id&#125;\") 修改 td button.btn.btn-danger.del(type=\"button\",data-id=\"#&#123;item._id&#125;\") 删除 5、修改helloworld文件夹下app.js，主要是加入模拟数据，内容如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192var express = require('express');var path = require('path');var port = process.env.PORT || 3000 ;var app = express();app.set('views','./views/pages');app.set('view engine','jade');app.use(express.bodyParser());app.use(express.static(path.join(__dirname, 'bower_components')));app.listen(port);console.log('helloworld started on port ' + port);app.get('/', function(req, res)&#123; res.render('index',&#123; title:'首页', movies: [ &#123; title: '机械战警', _id: 1, poster: 'http://ihelloworld.qiniudn.com/%40%2Fimgs%2FiNJIT.jpg', &#125;, &#123; title: '机械战警', _id: 2, poster: 'http://ihelloworld.qiniudn.com/%40%2Fimgs%2FiNJIT.jpg', &#125; ] &#125;)&#125;)app.get('/movie/:id', function(req, res)&#123; res.render('detail',&#123; title:'详情页', movie: &#123; doctor: '未知', country: '美国', title: '机械战警', year: '2014', poster: 'http://ihelloworld.qiniudn.com/%40%2Fimgs%2FiNJIT.jpg', language: '英语', flash: 'http://player.youku.com/player.php/sid/XNjM3Njc3MTY4/v.swf', summary: '无', &#125; &#125;)&#125;)app.get('/admin/movie', function(req, res)&#123; res.render('admin',&#123; title:'后台录入页', movie: &#123; doctor: '', country: '', title: '', year: '', poster: '', language: '', flash: '', summary: '', &#125; &#125;)&#125;)app.get('/admin/list', function(req, res)&#123; res.render('list',&#123; title:'列表页', movies: [ &#123; _id: 1, doctor: '未知', country: '美国', title: '机械战警', year: '2014', poster: 'http://ihelloworld.qiniudn.com/%40%2Fimgs%2FiNJIT.jpg', language: '英语', flash: 'http://player.youku.com/player.php/sid/XNjM3Njc3MTY4/v.swf', summary: '无', &#125;, &#123; _id: 2, doctor: '未知', country: '美国', title: '机械战警', year: '2014', poster: 'http://ihelloworld.qiniudn.com/%40%2Fimgs%2FiNJIT.jpg', language: '英语', flash: 'http://player.youku.com/player.php/sid/XNjM3Njc3MTY4/v.swf', summary: '无', &#125; ] &#125;)&#125;) 报错处理至此，已经敲完了Scott大神给的代码，马上就能看到效果了，好激动！哎呦我靠！报错，我改！又报错，我再改！还报错……诶？坏了，改不出来了！记录错误如下：百度“nodejs使用app.use(express.bodyParser());出错”，得到如下结论：1、node.js和windows的兼容性不如POSIX操作系统，因此npm提供给windows的第三方模块较少。2、bodyParser以前是集成在express中的，现在需要单独安装。无论哪个结论，解决办法都是安装body-parser：1npm install body-parser 然后在代码中如下使用： var bodyParser = require(‘body-parser’);app.use(bodyParser.urlencoded({ extended: false }))app.use(bodyParser.json()); 即把app.js的内容修改为如下内容：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394var express = require('express');var path = require('path');var port = process.env.PORT || 3000 ;var app = express();var bodyParser = require('body-parser');app.set('views','./views/pages');app.set('view engine','jade');app.use(bodyParser.urlencoded(&#123; extended: false &#125;))app.use(bodyParser.json());app.use(express.static(path.join(__dirname, 'bower_components')));app.listen(port);console.log('helloworld started on port ' + port);app.get('/', function(req, res)&#123; res.render('index',&#123; title:'首页', movies: [ &#123; title: '机械战警', _id: 1, poster: 'http://ihelloworld.qiniudn.com/%40%2Fimgs%2FiNJIT.jpg', &#125;, &#123; title: '机械战警', _id: 2, poster: 'http://ihelloworld.qiniudn.com/%40%2Fimgs%2FiNJIT.jpg', &#125; ] &#125;)&#125;)app.get('/movie/:id', function(req, res)&#123; res.render('detail',&#123; title:'详情页', movie: &#123; doctor: '未知', country: '美国', title: '机械战警', year: '2014', poster: 'http://ihelloworld.qiniudn.com/%40%2Fimgs%2FiNJIT.jpg', language: '英语', flash: 'http://player.youku.com/player.php/sid/XNjM3Njc3MTY4/v.swf', summary: '无', &#125; &#125;)&#125;)app.get('/admin/movie', function(req, res)&#123; res.render('admin',&#123; title:'后台录入页', movie: &#123; doctor: '', country: '', title: '', year: '', poster: '', language: '', flash: '', summary: '', &#125; &#125;)&#125;)app.get('/admin/list', function(req, res)&#123; res.render('list',&#123; title:'列表页', movies: [ &#123; _id: 1, doctor: '未知', country: '美国', title: '机械战警', year: '2014', poster: 'http://ihelloworld.qiniudn.com/%40%2Fimgs%2FiNJIT.jpg', language: '英语', flash: 'http://player.youku.com/player.php/sid/XNjM3Njc3MTY4/v.swf', summary: '无', &#125;, &#123; _id: 2, doctor: '未知', country: '美国', title: '机械战警', year: '2014', poster: 'http://ihelloworld.qiniudn.com/%40%2Fimgs%2FiNJIT.jpg', language: '英语', flash: 'http://player.youku.com/player.php/sid/XNjM3Njc3MTY4/v.swf', summary: '无', &#125; ] &#125;)&#125;) 效果图吼吼，终于搞定了！有图有真相！ 结束操作过程中的其他小错误，在此不作记录，有任何问题欢迎留言！","tags":[{"name":"node.js","slug":"node-js","permalink":"http://yutaiwei.github.io/tags/node-js/"}]},{"title":"Node.js学习笔记（一）","date":"2016-11-05T12:30:31.000Z","path":"2016/11/05/Node.js学习笔记（一）/","text":".jpg) 整理自：慕课网 helloworld工程的搭建技术及工具 node.js + mongodb(工具mongoose) + express + jade + moment.js + npm + jquery + bootstrap + grunt 我靠，那么多！淡定，暂时，咱们这个工程只要 node.js + express + jade 。 准备工作下载安装node.js。 工程结构123456helloworld/ -node_modules/ -bower_components/ -views/ -index.jade -app.js 上两张图，直观感受下： 具体操作新建helloworld文件夹在F盘下新建个文件夹叫做“ helloworld ”，然后打开命令提示符，cd命令进入F盘下的helloworld文件夹。 执行以下命令：12345npm install expressnpm install jadenpm install mongodbnpm install bower -gbower install bootstrap 查看文件夹看看helloworld文件夹，诶？结构和你给的不一样啊！那就对了，咱接着搞！ 新建文件在helloworld文件夹下，新建文件app.js，输入内容如下：12345678910111213var express = require('express');var port = process.env.PORT || 3000 ;var app = express();app.set('views','./views');app.set('view engine','jade');app.listen(port);console.log('helloworld started on port ' + port);app.get('/', function(req, res)&#123; res.render('index',&#123;title:'helloworld'&#125;);&#125;); 至于这段代码的意思，请自行观看视频哈！在views文件夹下，新建文件index.jade（这个文件就相当于html文件），输入内容如下：1234567doctypehtml head meta(charset=\"utf-8\") title #&#123;title&#125; body h1 #&#123;title&#125; 至此，大功告成！ 查看效果在helloworld文件夹下执行命令：1node app.js 在浏览器中打开：http://localhost:3000有没有看到“helloworld”这个出现在了浏览器上？没看到？请留言！PS：你也可以新建admin.jade，也输入和index.jade相同的代码。然后在app.js添加如下代码：123app.get('/admin/', function(req, res)&#123; res.render('admin',&#123;title:'admin'&#125;);&#125;); 访问地址：http://localhost:3000/admin/这时你会看到“admin”出现在了浏览器上！ 结束好了，今天的笔记就写到这里！有任何问题欢迎留言。","tags":[{"name":"node.js","slug":"node-js","permalink":"http://yutaiwei.github.io/tags/node-js/"}]},{"title":"金钱能买来幸福吗","date":"2016-10-20T14:38:18.000Z","path":"2016/10/20/金钱能买来幸福吗/","text":".jpg) 译者：裘霜 金钱能买来幸福吗？这是一个古老的问题。 在过去几年中，新的研究让我们对获得和感受之间的关系有了更深入的了解。在许多国家，经济学家一直在审视收入和幸福的关系；心理学家对人类个体的研究发现了在涉及现金时，是什么真正令我们怦然心动。 乍看起来，结果似乎有点显而易见：是的，从广义上说，高收入者比勉强摆脱贫困的人更快乐。 不过，对发现进行更深入的探究之后，他们得到了大量更令人惊讶、也更加有用的结论。 简而言之，最新研究表明，财富本身并不能为美好生活提供任何保证。比高收入更为重要的，是人们如何花钱。举例来说，与为自己花钱相比，为别人花钱更令人愉快。而且，当人们把钱花在自己身上时，花钱旅游、增长见识，比购买物质产品更让人感到持久的幸福。 让我们看看对于指导人们更明智地使用金钱、最大限度地提升幸福感方面，最新研究有哪些高见。 经历的价值超出想象 最近，瑞安·豪威尔被一个难题所困扰。过去10年间进行的大量研究表明，相对于物质商品，生活经历赋予我们的快乐明明更持久，可为什么人们在考虑如何花钱时，还是常常否定经历的价值，优先购买物质产品？ 作为旧金山州立大学心理学副教授，瑞安·豪威尔决定一探究竟。他发现，人们之所以认为买东西能够更好地体现金钱的价值，是因为经历总是转瞬即逝，但物质产品却一直在那里，看得见、摸得着，可以反复使用。所以，尽管人们偶尔会花一大笔钱去度假或购买演唱会门票，但在手头不甚宽裕的情况下，他们坚持把有限的金钱用来购买物质产品。豪威尔说：“人们认为经历只能提供短暂的快乐，但实际上，它能提供更多的快乐和更持久的价值。” 美国康奈尔大学心理学教授托马斯·季洛维奇也得出了类似的结论。“人们常常进行理性的计算：我的钱有限，要么出去玩，要么买东西。如果我出去玩，会很不错，但很快就结束了；如果我买东西，至少可以永远拥有它。这在事实上是正确的，但在心理层面上却未必，因为一旦买到手，我们很快会对自己物质财富习以为常。”这种过程叫做“享乐适应”，它使得人们难以通过购买物质感受到长久的幸福。新衣服或时髦汽车可以让人获得短暂的快感，但我们很快就认为它们理所当然了。 另一方面，季洛维奇教授认为，经历往往能够满足我们更多潜在的心理需求。旅行虽然很快结束，但我们可以经常与其他人共享自己的经历，不但能与他人有更广泛的联系，还有利于形成更高的认同感。如果您攀登过喜马拉雅山，那么，即使很久以后所有钟爱的小玩意儿都被抛在脑后，您还可以常常回忆和谈论这段经历。 更重要的是，我们往往不会拿自己的经历跟他人攀比，而物质方面的攀比要突出得多。季洛维奇教授说：“想象一下您刚刚买了一台新电脑，非常喜欢、满足，接着您的一位朋友出现了，说他也刚买了一台电脑，显示屏比您那台更亮、处理器更快。您该觉得多不爽啊！但是，如果您和您的朋友同时去度假，哪怕朋友去的地儿比您去的地儿更酷炫，您仍然拥有自己的经历和回忆，便不会那么闹心了。” 季洛维奇教授和他的同事们还发现，期待一段美妙的经历，要比等着购买实际有形的商品更能带来快感。等待一个事件的发生一般会令人兴奋，而期待物质性的东西则“似乎让人不耐烦”。 不要对所购物品习以为常 拥有更多物质并不总让我们欣喜，其中一个主要原因是我们习以为常了。“人类极其擅于习惯生活中的变化，尤其是积极的变化。”加州河滨大学心理学教授索尼娅·吕波密斯基说，“如果您的收入增加了，会给您带来快乐，但您的愿望也会跟着水涨船高。增加的收入也许能让您在更好的小区买更大的房子，结果那里的邻居们也更有钱，您想要的反而更多了。您已经踩上了‘享乐跑步机’，试图让它停下来或减慢速度，确实是一种挑战。” 吕波密斯基教授说，一种可行的方法是尽量有意识地欣赏和感谢您所拥有的，时常提醒自己敝帚自珍，将“享乐跑步机”的速度减缓下来。具体做法很简单，比如每天安排固定的时间，数数自己的幸福，又或者您可能想记日记，或者向他人表达感激之情。关键是要找到一种方法，对自己所拥有的一切保持清醒的认识，避免简单地把它们摆在四周。 吕波密斯基教授坦承，因为您是在与自己的自然倾向作斗争，所以，感激和赞赏很难持久。如果您的日记或每日感谢变成了乏味的例行公事，就不再有什么作用了。您可能需要变换使用其他技巧。 增加多样性、新颖性或惊喜，也可以帮助您更珍惜自己的所有。比方说，如果把一幅画挂在同一面墙的同一个位置，除了刚买回家的那段日子，您不会再多看它一眼。但是，如果把它与另一个房间的另一幅画对调，您就会用新鲜的眼光观看两幅画，而且会更欣赏它们。 吕波密斯基教授还建议，应尝试与他人分享您的所有，并敞开心扉，迎接新体验。这意味着您可以把自己的东西借给别人，或者与他人分享。吕波密斯基教授做了一个实验，给实验对象每人家里寄去一大包巧克力，告诉其中一些人尽可能多吃，告诉另一些人不准吃，第三组人可以自行选择吃多少。 结果如何呢？现在再面对巧克力，与可以敞怀吃、或按照通常食量吃的人相比，被禁止吃巧克力的人吃得更有滋有味。“暂时放弃一些东西确实有助于我们保持乐在其中的能力。”吕波密斯基教授说。 试着给别人钱 说到钱，一种自相矛盾的现象是，虽然赚更多的钱可能会提升我们的幸福感，但是，给别人钱却比为自己花钱更令人快乐。 这一结果是从吕波密斯基教授的一系列研究中发现的。一开始她在校园里向学生随意派发现金，并告诉一些人要把钱花在自己身上，告诉另一些人把钱花在别人身上。结果显示，后者比前者更开心。 此后，吕波密斯基教授反复在世界各地的不同国家重复这一实验，并将实验方式拓展为让人们送出自己的钱，而不是从教授那里白得的现金，以观察人们是否依然高兴。她发现，在加拿大、南非和乌干达等不同国家，施舍金钱都让人们更快乐，无一例外。即使在那些贫困国家，当人们囊中羞涩时，送出自己的钱仍然令人快乐不已。 吕波密斯基教授还与来自100个国家的经济学家分析了盖洛普世界民意调查数据，结果发现，向慈善机构捐款的人更加快乐，在穷国和富国皆是如此。“我们能够在加拿大观察到与南非和乌干达等地一模一样的效果，在我的从业生涯中，这无疑是最大的惊喜。”她说，“很多人的想法是，等我有钱了，就向慈善机构捐款，但实际上我们看到的乐于奉献的人，往往是正在贫困线上挣扎、努力满足自身基本需要的人。” 就幸福而言，指针的移动与您拥有的金钱数额关系不大，但与您的捐款所产生的效应密切相关。如果您看到自己的钱让别人的生活有所不同，就会使您快乐，即使您出资的数额微不足道。 还要确保花钱买时间 同样重要的一点是，您买回来的东西会怎样影响您安排自己的时间。在郊区购置大宅似乎是一个不错的主意，但研究人员发现，在其他条件不变的前提下，长时间通勤时间会降低总体生活满意度。据计算，您需要加薪40%，才能抵消1小时通勤所增加的痛苦。 “花钱买时间更划算，”吕波密斯基教授说，“不要购买一辆更花哨的汽车，除了每天上下班的时候坐在车里，您不会在其他时间需要它。与其在郊区买别墅，每天长时间通勤，不如在市区购买一处离工作地点很近的小房子，如此一来，您就可以利用日落前1小时与您的孩子在公园里踢踢球。” 另一种为自己购买时间的方式是把不喜欢的工作外包出去。聘请私人助理曾经是富人的专利，但现在人们可以更方便、更实惠地雇佣自由职业者，或在网络上找专业人士，帮自己完成日常管理，或单个任务。 目前，吕波密斯基教授正在做的研究涉及到人们外包任务后如何安排因此所节省的时间，以及这样做是否使他们更快乐。初步调查结果表明，通过为自己购买时间，大多数人确实变得更加快乐，但前提是他们使用时间的方法正确无误。如果人们将它视为是“意外得到的时间”，并真的用它做点计划之外、让我们更加快乐的事，我们才能在情感上受益。 不过，虽然购买时间不失为一个好主意，但总是用金钱来衡量时间的价值却未必可行。一旦人们把自己的时间当做金钱，便不太可能花时间去做没有经济收益的事，即使是少量时间也不行。因此，将时间当做金钱也会造成一些破坏性后果。 钱只会在一定程度上带来幸福 幸福的第一个衡量指标是“可评估性”，吕波密斯基教授将其定义为：“从某种意义上说，您的生活是美好的——您对自己的生活满意，正在朝着人生目标迈进。”经济学家们对世界各地的经济数据和幸福调查进行了广泛的研究比对，非常明显的证据表明，在世界各地几乎每一个国家，富人都比穷人更幸福，富裕国家的人比贫穷国家的人更幸福。 幸福的另一个要素是“情感性”，吕波密斯基教授解释说，这是指一个人经历愉悦、喜欢和安宁等正面情绪和与此相对的负面情绪的频率。“您也许整体上对自己的生活感到满意，但其实真正开心的时候不多。”她说，“当然了，快乐的人也会体验到负面情绪，只是没那么频繁。所以幸福其实是由‘可评估性’和‘情感性’两个部分组成。” 当研究者审视情感性指标时，一户家庭的年收入一旦达到7.5万美元，他们的幸福感便不再随着钱的增多而递增。总之，当您钱不多的时候，额外一点点钱就会让您开心很久，因为您有能力满足更多基本需求了。然而，一旦您积累了一定财富，再想“买到”更多幸福就变得难上加难。 切忌入不敷出 最后，虽然关于金钱与幸福的许多研究都侧重于如何花钱而不是如何省钱，研究者认为，入不敷出将招致灾难。关照好您的基本需求，确保一定程度上的金融安全，是非常重要的。 季洛维奇教授认为，虽然他的研究表明，相对于物质产品而言，生活经历能够给予人们更多幸福，但人们首先当然应该购买必需品。尽管他的研究结果可以涵盖各个收入水平的人群，但却不适用于收入非常低的人群。他说：“那些人真的无法自由支配收入，手里的钱几乎全部用于购买必需品了。” 研究还表明，债务对幸福感产生不利影响，而储蓄和金融安全往往会提升幸福感。一项关于英国家庭的调查发现，那些债务水平较高的人群拥有较低的幸福感，而一项针对已婚夫妇的研究则显示，更多债务意味着更多婚姻冲突。“储蓄有利于促进幸福;债务不利于幸福。但是，债务的弊端大于储蓄所带来的好处。”吕波密斯基教授说，“从幸福的角度来看，更重要的是摆脱债务，而不是增加储蓄。” 所以，在您走出去、花大钱享受梦想假期之前，请确保您已经照顾好自己的基本需要，还清了债务，并有足够的钱防范生活中最糟糕的事情从天而降。如果您为了获得一流的人生经历而举债度日，那么，当信用卡账单到来时，一流的人生经历所带来的快乐将被还款压力一笔勾销。","tags":[{"name":"读者","slug":"读者","permalink":"http://yutaiwei.github.io/tags/读者/"},{"name":"裘霜","slug":"裘霜","permalink":"http://yutaiwei.github.io/tags/裘霜/"}]},{"title":"你总会信仰些什么","date":"2016-10-19T02:24:06.000Z","path":"2016/10/19/你总会信仰些什么/","text":".jpg) 作者：白岩松 读书读久了，你总会信仰些什么。 当我们翻开一本书，要在翻开的这本书里头寻找到什么呢？这个话题似乎要从我们刚刚出生来到这个世界上开始说起。当人生的这本书刚刚翻开，在未来漫长的岁月里，在这本书里，我们又要寻找到什么呢？也许两者的答案有很多是相似的。首先翻开一本书，我们希望知道自己是谁，我的家乡在哪里，而世界又在哪里。如果我不打开书，我会以为世界就像我生活的这座城市一样，有草原，有森林，有很多和善的人们。但是当我打开书才知道，《上下五千年》里有那么多的历史；当我打开书的时候，我知道在《一千零一夜》里还有另外一个跟我们完全不一样的世界；当我打开书的时候才知道有好人、有坏人；当我打开书的时候才知道，北京、江苏、四川或者其他的地方怎么怎么样。了解的事情越来越多了，这个世界开始变得越来越大了，结果一个又一个少年该如同我一样，开始向往外面的世界。如果没有书，你不会知道世界是个什么概念，即便后来当你的年岁足够大了，当你来到一个又一个陌生的国度里，你竟然发现一切似乎没那么陌生，因为早在白纸黑字上，早在字里行间，早在曾经翻开的一本又一本书当中，你曾经如此亲密地靠近过它，世界变得不再那么遥远，也不再那么陌生了。 说起来真的有意思，总有很多人问我，对我影响最大的一本书是什么？我的答案永远是一样的，当然是《新华字典》了。如果要是没有《新华字典》，没有我从最简单的一个又一个汉字开始认识起，一直到后来，我怎么会有勇气、有能力翻开一本又一本或厚或薄的书呢？如果我不能翻开那些书，我的很多困惑、我的很多未知怎么能在我的面前陆续打开呢？成长是什么？成长不仅是年岁慢慢增长，更重要的是内心所累积的一个又一个问号慢慢地得到答案。 当你的答案越来越多，当你的问号开始慢慢地被抻直的时候，你就是在成长。最小的时候可能在读《十万个为什么》，获取一个又一个答案，如果没有那些书，答案不出现在你的面前，你就永远像是一个仰望星空的孩子。虽然在这一生当中葆有好奇，葆有问号，永远是一个最重要的事情，但是，在你成长的过程中，如果你的一个又一个问题不能得到解答的话，成长怎么可能变成现实呢？从你最初好奇的一加一等于二，到后来一加一等于二不再是一个简简单单的数学题，而是人生，是大的哲学，是你如何去捍卫常识；当别人因为自己的利益，能喊出一加一等于三，甚至等于四的时候，你还有勇气去坚持说一加一等于二。你想想我们走了多远的路程了。从最初只是一个最简单的小学的数学题到后来与常识、与正义、与真理有关，如果没有那一本又一本翻开的书，你怎么可能有这种成长呢？总有人问我读书有什么好处。我说用几个“解”来回答你吧，它可以解惑，它可以解气，有的时候你有很多这种郁闷和生气，打开书看到有与你同样生活在这个世界上的人，或者古人甚至都提前把那种呐喊替你发泄出来，你就觉得挺解气的。 另外，还解决你的很多挣扎和困惑。翻开一本又一本书的时候，你看到答案，拥有了一种解决的方案，道路变得更加清晰了。当然千万别忘了，看书还有另外的功能，那就是有的时候还解闷。哪怕现在人们开玩笑连解手的时候，都需要有那些看起来不那么累的书能陪伴你度过人生当中永远不会没有的这种时光。一天总是琐碎的，但是累加在一起却可能会获取很多知识，因此，我觉得一个能提供这么多“解”的书，会帮助一个又一个人更好地走这样一个成长的道路。 在我们寻找的无数答案当中，最后一种答案可能非常的重要。它帮助我们寻找到平静和幸福，我们可能都记着这样的一句话，“华北之大，已经安放不下一张平静的书桌了”。那是一个屈辱的时代。但是现代在物质大潮快速奔涌而来的时候，这句话可以稍微地变一变了，变成什么呢？ “中国之大，找到一颗平静的心简直太难了。”但是不平静又怎么可能幸福呢？我曾经有过这样的经历，周围是乱的，自己的心里也是乱的，当你打开书想在书里找到平静的时候，最初几页是很难的。但是当最初的几页慢慢读进去了，你就觉得好书真像是一堵又一堵的墙，开始慢慢地升腾起来，把外面的车水马龙还有那些喧嚣的声音都阻拦在了外面。这个时候，你觉得那颗躁动的心慢慢地安静下来，这个世界你似乎又可以在白纸黑字里闻得到花香，听得到鸟的声音，大自然仿佛又回到了你的身边。更重要的是没有平静怎么可能幸福呢？ 那么，幸福与读书、与平静有什么关系吗？很有关系，幸福是由三个关键词构成的，那就是物质、情感和精神。只有物质基础、情感依靠、精神支柱这三种因素的分数都不错，加起来你的幸福指数才高。而读书与这三者紧密相关，“读书无用论”的论调早已经慢慢消散了，那个时代也结束了。 早有调查显示，人们读书和知识获取的水平和你的工资收入是成正比的，我想只有你的读书足够多了，你才会更有创意，才会更自信，你才会更有底气，才能获取更多的物质回报。但是这还不是最重要的。书读得多了，你在情感方面会是一个充沛的、获益很多的人，你的依靠会更充实，更重要的是在读书中会寻找到我们的信仰和精神支柱。中国人的信仰千百年来并不是仅仅靠宗教来支撑的，它就在唐诗宋词当中，在爷爷姥姥讲给你的故事里，在《三国演义》里，在《红楼梦》里，在《西游记》里，在无数的经典书籍当中，至今依然被文人用那种美丽的方块字写在字里行间。 读书读久了你总会信一些什么，信一些什么就有了敬，有了畏，因为信仰我认为最重要的是“敬畏”二字。有了敬，有了畏，知道什么是最好的我要去做，知道什么是不好的我不能逾越它，就如同社会这条奔腾的大河两边有了安全的河床，敬和畏这两个河床在，不管这条河流如何奔涌，总是安全的。我们现在正处在慢慢建两边河床的过程中。 因此，如果更多的中国人能够多读书，能够让自己的心平静下来，能在这里慢慢找到幸福感并且找到自己的话，中国就会变得更好。也许读书不能解决所有的问题，但是读书可以改变很多，可以让我们一个又一个人变得更好。 当我们一个又一个人变得更好的时候，你什么样，中国就什么样。","tags":[{"name":"读者","slug":"读者","permalink":"http://yutaiwei.github.io/tags/读者/"},{"name":"白岩松","slug":"白岩松","permalink":"http://yutaiwei.github.io/tags/白岩松/"}]},{"title":"jQuery学习笔记——Ajax篇","date":"2016-10-15T12:10:14.000Z","path":"2016/10/15/jQuery学习笔记——Ajax篇/","text":".jpg) 显示欢迎信息Ajax的优点我们已经说过了，上个例子先！ 12345678910111213141516171819202122232425262728293031323334&lt;!--显示欢迎信息.html--&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;显示欢迎信息&lt;/title&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;script type=\"text/javascript\" src=\"jquery-1.11.1.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $(function()&#123; $(\"#submit\").click(function()&#123; var name = $(\".uname\").val(); var data = \"uname=\" + name; $.ajax(&#123; type:\"POST\", url:\"http://demo.voidking.com/welcome.php\", data:data, success: function(html)&#123; $(\"#message\").html(html); &#125; &#125;); return false; &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;form&gt; &lt;label&gt;Enter your name&lt;/label&gt; &lt;input type=\"text\" name=\"uname\" class=\"uname\" /&gt;&lt;br/&gt; &lt;input type=\"submit\" id=\"submit\"/&gt; &lt;/form&gt; &lt;div id=\"message\"&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 12345&lt;!--welcome.php--&gt;&lt;?php $name = $_POST['uname']; echo \"welcome \".$name;?&gt; 把ajax实例01.html、welcome.php、jquery-1.11.1.js上传到自己的服务器。打开浏览器访问“显示欢迎信息.html”，输入一个名字，就能看到效果了。 为什么要上传服务器，搞的这么麻烦？大哥，ajax主要就是用来和服务器交互的好不好？如果你觉得麻烦，可以直接访问我的服务器查看效果:VoidKing编程实例，接下来的例子也可以在这个网页找到。 当然，你也可以直接本地打开“显示欢迎信息.html”，但是提交数据没有反应，因为同源策略限制交互。怎么破？简单点，本地搭建一个php服务器！高大上点，自行百度，修改代码！ 执行认证12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"/&gt; &lt;title&gt;ajax实例02&lt;/title&gt; &lt;script src=\"jquery-1.11.1.js\" type=\"text/javascript\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $(function() &#123; $('#submit').click(function () &#123; var name = $('.uname').val(); var pwd = $('.passwd').val(); var data='uname='+name+'&amp;password='+pwd; $.ajax(&#123; type:\"GET\", url:\"logincheck.php\", data:data, success:function(html) &#123; $(\"#message\").html(html); &#125; &#125;); return false; &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;用户名输入guest，密码输入jquery，会出现欢迎信息，否则显示未注册&lt;/p&gt;&lt;br/&gt; &lt;form&gt; &lt;label&gt;Enter your Name&lt;/label&gt; &lt;input type=\"text\" name=\"uname\" class=\"uname\"/&gt; &lt;br/&gt; &lt;label&gt;Enter your Password&lt;/label&gt; &lt;input type=\"password\" name=\"password\" class=\"passwd\"/&gt; &lt;br/&gt; &lt;input type=\"submit\" id=\"submit\"/&gt; &lt;/form&gt; &lt;div id=\"message\"&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 123456789&lt;!--logincheck.php--&gt;&lt;?php $name = trim($_GET['uname']); $pswd = trim($_GET['password']); if(($name==\"guest\") &amp;&amp; ($pswd==\"jquery\")) echo \"Welcome \". $name;else echo \"Sorry you are not authorized\";?&gt; 验证用户名12345678910111213141516171819202122232425262728293031323334&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;验证用户名&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"jquery-1.11.1.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $(function() &#123; $('.error').hide(); $('#submit').click(function () &#123; var name = $('.uname').val(); var data='uname='+name; $.ajax(&#123; type:\"POST\", url:\"validateuser.php\", data:data, success:function(html) &#123; $('.error').show(); $('.error').text(html); &#125; &#125;); return false; &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;验证用户名，只能是数字、字母和下划线&lt;/p&gt;&lt;br/&gt; &lt;form&gt; &lt;span class=\"label\"&gt;Enter your Name&lt;/span&gt; &lt;input type=\"text\" name=\"uname\" class=\"uname\"/&gt; &lt;span class=\"error\"&gt; &lt;/span&gt;&lt;br&gt; &lt;input type=\"submit\" id=\"submit\"/&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 123456789101112&lt;!--validateuser.php--&gt;&lt;?php $name = $_POST['uname']; if (!eregi(\"^[a-zA-Z0-9_]+$\", $name)) &#123; echo \"Invalid User name!\";&#125;else&#123; echo \"Great user name!\";&#125;?&gt; 使用自动完成1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;使用自动完成&lt;/title&gt; &lt;style type=\"text/css\"&gt; .listbox &#123; position: relative; left: 10px; margin: 10px; width: 200px; background-color: #000; color: #fff; border: 2px solid #000; &#125; .nameslist &#123; margin: 0px; padding: 0px; list-style:none; &#125; .hover &#123; background-color: cyan; color: blue; &#125; &lt;/style&gt; &lt;script type=\"text/javascript\" src=\"jquery-1.11.1.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $(function() &#123; $('.listbox').hide(); $('.userid').keyup(function () &#123; var uid = $('.userid').val(); var data='userid='+uid; $.ajax(&#123; type:\"POST\", url:\"autocomplete.php\", data:data, success:function(html) &#123; $('.listbox').show(); $('.nameslist').html(html); $('li').hover(function()&#123; $(this).addClass('hover'); &#125;, function()&#123; $(this).removeClass('hover'); &#125;); $('li').click(function()&#123; $('.userid').val($(this).text()); $('.listbox').hide(); &#125;); &#125; &#125;); return false; &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;输入名字的第一个字符时，弹出建议框。&lt;/p&gt;&lt;br/&gt; &lt;form&gt; &lt;span class=\"label\"&gt;Enter user id&lt;/span&gt; &lt;input type=\"text\" name=\"userid\" class=\"userid\"/&gt; &lt;div class=\"listbox\"&gt; &lt;div class=\"nameslist\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 1234567891011121314&lt;?php $name = $_POST['userid']; $connect = mysql_connect(\"localhost\", \"demo\", \"voidking\") or die(\"Please, check your server connection.\"); mysql_select_db(\"demo\"); $query = \"SELECT name from user where name like '$name%'\"; $results = mysql_query($query) or die(mysql_error()); if($results) &#123; while ($row = mysql_fetch_array($results)) &#123; extract($row); echo '&lt;li&gt;' . $name. '&lt;/li&gt;'; &#125; &#125;?&gt; 导入HTML12345678910111213141516171819202122&lt;!--导入HTML--&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;导入HTML&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"jquery-1.11.1.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $(function() &#123; $('.list').click(function () &#123; $('#message').load('namesinfo.html'); return false; &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;单击超链接，从另一个文件中导入一些HTML内容到当前网页中。&lt;/p&gt;&lt;br/&gt; &lt;p&gt;We are going to organize the Conference on IT on 2nd Feb 2010&lt;/p&gt; &lt;a href=\"http://demo.voidking.com\" class=\"list\"&gt;Participants&lt;/a&gt; &lt;div id=\"message\"&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 123456789&lt;!--namesinfo.html--&gt;&lt;p&gt;The list of the persons taking part in conference &lt;/p&gt;&lt;ul&gt;&lt;li&gt;Jackub&lt;/li&gt;&lt;li&gt;Jenny&lt;/li&gt;&lt;li&gt;Jill&lt;/li&gt;&lt;li&gt;John&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;We wish them All the Best&lt;/p&gt; 取得JSON数据12345678910111213141516171819202122232425262728293031323334&lt;!--取得JSON数据--&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;取得JSON数据&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"jquery-1.11.1.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $(function() &#123; $('#submit').click(function () &#123; $.ajax(&#123; type:\"GET\", url:\"drinkinfo.json\", dataType:\"json\", success: function (data) &#123; var drinks=\"&lt;ul&gt;\"; $.each(data, function(i,n)&#123; drinks+=\"&lt;li&gt;\"+n[\"optiontext\"]+\"&lt;/li&gt;\"; &#125;); drinks+=\"&lt;/ul&gt;\"; $('#message').append(drinks); &#125; &#125;); return false; &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;从JSON文件中异步地导入信息到当前的网页中。&lt;/p&gt;&lt;br/&gt; &lt;p&gt;For information from JSON file click the button given below :&lt;br&gt; &lt;input type=\"submit\" id=\"submit\"/&gt; &lt;div id=\"message\"&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; drinkinfo.json文件内容如下：12345[ &#123;\"optiontext\" : \"Tea\", \"optionvalue\" : \"Tea\"&#125;, &#123;\"optiontext\" : \"Coffee\", \"optionvalue\" : \"Coffee\"&#125;, &#123;\"optiontext\" : \"Juice\", \"optionvalue\" : \"Juice\"&#125;] 矮油我靠，在服务器上打开浏览器，读取正常；在本地打开浏览器，居然无法读取，404错误！ 经过测试，只要把文件名更改一下就好了。即把drinkinfo.json改成drinkinfo.txt。真是个奇葩问题，个人猜测是浏览器传输文件有格式限制。 取得XML数据12345678910111213141516171819202122232425262728293031323334&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;取得XML数据&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"jquery-1.11.1.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $(document).ready(function() &#123; $('#submit').click(function () &#123; $.ajax(&#123; type:\"GET\", url:\"student.xml\", dataType:\"xml\", success: function (sturec) &#123; var stud=\"&lt;ul&gt;\"; $(sturec).find('student').each(function()&#123; var name = $(this).find('first-name').text() stud+=\"&lt;li&gt;\"+name+\"&lt;/li&gt;\"; &#125;); stud+=\"&lt;/ul&gt;\"; $('#message').append(stud); &#125; &#125;); return false; &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;从student.xml文件中异步导入信息到当前的网页中。&lt;/p&gt;&lt;br/&gt; &lt;p&gt;To see the Names of the students extracted from XML file click the button given below :&lt;/p&gt; &lt;input type=\"submit\" id=\"submit\"/&gt; &lt;div id=\"message\"&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; student.xml文件内容如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?xml version=\"1.0\" encoding=\"utf-8\" ?&gt;&lt;school&gt; &lt;student&gt; &lt;roll&gt;101&lt;/roll&gt; &lt;name&gt; &lt;first-name&gt;Anil&lt;/first-name&gt; &lt;last-name&gt;Sharma&lt;/last-name&gt; &lt;/name&gt; &lt;address&gt; &lt;street&gt; 22/10 Sri Nagar Road &lt;/street&gt; &lt;city&gt; Ajmer &lt;/city&gt; &lt;state&gt; Rajasthan &lt;/state&gt; &lt;/address&gt; &lt;marks&gt; 85 &lt;/marks&gt; &lt;/student&gt; &lt;student&gt; &lt;roll&gt;102&lt;/roll&gt; &lt;name&gt; &lt;first-name&gt;Manoj&lt;/first-name&gt; &lt;last-name&gt;Arora&lt;/last-name&gt; &lt;/name&gt; &lt;address&gt; &lt;street&gt; H.No 11-B Alwar Gate &lt;/street&gt; &lt;city&gt; Ajmer &lt;/city&gt; &lt;state&gt; Rajasthan &lt;/state&gt; &lt;/address&gt; &lt;marks&gt; 92 &lt;/marks&gt; &lt;/student&gt;&lt;/school&gt; 结束语以上例子，全部摘自《jQuery攻略》，不详解，看代码！ 参考文档李炎恢的jQuery视频教程《jQuery攻略（作者B.M.Harwani）》《jQuery实战（作者Bear Bibeault、Yehuda Katz）》《jQuery高级编程（作者 Cesar Otero、Rob Larsen）》《jQuery Javascript 与CSS开发入门经典（作者Richard York）》","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yutaiwei.github.io/tags/JavaScript/"},{"name":"jQuery","slug":"jQuery","permalink":"http://yutaiwei.github.io/tags/jQuery/"}]},{"title":"jQuery学习笔记——事件篇","date":"2016-10-15T08:09:44.000Z","path":"2016/10/15/jQuery学习笔记——事件篇/","text":".jpg) 前言任何基于GUI的现代应用程序都是基于事件驱动的，Web应用程序也不例外。 所有事件驱动的应用程序都采用相同的工作模式：建立事件机制、等待相关事件发生（比如鼠标单击）、对该事件做出相应。 浏览器事件模型忆苦思甜，先了解一下传统的事件模型的缺点，我们才能明白改革开放是多么好的政策！ DOM第0级事件模型也许你听说过网景事件模型、基本事件模型、浏览器事件模型，但是大多数人称其为DOM第0级事件模型。 为什么称其为第0级事件模型呢？因为，虽然该模型并不是一个正式的标准，但是所有主流的浏览器都与之兼容。而且，所有的现代浏览器依然支持这种模型。 插播广告几乎所有的标准、协议、规范，都是在一门技术出现甚至成熟之后，才会形成。所以，我们也不能责怪W3C组织，没有及时给网景推出的事件模型一个名分，毕竟技术要领先于标准。 DOM第2级事件模型等一下？void，你是不是把DOM第1级事件模型漏掉了？没有漏掉，因为没有DOM第1级事件模型。DOM级别1于1998年10月成为W3C推荐标准，但是，该标准中并没有定义事件相关的内容。直到2000年11月，DOM级别2被引入时，W3C才真正为事件处理建立了标准模型。 这个模型得到了所有标准兼容的现代浏览器的支持，比如Firefox、Safari、Opera等。IE浏览器特立独行，它支持DOM第2级事件模型的一个功能子集。 IE事件模型刚才说到，IE不支持DOM第2级事件模型。IE为每个DOM元素定义了一个名为attachEvent()的方法，而不是addEventListener()。 小结以上你可以认为是废话……总而言之，想要使用事件模型，不得不考虑到兼容问题，非常麻烦！这时，我们的jQuery事件模型华丽登场！ jQuery事件模型，jQuery把不一致的代码从页面代码中提取出来，将其隐藏在API中，因此，我们终于不用再去考虑兼容性问题！ 使用jQuery绑定事件处理器1234567891011121314&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;script type=\"text/javascript\" src=\"jquery-1.10.2.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $(function()&#123; $(\"img\").bind(\"click\",function()&#123;alert(\"hello voidking\");&#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;img src=\"./head.jpg\" alt=\"头像\"/&gt; &lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;script type=\"text/javascript\" src=\"jquery-1.10.2.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $(function()&#123; $(\"#voidking\") .bind(\"click\",function()&#123; alert(\"hello voidking once!\"); &#125;) .bind(\"click\",function()&#123; alert(\"hello voidking twice!\"); &#125;) .bind(\"click\",function()&#123; alert(\"hello voidking three times!\"); &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;img id=\"voidking\" src=\"./head.jpg\" alt=\"头像\"/&gt; &lt;/body&gt;&lt;/html&gt; 由上面两段代码我们发现，绑定事件很简单，只需要一个bind()函数。而且，一个事件可以对应多个处理器。除了bind()函数，jQuery还为创建特定的事件处理器提供了一些便捷方法。比如one、focusin、focusout等。 删除事件处理器创建了一个事件处理器，那么它在页面剩余的生命周期里就是有效的。但是一些特殊的交互，要求根据一定标准删除处理器。这时我们就要用到unbind()函数，jQuery考虑的很周到啊！123456789101112131415161718192021222324&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;script type=\"text/javascript\" src=\"jquery-1.10.2.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $(function()&#123; $(\"#voidking1\").bind(\"click.voidking\",function()&#123; alert(\"hello voidking1\"); $(\"*\").unbind('click.voidking'); &#125;); $(\"#voidking2\").bind(\"click.voidking\",function()&#123; alert(\"hello voidking2\"); $(\"*\").unbind('click.voidking'); &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;img id=\"voidking1\" src=\"./head.jpg\" alt=\"头像\"/&gt; &lt;img id=\"voidking2\" src=\"./head.jpg\" alt=\"头像\"/&gt; &lt;/body&gt;&lt;/html&gt; 上面这个例子中，我们实现了一个效果：有任何一张图片被点击了一次，那么两张图都不可以再被点击。 Event实例使用bind()方法，无论是什么浏览器，Event实例都会作为第一个参数传入函数。 那么，怎么处理不同浏览器中Event实例中属性的差异呢？原来，jQuery定义了一个jQuery.Event对象，真正传入的函数的，是这个对象。这个对象复制了大部分原始Event的属性，忽略了Event实例的差异性。就像是一个接口，我们不需要管它怎么实现，只要调用就好了！ 预先管理事件处理器当混合使用Ajax时，我们可能在页面的生命周期内频繁引入DOM元素或删除它们。在管理这些动态元素的事件处理器时，就绪处理器就起不到多大作用了，因为这些动态元素在就绪处理器执行时还不存在。 jQuery提供了live()方法，该方法允许预先为那些不存在的元素创建事件处理器。它的语法和bind()非常相似，看上去似乎比bind()更加强大，那么，用live()代替bind()不就好了吗？不是的，首先，“live”事件不是原生的“普通”事件。其次，live()方法只能应用于选择器，不能应用于衍生而来的包装集。 这里不再举例，下面的Ajax会详细探讨。 live()创建的选择器可以使用die()方法来解除绑定，语法和unbind()相似。 触发事件处理器触发事件，听起来就很难懂的样子，我们换个说法：模拟用户动作。比如点击，我们可以用代码去模拟用户点击，达到的效果与真实的鼠标点击是一样的。 12345678910111213141516171819202122232425262728293031323334353637383940&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;script type=\"text/javascript\" src=\"jquery-1.10.2.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $(function()&#123; $(\"#voidking\").bind(\"click\",function()&#123; alert(\"hello voidking\"); &#125;); $(\"#voidking\").click();//模拟用户单击事件 $(\"#voidking\").trigger(\"click\");//模拟用户单击事件 $(\"p\").bind(\"myEvent\", function (event, message1, message2) &#123; alert(message1 + ' ' + message2); &#125;); $(\"p\").trigger(\"myEvent\", [\"hello\",\"trigger\"]); //弹出两次 $('p').triggerHandler(\"myEvent\",[\"hello\",\"triggerHandler\"]); //弹出一次，只触发第一个p元素 $(\"input\").select(function()&#123; &#125;); $(\"#trigger\").click(function()&#123; $(\"input\").trigger(\"select\");//触发select事件，执行select默认操作和select处理器内操作 &#125;); $(\"#triggerHandler\").click(function()&#123; $(\"input\").triggerHandler(\"select\");//触发select事件，但是不会执行select默认操作 &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;img id=\"voidking\" src=\"./head.jpg\" alt=\"头像\"/&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;input type=\"text\" value=\"hello voidking\" /&gt; &lt;br /&gt; &lt;button id=\"trigger\"&gt;激活select事件，同时选中文本&lt;/button&gt;&lt;/br&gt; &lt;button id=\"triggerHandler\"&gt;激活select事件，不选中文本&lt;/button&gt; &lt;/body&gt;&lt;/html&gt; 上面这个例子，基本上涵盖了触发事件管理器的所有知识点。这里不详细解释了，自己看注释，不懂的请百度或留言。 更多toggle: 这个方法在jQuery 1.8中宣告过时，在jQuery 1.9中已经移除。为了写出一个图片大中小切换效果，各种百度谷歌，最终没搞出来。开始怀疑，toggle过时了，经过查看官方文档，果然！我靠，各位大神，你们13、14年写的教程，居然使用过时的代码……还有你，w3school，该更新了大哥！ 结束语以上总结不可能面面俱到，差不多了，就写到这儿吧！ 参考文档李炎恢的jQuery视频教程《jQuery攻略（作者B.M.Harwani）》《jQuery实战（作者Bear Bibeault、Yehuda Katz）》《jQuery高级编程（作者 Cesar Otero、Rob Larsen）》《jQuery Javascript 与CSS开发入门经典（作者Richard York）》","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yutaiwei.github.io/tags/JavaScript/"},{"name":"jQuery","slug":"jQuery","permalink":"http://yutaiwei.github.io/tags/jQuery/"}]},{"title":"jQuery书签","date":"2016-10-15T07:54:38.000Z","path":"2016/10/15/jQuery书签/","text":".jpg) 从零开始学习jQuery (一) 开天辟地入门篇http://kb.cnblogs.com/page/46450/ jQuery APIhttp://jquery.cuishifeng.cn/ jQuery API资源专属下载页http://www.cuishifeng.cn/down.html jQuery基础课程http://www.imooc.com/learn/11 CodePlayerhttp://www.365mini.com/ html中offsetTop、clientTop、scrollTop、offsetTop各属性介绍http://blog.csdn.net/fswan/article/details/17238933 值得 Web 开发人员学习的20个 jQuery 实例教程http://www.cnblogs.com/lhb25/p/20-must-have-jquery-tutorials.html jQuery Mobilehttp://jquerymobile.com/ HTML5+JS手机web开发之jQuery Mobile初涉 10个优秀的jQuery Mobile主题http://caibaojian.com/10-best-free-jquery-mobile-theme.html","tags":[{"name":"书签","slug":"书签","permalink":"http://yutaiwei.github.io/tags/书签/"},{"name":"jquery","slug":"jquery","permalink":"http://yutaiwei.github.io/tags/jquery/"}]},{"title":"jQuery学习笔记——选择器篇","date":"2016-10-15T07:05:25.000Z","path":"2016/10/15/jQuery学习笔记——选择器篇/","text":".jpg) 选择器语法jQuery选择元素的语法为：$(selector,[content]); 如果第一个参数是选择器，那么第二个参数就是指示该操作的上下文，默认为整个DOM文档。上下文参数可以是DOM元素的引用，也可以包含jQuery选择器的字符串，或者是DOM元素包装集。上文hello voidking中的html文件内容修改为：1234567891011121314151617181920&lt;html&gt;&lt;head&gt; &lt;script type=\"text/javascript\" src=\"jquery-1.10.2.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $(function()&#123; $(\"p\",\"div#voidking\").css(\"color\",\"red\"); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"voidking\"&gt; &lt;p&gt; welcome to jQuery world ! &lt;/p&gt; &lt;/div&gt; &lt;p&gt; welcome to jQuery world ! &lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 在浏览器中打开，我们发现，只有第一行是红色的。这是因为，$(“p”,”div#voidking”)指定的范围是：id值为voidking的元素内。 CSS基本选择器id选择器获取一个id为voidking的元素。 在CSS中：123#voidking&#123; color:red;&#125; 在jQuery中：1$(\"#voidking\").css(\"color\",\"red\"); class选择器获取所有class为voidking的元素。 在CSS中：123.voidking&#123; color:red;&#125; 在jQuery中：1$(\".voidking\").css(\"color\",\"red\"); 标签选择器获取所有标签名为div的元素。 在CSS中：123div&#123; color:red;&#125; 在jQuery中：1$(\"div\").css(\"color\",\"red\"); 群组选择器获取标签名为span、em和class为voidking的所有元素。 在CSS中：123span,em,.voidking&#123; color:red;&#125; 在jQuery中：1$(\"span,em,.voidking\").css(\"color\",\"red\"); 后代选择器获取标签名为ul下的标签名为li下的标签名为a的所有元素。 在CSS中：123ul li a&#123; color:red;&#125; 在jQuery中：1$(\"ul li a\").css(\"color\",\"red\"); 或者1$(\"ul\").find(\"li\").find(\"a\").css(\"color\", \"red\"); 通配选择器获取所有元素，一般不使用。 在CSS中：123*&#123; color:red;&#125; 在jQuery中：1$(\"*\").css(\"color\",\"red\"); 组合上面的六种选择器，已经可以满足大部分的选择需要。而它们还可以结合起来使用。1$(\"div.voidking,ul li a\").css(\"color\",\"red\"); CSS高级选择器子选择器选择id为voidking的元素下，子标签为p的元素。 在CSS中：123#voidking &gt; p&#123; color:red;&#125; 在jQuery中：1$(\"#voidking &gt; p\").css(\"color\",\"red\"); 或者1$(\"#voidking\").children(\"p\").css(\"color\", \"red\"); 同级下一个选择器选择和id为voidking的元素同级的，下一个标签为p的元素。 在CSS中：123#voidking + p&#123; color:red;&#125; 在jQuery中：1$(\"#voidking + p\").css(\"color\",\"red\"); 或者1$(\"#voidking\").next(\"p\").css(\"color\", \"red\"); 同级所有下面选择器选择和id为voidking的元素同级的，下面所有标签为p的元素。 在CSS中：123#voidking ~ p&#123; color:red;&#125; 在jQuery中：1$(\"#voidking ~ p\").css(\"color\",\"red\"); 或者1$(\"#voidking\").nextAll(\"p\").css(\"color\", \"red\"); PS在find()、children()、next()、nextAll()四个函数中，如果不传入参数，默认为”*”。 建议使用方法而不是符号，理论上讲，使用方法的效率高于使用符号，而且，使用方法更加易读易懂。 接下来的选择器就没有类似于” “、”&gt;”、”+”、”~”这样的符号了，全部由函数来完成。 同级上一个选择器选择和id为voidking的元素同级的，上一个标签为p的元素。 1$(\"#voidking\").prev(\"p\").css(\"color\", \"red\"); 同级所有上面选择器选择和id为voidking的元素同级的，上面所有标签为p的元素。1$(\"#voidking\").prevAll(\"p\").css(\"color\", \"red\"); 同级上下所有选择器1$(\"#voidking\").siblings(\"p\").css(\"color\", \"red\"); 等价于12$(\"#voidking\").prevAll(\"p\").css(\"color\", \"red\");$(\"#voidking\").nextAll(\"p\").css(\"color\", \"red\"); 非指定选择器同级上、下非指定元素选定，遇到则停止。12$(\"#voidking\").prevUntil(\"p\").css(\"color\", \"red\");$(\"#voidking\").nextUntil(\"p\").css(\"color\", \"red\"); 属性选择器精确匹配1$('[id='voidking']').css(\"color\",'red'); 1$('div[id='voidking']').css(\"color\",'red'); 精确不匹配1$(\"p[class != 'voidking']\").css(\"color\",'red'); 匹配开头1$(\"[id ^= 'void']\").css(\"color\",\"red\"); 匹配结尾1$(\"[id $= 'king']\").css(\"color\",\"red\"); 其他 CSS选择器 jQuery选择器 描述 elem[id] $(“elem[id]”) 选择具有id属性的元素 elem[id \\ = ‘void’] $(“elem[id\\ = ‘void’]”) 选择具有id属性，且属性值以viod开头或者属性值等于void的元素 elem[class ~= ‘voidking’] $(“elem[id ~= ‘voidking’]”) 选择具有class属性，且属性值是一个以空格分格的列表，其中包含voidking的元素 elem[id *= ‘oidki’] $(“elem[id *= ‘oidki’]”) 选择具有id属性,且属性值中包含”oidki”字串的元素 过滤选择器位置选择器 jQuery选择器 描述 $(“li:first”) 返回匹配集合的第一个元素 $(“li:last”) 返回匹配集合的最后一个元素 $(“li:odd”) 返回匹配集合的奇数成员 $(“li:even”) 返回匹配集合的偶数成员 $(“li:eq(3)”) 返回匹配集合的索引值等于3的元素（第4个元素） $(“li:not(3)”) 返回匹配集合的索引值不等于3的所有元素 $(“li:gt(2)”) 返回匹配集合的索引值大于2的所有元素 $(“li:lt(3)”) 返回匹配集合的索引值小于3的所有元素 基本过滤选择器基本过滤选择器包括位置选择器，比位置选择器多了一些东东：| 过滤器 | 描述 || ——- | ——- || :animated | 选择当前正在执行动画的所有元素 || :header | 选择所有的标题元素，比如h1、h2、h3等 | 过滤表单元素 过滤器 描述 :text 选择所有类型为text的元素 :password 选择所有类型为password的元素 :radio 选择所有类型为radio的元素 :checkbox 选择所有类型为checkbox的元素 :checked 匹配所有已被选中的元素 :image 选择所有类型为image的元素 :file 选择所有类型为file的元素 :submit 选择所有类型为submit的元素 :reset 选择所有类型为reset的元素 :button 选择所有button元素和类型为botton的元素 :input 选择所有input、textarea、select和button元素 :selected 选择所有类型已选中的元素 :enabled 选择所有可用元素 :disabled 选择所有不可用元素 可见性过滤器 过滤器 描述 :visible 选择所有可见元素 :hidden 选择所有隐藏元素 内容过滤器 过滤器 描述 :contains() 选择所有包含特定文本内容的元素 :has() 选择至少含有一个元素与制定选择器匹配的元素 :empty 选择所有不包含子元素或文本的空元素 :parent 选择所有含有子元素或文本节点的元素 关系过滤器 过滤器 描述 :first-child 选择每个父元素的第一个子元素 :last-child 选择每个父元素的最后一个子元素 :nth-child 选择每个父元素的第nth-child()个子元素 :only-child 选择具有唯一一个子元素的元素 自定义选择器有些时候，jQuery提供的选择器不够用，我们就需要自己创建选择器。比如，我们需要选择具有绿色背景的元素： 1234567891011121314151617181920&lt;html&gt;&lt;head&gt; &lt;script type=\"text/javascript\" src=\"jquery-1.10.2.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $(function()&#123; //通过扩展$.expr[\":\"]实现自定义选择器 $.expr[\":\"].greenbg = function(element)&#123; return $(element).css(\"background-color\") === \"green\"; &#125;; //此处兼容性问题。输出在Firefox和IE中有所不同，Firefox值为0，IE值为1。 alert($(\":greenbg\").length); $(\":greenbg\").text(\"hello voidking\"); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div style=\"width:200 ; height:200 ; background-color:green;\" &gt;&lt;/div&gt; &lt;div style=\"width:200 ; height:200 ; background-color:red;\" &gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 结束语我靠，选择器这块实在是太难搞了！一天一夜才完成这份总结。内容纯手打，代码测试通过！ 参考文档李炎恢的jQuery视频教程《jQuery攻略（作者B.M.Harwani）》《jQuery实战（作者Bear Bibeault、Yehuda Katz）》《jQuery高级编程（作者 Cesar Otero、Rob Larsen）》《jQuery Javascript 与CSS开发入门经典（作者Richard York）》","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yutaiwei.github.io/tags/JavaScript/"},{"name":"jQuery","slug":"jQuery","permalink":"http://yutaiwei.github.io/tags/jQuery/"}]},{"title":"jQuery学习笔记——概述篇","date":"2016-10-15T00:04:52.000Z","path":"2016/10/15/jQuery学习笔记——概述篇/","text":".jpg) jQuery是什么jQuery是一个兼容多浏览器的Javascript库，类似于C语言中的”.h”文件和Java中的”.jar” 文件。 核心理念是write less,do more(写得更少,做得更多)。jQuery是免费、开源的，使用MIT许可协议。jQuery的语法设计可以使开发者更加便捷，例如操作文档对象、选择DOM元素、制作动画效果、事件处理、使用Ajax以及其他功能。除此以外，jQuery提供API让开发者编写插件。其模块化的使用方式使开发者可以很轻松的开发出功能强大的静态或动态网页。 jQuery能够做什么1、简化编程。jQuery最大的优点，是简化了Javascript编程。本来需要很多行代码才能完成的功能，使用jQuery，时常一两行就够了。 2、跨平台。使用Javascript开发，是一件痛苦的事情，因为你不得不考虑到各种浏览器的兼容问题。而使用jQuery，你编写的程序可以很容易地实现跨浏览器平台。 jQuery简史jQuery在2006年1月由美国人John Resig在纽约的barcamp发布，吸引了来自世界各地的众多JavaScript高手加入，由Dave Methvin率领团队进行开发。 如今，jQuery已经成为最流行的javascript库，在世界前10000个访问最多的网站中，有超过55%在使用jQuery。 在写这篇文章的时候，在谷歌搜索jQuery，返回大约 85,900,000条结果。jQuery每天都有新的官方插件和第三方插件产生，它们不断扩展jQuery的核心功能。 hello voidkingC语言写的第一个程序是helloworld，今天，void自恋一把，第一个程序就和自己打招呼了！ 1、官网下载jQuery文件（这里我使用的是jquery-1.10.2.js）。 2、新建index.html文件，内容如下：12345678910111213141516&lt;html&gt;&lt;head&gt; &lt;script type=\"text/javascript\" src=\"jquery-1.10.2.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $(function()&#123; alert(\"hello voidking\"); $(\"p\").css(\"color\",\"red\"); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt; welcome to jQuery world ! &lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 3、打开浏览器，看到弹出的对话框了吧？大功告成！下面的内容，会对此程序作出解释。 $jQuery的一切功能都源自”$”对象，即一个美元符号对象（或美元符号方法），它可以用”jQuery”来代替。 美元符号既是一个对象，也是一个方法。这是因为它具有很多成员属性和方法可以调用，同时可以把它当成一个函数来调用。 延迟加载我们在hellovoidking的代码中，使用$(function(){});进行首尾包裹，那么为什么要包裹这段代码呢？原因是，jQuery库文件是在body元素之前加载的，我们必须等待所有的DOM元素加载后，延迟支持DOM操作，否则就无法获取到。 为了延迟等待加载，JavaScript提供了一个事件为load，方法如下：1window.onload = function()&#123;&#125;; 而jQuery提供的方法如下：1$(document).ready(function()&#123;&#125;); 什么东东？和hello voidking中的代码不一样啊？原来，jQuery的延迟加载方法可以简写为：1$(function()&#123;&#125;); jQuery选择器jQuery最核心的组成部分就是：选择器引擎。用iPhone式的格言来说，“让选择器完成一切”就是jQuery的座右铭。 在使用jQuery的任何方法时，首先要做的就是选择页面中要操作的那些元素。 jQuery选择器继承了CSS的语法，可以对DOM元素的标签名、属性名、状态等进行快速准确的选择，并且不必担心浏览器的兼容性。jQuery选择器实现了CSS1~CSS3的大部分规则之外，还实现了一些自定义的选择器，用于各种特殊状态的选择。 选择器部分内容很多，我会在下一篇文章中详细研究探讨。 事件处理对于事件的概念，我在《Javascript学习笔记——基础篇》中已经解释过，这里不再赘述。jQuery的事件处理，内容也很多，我会在接下来的文章中探究。 AjaxjQuery的Ajax也是重点，必须的展开。我靠，肿么这么多！别吐槽了帅哥，写教程的void都快哭了，赶着去搞XMPP呢！ 调试个人喜欢的工具是：火狐浏览器 + firebug。 结束语jQuery博大精深，还有什么单元测试、插件、特效制作啥的，void就不多说了，感兴趣的小伙伴自己查找资料吧！ 参考文档李炎恢的jQuery视频教程《jQuery攻略（作者B.M.Harwani）》《jQuery实战（作者Bear Bibeault、Yehuda Katz）》《jQuery高级编程（作者 Cesar Otero、Rob Larsen）》《jQuery Javascript 与CSS开发入门经典（作者Richard York）》","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yutaiwei.github.io/tags/JavaScript/"},{"name":"jQuery","slug":"jQuery","permalink":"http://yutaiwei.github.io/tags/jQuery/"}]},{"title":"Javascript学习笔记——实践篇","date":"2016-09-20T11:27:20.000Z","path":"2016/09/20/Javascript学习笔记——实践篇/","text":".jpg) 注释本文中的文件名，写在了代码注释中。既然用到了三种文件，就把这三种文件的注释方法先说明一下。 HTML注释语法&lt;!--注释的内容--&gt;,示例如下：1&lt;!--欢迎来到VoidKing的主页--&gt; CSS注释语法/*注释的内容*/，示例如下：12345/*这是注释*//*这也是注释可以分段*/ Javascript注释和C语言相同，语法//注释的内容或者/*注释的内容*/，示例如下：1234//这是注释/*这也是注释*/ 使用Javascript在html页面中使用Javascript，有三种方法： body中body中的Javascript代码，相当于C语言中位于main函数内代码，格式如下：1234567891011&lt;!--index.html--&gt;&lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;script type=\"text/javascript\"&gt; document.write(\"voidking.com\"); alert(\"voidking.com\"); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; head中head中的Javascript代码，相当于C语言中位于main函数外的代码，一般是封装好的函数。格式如下：123456789101112131415161718192021222324&lt;!--index.html--&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"charset=utf-8\" /&gt; &lt;script type=\"text/javascript\"&gt; function hello()&#123; var str=prompt(\"VoidKing的网址是什么？\",\"请在这里输入\"); if(str!=null &amp;&amp; str!=\"\") &#123; alert(\"你输入的是：\"+str); &#125; else &#123; alert(\"你什么也没有输入！\"); &#125; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;script type=\"text/javascript\"&gt; hello(); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 外部head中的Javascript代码不易维护，所以多数情况下我们会使用外部引用来代替。格式如下：123456789101112&lt;!--index.html--&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"charset=utf-8\" /&gt; &lt;script type=\"text/javascript\" src=\"javascript.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;script type=\"text/javascript\"&gt; hello(); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 123456789101112//javascript.jsfunction hello()&#123; var str=prompt(\"VoidKing的网址是什么？\",\"请在这里输入\"); if(str!=null &amp;&amp; str!=\"\") &#123; alert(\"你输入的是：\"+str); &#125; else &#123; alert(\"你什么也没有输入！\"); &#125; &#125; 使用CSS上面我们已经说完了使用Javascript的三种方式，爱思考的小伙伴肯定想到了CSS的使用方法，在这里，我也总结一下。 内联样式当特殊的样式需要应用到个别元素时，就可以使用内联样式。格式如下：12345678910&lt;!--index.html--&gt;&lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;p style=\"color:red;margin-left:20px\"&gt; This is a paragraph. &lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 内部样式当单个文件需要特别样式的时候，就可以使用内部样式表。格式如下:1234567891011121314&lt;!--index.html--&gt;&lt;html&gt; &lt;head&gt; &lt;style type=\"text/css\"&gt; body&#123;background-color:red&#125; p&#123;margin-left:20px&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt; This is a paragraph. &lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 外部样式当样式需要被应用到很多页面的时候，外部样式表最适合。格式如下：1234567891011&lt;!--index.html--&gt;&lt;html&gt; &lt;head&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\"/&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt; This is a paragraph. &lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 123/*style.css*/body&#123;background-color:red&#125;p&#123;margin-left:20px&#125; 借花献佛本来想自己整理出一批好的例子，但是，无意中发现了一个网站，已经做得非常好了。所以，void在这里就偷懒一下。例子精品，还附有教程讲解，分享给大家——梦之都！ 结束语这篇文章比预期的用时要短上很多，主要因为，我把痛苦的工作全部交给梦之都了，好机智地说！还想写个提高篇来着，但是能力有限，不能误人子弟啊！所以，Javascript笔记至此结束，接下来，该是jQuery了！","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yutaiwei.github.io/tags/JavaScript/"}]},{"title":"js中call、apply、bind的用法","date":"2016-09-20T10:45:27.000Z","path":"2016/09/20/js中call、apply、bind的用法/","text":".jpg) 今天看博客时，看到了这样的一段js代码： 1var bind = Function.prototype.call.bind(Function.prototype.bind); 我想突然看到这样的一段代码，即使js能力再强的人，可能也需要花点时间去理解。像我这样的菜鸟就更不用说了。其实，原文已经对这端代码做出了解释，但我还是想用我的想法去解释这段代码。 上面那段代码涉及到了call、bind，所以我想先区别一下call、apply、bind的用法。这三个方法的用法非常相似，将函数绑定到上下文中，即用来改变函数中this的指向。举个例子： 123456789101112var zlw = &#123; name: \"zlw\", sayHello: function (age) &#123; console.log(\"hello, i am \", this.name + \" \" + age \" years old\"); &#125;&#125;;var xlj = &#123; name: \"xlj\",&#125;;zlw.sayHello(24);// hello, i am zlw 24 years old 下面看看call、apply方法的用法： 12zlw.sayHello.call(xlj, 24);// hello, i am xlj 24 years oldzlw.sayHello.apply(xlj, [24]);// hello, i am xlj 24 years old 结果都相同。从写法上我们就能看出二者之间的异同。相同之处在于，第一个参数都是要绑定的上下文，后面的参数是要传递给调用该方法的函数的。不同之处在于，call方法传递给调用函数的参数是逐个列出的，而apply则是要写在数组中。 我们再来看看bind方法的用法： 12zlw.sayHello.bind(xlj, 24)(); //hello, i am xlj 24 years oldzlw.sayHello.bind(xlj, [24])(); //hello, i am xlj 24 years old bind方法传递给调用函数的参数可以逐个列出，也可以写在数组中。bind方法与call、apply最大的不同就是前者返回一个绑定上下文的函数，而后两者是直接执行了函数。由于这个原因，上面的代码也可以这样写: 12zlw.sayHello.bind(xlj)(24); //hello, i am xlj 24 years oldzlw.sayHello.bind(xlj)([24]); //hello, i am xlj 24 years old bind方法还可以这样写fn.bind(obj, arg1)(arg2)。 用一句话总结bind的用法：该方法创建一个新函数，称为绑定函数，绑定函数会以创建它时传入bind方法的第一个参数作为this，传入bind方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。 现在回到开始的那段代码： 1var bind = Function.prototype.call.bind(Function.prototype.bind); 我们可以这样理解这段代码： 1var bind = fn.bind(obj) fn相当于Function.prototype.call，obj相当于Function.prototype.bind。而fn.bind(obj)一般可以写成这样obj.fn，为什么呢？因为fn绑定了obj，fn中的this就指向了obj。我们知道，函数中this的指向一般是指向调用该函数的对象。所以那段代码可以写成这样: 1var bind = Function.prototype.bind.call; 大家想一想Function.prototype.call.bind(Function.prototype.bind)返回的是什么？ 1console.log(Function.prototype.call.bind(Function.prototype.bind)) // call() 返回的是call函数，但这个call函数中的上下文的指向是Function.prototype.bind。这个call函数可以这样用 1234567891011var bind = Function.prototype.call.bind(Function.prototype.bind);var zlw = &#123; name: \"zlw\"&#125;;function hello () &#123; console.log(\"hello, I am \", this.name);&#125;bind(hello, zlw)() // hello, I am zlw 大家可能会感到疑惑，为什么是这样写bind(hello, zlw)而不是这样写bind(zlw, hello)？既然Function.prototype.call.bind(Function.prototype.bind)相当于Function.prototype.bind.call，那么先来看下Function.prototype.bind.call怎么用。call的用法大家都知道： 1Function.prototype.bind.call(obj, arg) 其实就相当于obj.bind(arg)。我们需要的是hello函数绑定对象zlw，即hello.bind(zlw)也就是Function.prototype.bind.call(hello, zlw)，所以应该这样写bind(hello, zlw)。 现在又有一个疑问，既然Function.prototype.call.bind(Function.prototype.bind)相当于Function.prototype.bind.call，我们为什么要这么写： 1var bind = Function.prototype.call.bind(Function.prototype.bind); 而不直接这样写呢： 1var bind = Function.prototype.bind.call; 先来看一个例子： 1234567891011var name = \"xlj\";var zlw = &#123; name: \"zlw\" hello: function () &#123; console.log(this.name); &#125;&#125;;zlw.hello(); // zlwvar hello = zlw.hello;hello(); // xlj 有些人可能会意外，hello()的结果应该是zlw才对啊。其实，将zlw.hello赋值给变量hello，再调用hello()，hello函数中的this已经指向了window，与zlw.hello不再是同一个上下文，而全局变量name是window的一个属性，所以结果就是xlj。再看下面的代码： 12var hello = zlw.hello.bind(zlw);hello(); // zlw 结果是zlw，这时hello函数与zlw.hello是同一个上下文。其实上面的疑惑已经解开了，直接这样写： 1var bind = Function.prototype.bind.call; bind函数中的上下文已经与Function.prototype.bind.call中的不一样了，所以使用bind函数会出错。而这样写 1var bind = Function.prototype.call.bind(Function.prototype.bind); bind函数中的上下文与Function.prototype.call.bind(Function.prototype.bind)中是一样的。 关于这个这段代码的解释这到这边了，感觉语言组织能力不是很好，文章写得有些啰嗦了。文中可能会有错误，希望大家指正。","tags":[{"name":"call","slug":"call","permalink":"http://yutaiwei.github.io/tags/call/"},{"name":"apply","slug":"apply","permalink":"http://yutaiwei.github.io/tags/apply/"},{"name":"bind","slug":"bind","permalink":"http://yutaiwei.github.io/tags/bind/"}]},{"title":"Javascript学习笔记——基础篇","date":"2016-09-20T02:57:02.000Z","path":"2016/09/20/Javascript学习笔记——基础篇/","text":".jpg) 什么是JavascriptJavascript是一种基于对象的脚本语言。 基于对象（Object-Based）不提供抽象、继承、重载等有关面向对象语言的功能。而是把其他语言创建的对象统一起来，形成一个对象系统，以供使用。脚本语言最大的特点就是不需要编译和链接。传统编程语言有四个步骤“编写-&gt;编译-&gt;链接-&gt;运行”，而脚本语言只有两个步骤“编写 -&gt; 运行”。 脚本语言是解释执行而非编译执行。windows下，命令提示符界面，就是输入脚本语言的shell；经常见到的“*.bat”批处理文件，就是脚本文件。而在linux系统里面，脚本、脚本编程的概念更是常见。 shell，提供用户使用界面的软件。在windows中，win+R，输入cmd，出现的那个黑黝黝的窗口就是一个shell；打开任务管理器，看到的那个explorer.exe程序，也是一个shell，它叫做GUI shell。在linux中，如果不使用图形用户界面，那么，你所看到的，就是一个shell，一般的linux系统都会提供几种shell供你选择；而如果使用图形用户界面，你看到的界面，就是一个GUI shell。 什么是对象一切都是对象。比如“你”就是一个对象，你拥有姓名、性别、身高、体重等等属性信息，也有跳跃、奔跑、吃饭、睡觉等等方法。 Javascript中使用的对象，分为内置对象和自定义对象。 常见的内置对象有Array、String、Math、Date、Document、Form、Anchor、Link、Image、Windows、Screen、Navigator、Location、History、Frame、DOM、RegExp、StyleSheet、Event、FileSystemObject、Drive、Folder、File、XMLHttpRequest、Error…… Javascript出现的原因1、表单验证。早期的验证全部在服务端，比如注册时需要输入邮箱，而邮箱有固定格式，中间有一个“@”。为了验证一个邮箱格式，就需要发送请求给服务端，服务端的压力很大，多么令人蛋疼。为了减轻服务器的压力，需要一种可以运行在客户端的精小高效的语言。 2、网页交互性。随着互联网的发展，单纯的网页浏览已经无法满足用户的需求，越来越多的用户渴望与网页进行交互。为了改善用户的交互体验，需要开发一种语言，而这种语言运行在服务端是不合适的。 火药的发明，最初并没有想到可以用来打仗。Javascript的作者也没想到，Javascript能够发展到现在这么强大：（1）在浏览器的状态栏或者警告框里，向访问者显示信息。（2）验证表单内容。（3）当访问者将鼠标指针移动到图像上面时，自动替换图像。（4）创建与访问者交互的广告栏，而不仅仅是显示一幅图像。（5）检测可用浏览器或其属性，并且只在支持它们的浏览器上运行高级功能。（6）检测已安装的插件，并在需要某一插件时通知访问者。（7）在不需要访问者重新加载网页的情况下，修改整个或部分网页。（8）显示从远程服务器检索到的数据，或者与远程服务器交互数据。……总结一下，大致分为表单验证、网页特效、浏览器检测。 语法汉语有语法，英语有语法，编程语言也有语法，Javascript也不例外。 语法，简而言之，就是语言表达的规则。你说“我真帅！”，大家理解你的意思，但是你说“帅真我！”，就没有人明白了！同样的，只有遵循一定的规则，浏览器才能明白你写的某句代码的意思。 数据类型数值型、字符串、布尔型、null、undefined、对象、数组 变量和常量和C、Java基本相同，不多解释，如果你没有学过编程，就按照数学中的理解就好了。 运算符和表达式和C、Java基本相同，不懂的同学请自行百度、读书，此处不展开了。 流程和C、Java基本相同，学过C、Java的同学请自行跳过本节。 其实所有的编程语言的执行流程都可以分为四种：（1）顺序。排队买饭，就是一个顺序流程。 （2）条件。假设有两个窗口，窗口一卖饭，窗口二卖汤。如果你想打饭，就去窗口一；如果你想打汤，就去窗口二。这里的“想打饭”和“想打汤”就是条件。 （3）循环。排队买饭，终于排到我了，这时我发现钱不够，于是我回宿舍拿钱；之后回来排队，终于又排到我了，钱还是不够，于是我又回宿舍拿钱……这个过程，就是循环。终于有一次，我的钱拿够了，买到了饭，这个循环就结束了。 （4）其他。比如continue、break、异常处理等。continue，排队买饭，还没有排到我，我发现钱没带，于是提前结束本次排队，回宿舍拿钱，回来后重新排队。break，排队买饭，还没有排到我，突然不想买了，于是结束排队。异常处理，排队买饭，突然收到一个紧急电话，必须去跑1000米。这个紧急电话，就是一个异常，跑1000米，就是处理。 函数和程序函数是用来实现一个功能的程序块。 举个例子，打电话告诉老爸缺钱了。这个过程，有两个动作，“打电话”和“告诉”。这里的“打电话”和“告诉”就是两个函数，也就是两个程序块。 程序块是什么？那些用大括号括起来的代码就是程序块。 程序呢？程序就是命令序列的集合。通俗一点说，程序就是做一件事情的步骤的集合。 “打电话”是一个程序，可以分为这样几个步骤：掏出手机，找到号码，拨号，等待接通。 当然你可以分的更细，比如“掏出手机”也可以看成一个程序，分为这样几个步骤：伸手拿到手机，提高一厘米，提高一厘米，提高一厘米…… 闭包闭包是啥玩意？各种专业文档中给出了void根本看不懂的定义。这里借用阮一峰的理解：闭包就是能够读取和保持其他函数内部变量的函数。 1、作用域要理解闭包，首先必须理解Javascript的变量作用域。变量作用域无非两种：全局变量和局部变量。 Javascript特有“链式作用域”结构。js寻找变量的定义会从最近的区域开始，本地找不到就往上一层区域，直到找到命名空间的顶端，在浏览器的世界里顶端就是window对象了。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。 2、一个例子1234567891011121314151617&lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;script &gt; function f1()&#123; var n = \"hello voidking\"; function f2()&#123; alert(n); &#125; return f2; &#125; var result = f1(); result(); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 运行这段代码，浏览器弹出了“hello voidking”对话框。 这段代码中的f2，就是一个闭包。 虽然外部函数已经返回，但是内部函数仍然记得外部函数定义的变量。 由于在Javascript中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。 在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。功能类似于Java对象中的set和get函数。 3、传引用闭包可以更新外部变量的值。 Javascript中函数的传参是传值，而不是传引用。而在闭包中，其存储的是一个对外部变量的引用。 正则表达式说到正则表达式，很多人会想到通配符。正则表达式和通配符的不同在哪里呢？ 1、通配符是系统级的，在bash shell界面下可以直接使用；正则表达式是需要工具支持的，比如grep、sed、awk等工具。2、通配符一般用来查找文件、文件夹；正则表达式的匹配更加精确，主要用来文本过滤和字符串的操作。 Javascript对于正则表达式有很好的支持，也就是说，我们可以很方便的进行文本过滤和字符串操作。比如开篇提到的邮箱格式验证，我们就可以用正则表达式来实现。 DOMDOM，文档对象模型（Document Object Model）。 DOM独立于语言和平台，是一套标准接口，用来对XML和HTML文档进行增删查改。 DOM规范的核心就是树模型，对于要解析的HTML文档，解析器会把HTML文档加载到内存中，在内存中为HTML文件建立逻辑形式的节点树。而每一个节点，代表一个可以进行交互的对象。 XMLXML，可扩展标记语言（eXtensible Markup Language）。 它的格式很HTML很像，但是，HTML的标记是固定的，不区分大小写；而XML的标记是自定义的，区分大小写的。 XML文档结构分为3个部分：序言、主体和尾声。其中尾声可有可无。如果把一个HTML文档看做是一个主体（一棵树），那么，XML和HTML文档结构的不同，就在于XML多了一个序言，而且，主体可能不止一棵树。 事件编程语言中的事件，我们可以简单理解为事情。 当一件事情发生，我们可能会产生反应，也许不会。 比如，你们的老师让你们写一篇实验报告，这就是一个事件。这个事件发生后，你就会去写实验报告，这就是反应。也许你会吐槽，告诉远方的某位姑娘，老师多么无聊，让你们写实验报告。这时，虽然姑娘也知道了这件事，但是微微一笑（没有去写报告吧），或者连反应都没有。而更多的不知道这个事件的人，当然就当做没发生。 Javascript中的事件，提供了与窗口以及当前加载文档交互的基础。而Javascript对事件的处理，也就是通常所说的反应。 CookieCookie（小甜饼）是由浏览器存储在客户端系统的文本，而且与浏览器的每次请求一同发送到服务器。使用Cookie可以方便地帮助Web服务器保存有关访客的信息。 Cookie常用于以下场合：（1）保存用户登录状态（2）跟踪用户行为（3）定制界面（4）创建购物车 AjaxAjax，异步Javascript和XML（Asynchronous Javascript and XML），被称为远程脚本技术。 Javascript在早期，和服务器通信的方法只有一个——提交表单，远程脚本技术使两者之间的通信变得更加丰富。它可以使Javascript超越客户端的界限，使其能够处理Web服务器上的文件。 特点：局部更新，节省带宽，提高加载速度。 结束语看完上面的概念，是不是在想：什么玩意儿？看不懂没关系，知道有那么一回事就行，下一篇实践篇将会告诉你Javascript到底怎么玩。以上内容也许理解失误的地方，感谢大家留言指正。 参考文档李炎恢的Javascript视频教程《Javascript完全学习手册（作者张银鹤等）》《Javascript基础教程（第七版，作者Tom Negrino、Dori Smith）》《Javascript开发技术详解（作者李峰、晁阳）》一些技术大牛的博客……","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yutaiwei.github.io/tags/JavaScript/"}]},{"title":"瀑布流特效","date":"2016-09-10T12:55:17.000Z","path":"2016/09/10/瀑布流特效/","text":".jpg) 原理假设页面上有三列图片，当我们下拉时，最短（或最长）的一列图片展示完的时候，就要请求加载新的图片，获取到的新的图片放到最短一列图片的下面。尝试过用原生js或jquery实现瀑布流，源码放在本文最后。下面记录一种使用imageloaded和masonry插件实现的瀑布流，更简便。 imageloaded和masonryejs代码：1234567&lt;div id=\"meitulist\" class=\"meitulist\"&gt; &lt;% data.obj.pictureList.forEach(function(picture)&#123; %&gt; &lt;a href=\"/inspiration/imagedetail/&lt;%= picture.albumId%&gt;\" class=\"item\"&gt; &lt;img src=\"&lt;%= picture.url%&gt;\" /&gt; &lt;/a&gt; &lt;% &#125;)%&gt;&lt;/div&gt; 每次加载图片并插入后，执行resetImage()函数。 1234567891011121314151617181920function resetImage()&#123; var width = document.documentElement.clientWidth; var column = width&gt;320? 3 : 2; var itemWidth = Math.ceil((width-(column+1)*10)/column); $('.meitulist .item').css('width',itemWidth); $('.meitulist .item img').css(&#123; 'width':itemWidth // 'height': itemWidth &#125;) window.imagesLoaded('#meitulist', function() &#123; var msnry = new Masonry('#meitulist',&#123; 'columnWidth': itemWidth, 'itemSelector': '.item', 'isAnimated':true, // 'percentPosition':true, 'gutter': 10 &#125;); &#125;);&#125; js和jquery源码https://github.com/voidking/front-end-demo/tree/master/%E7%80%91%E5%B8%83%E6%B5%81 参考文档瀑布流特效http://www.cnblogs.com/Leo_wl/p/4306295.html Masonry官网http://masonry.desandro.com/ mosonry项目地址：https://github.com/desandro/masonry imagesLoaded官网http://imagesloaded.desandro.com/ imagesloaded项目地址：https://github.com/desandro/imagesloaded","tags":[{"name":"前端","slug":"前端","permalink":"http://yutaiwei.github.io/tags/前端/"},{"name":"jQuery","slug":"jQuery","permalink":"http://yutaiwei.github.io/tags/jQuery/"},{"name":"插件","slug":"插件","permalink":"http://yutaiwei.github.io/tags/插件/"}]},{"title":"让伤疤微疼","date":"2016-09-05T13:24:56.000Z","path":"2016/09/05/让伤疤微疼/","text":".jpg) 作者：王纯 去朋友家做客，发现他的书桌上有一个小记事本，封面上写着“让伤疤微疼”。不觉好奇，朋友让我打开看。只见他的本子上写着：某年某月某天，做了个小手术，虽然不是大毛病，但要记得，是该储蓄健康了，伤疤好了，别忘了疼。还有，某年某月某天，工作失误，第一次犯这样的低级错误，主要原因是马虎，同样的错误不能犯第二次。某年某月某天，母亲突然晕倒，到医院检查是血压高，多关注老人的身体，千万不能忽略了，爱可能会来不及。诸如此类，都是生活中遇到的一些问题，提醒自己一定要警醒，所以他说“让伤疤微疼”。 我不由被朋友的良苦用心打动了。生活中，我们很多人都太容易“好了伤疤忘了疼”。 我一个远方的表舅，事业蒸蒸日上，他也是全身心投入到事业中，加班加点是常有的事。没想到他突然间脑出血，在医院接受治疗时，他叹着气说：“人呐，真没必要拼死拼活地干。身外之物，生不带来，死不带去，只有身体和健康是自己的。”大家也都劝他，把工作放放，少挣点没关系。他点头答应。 刚出院的时候，表舅的手脚还不利落，在家休养。他养花种菜，过得也很开心，大家都以为他想开了。没过多久，他的手脚完全恢复了，虽然每天都吃药，但他感觉没事了。正好有一笔大生意来了，他不顾家人劝阻，接了下来。他以为身体没事，可工作起来费心劳神，他很快就挺不住了。突然有一天，一头栽倒，再也没有起来。 大家都说，表舅吃了“好了伤疤忘了疼”的亏。 其实，复杂多变的生活和工作中，总会出现这样那样的问题。问题的出现，对我们来说是个很好的提醒。有时还有一些让你很受伤的事，刺痛你，但我们习惯了时过境迁，把伤痛忘得一干二净。 让伤疤微疼，是一种智慧。把经历的伤痛默默记在心上，时时提醒自己，伤疤虽然结痂，但要让自己微疼。过去的一切，都是宝贵的经验，失败和伤痛更是一种难得的财富，要懂得利用。 让伤疤微疼，也需要勇气。有了伤疤，有些人千方百计选择各种“疤痕灵”消除伤疤，说是忘记伤痛，重新开始。其实最明智的做法是，在伤疤上纹上一朵淡淡的花，提醒自己，曾经伤过。人要有直面伤疤的勇气，要留有疼痛的记忆。只有这样，才能让自己少受伤害。 每个人都有大大小小的伤疤，身体、工作、情感、生活等等。有让伤疤微疼的能力，就有了获得智慧人生和幸福人生的能力。","tags":[{"name":"读者","slug":"读者","permalink":"http://yutaiwei.github.io/tags/读者/"},{"name":"王纯","slug":"王纯","permalink":"http://yutaiwei.github.io/tags/王纯/"}]},{"title":"赚钱以外的功夫","date":"2016-09-05T12:56:11.000Z","path":"2016/09/05/赚钱以外的功夫/","text":".jpg) 作者：冯仑 我发现一个非常有趣的现象，李嘉诚在创业的时候，许多人都比他有钱，但后来那些人不见了，或者财富排在他后面。比尔?盖茨创业的时候，比他钱多的人也很多，但盖茨今天成了首富。中国许多企业家也是如此。为什么？ 因为，在中国由计划经济向市场经济，由封闭向开放，由野蛮的市场经济向文明法制的市场经济转型过程中，最重要的恰好是钱以外的因素。 就像你驾驶一辆汽车在高速公路上要并线转弯，既要车不能翻，还要保持速度，这非常难。这时候的问题不在于汽油，而在于司机的技巧，这个技巧就是钱以外的东西。钱以外的能力究竟是什么能力？我讲四种。 一、将自己的姿态放低 钱以外的能力之一是做人的能力，特别是做人的姿态。我发现凡是生意做得不错的人，都善于把自己的姿态放得很低，在中国文化里这叫给别人面子，就是你得把人尊敬一下。凡是刚开始做生意的时候，他们的姿态都很重要，就是很谦恭、谦虚、谦卑。按北京话来说，挣钱要像孙子，花钱要像大爷。 二、价值观 钱以外的第二个能力是价值观。价值观是我们判断是非善恶的简单标准。你之所以做这件事而不做那件事，之所以这么做而不是那么做，就是价值观。MBA经常讲差异化竞争，差异化的战略在产品、在营销方法这些方面，几乎都可以模仿。真正不能模仿的是价值观，这就是为什么有些人能够成功，有些人不能够成功。 所谓价值观，就是在你心里跟你的合作伙伴、同事、朋友建立金钱关系的时候，你需要拿一个尺度来衡量、来决策，而这个东西会引导你朝不同的方向去走。例如，我们看马云，不要看马云成功的故事，而应该看马云是怎样在微观决策的时候，判断细小的是非。比如马云在上市的时候，他只拿了5%的股份，这就是价值观。还有一些人，会把70%的股份变成自己的。而这个价值观会导致未来非常多的人生故事和结局。 三、毅力和耐心 钱以外的第三种能力就是毅力、时间。为什么坚持这件事很重要？因为如果你没有理想，就不可能有毅力。所有的人在做事情的时候，最后不是比一个结果，而是比一个过程。一件事情的性质由什么决定，我认为取决于两方面。第一，取决于时间，时间不同，对这件事的评价完全不一样。第二，取决于你跟谁做。 做企业也是这样。如果我们在做了三年的时候垮掉了，大家可能把我们随意看待。当我们30年还在这儿的时候，大家开始有一些敬意。当300年后这个公司还在的时候，大家开始顶礼膜拜。所以时间是一个很好的东西，它可以考验你的价值观和做人的姿态。中国历史传统中，没有把事往快里办的办法，大部分都教我们把事往慢里办。通过慢能够把事做好，所以叫事缓则圆，以缓找到方法，以圆作为皈依，这就是中国人的智慧。所以你要有毅力。 四、正确判断未来 上面讲的都是刚开始挣钱，怎样能挣到钱的故事。当一个企业已经发展得不错的时候，实际上也面临着更大的挑战，钱以外的能力，就是你对未来的看法，对社会的看法是不是准确。 我在公司已经做了17年董事长，没有做过一天经理。我发现我能干的工作并不多，但是很费神。因为我就干三件事情：第一，看别人看不见的地方；第二，算别人算不清的账；第三，做别人不做的事情。 这其实非常难。第一，你永远要看别人看不见的地方。当一个企业正常发展时，要看那些看不见的东西，包括风险、机会，很多我们还不知道的未来变化的趋势。这些工作需要企业的领导花很多时间。所以我经常说，我要跟神、跟先知做邻居，这样才能看见别人看不见的地方，我们要有一个方法去看趋势、模式、危险、机会，这些很重要。这些东西属于钱以外的东西，并不是说花多少钱就有这个能力，而是要长期去积累和研究去学习。 第二，算那些算不清的账。眼前最简单也最现实的是我们捐献灾区多少钱合适，社会的情绪，公众的期待跟捐多少钱有很大的关系。更复杂的账还有，比如说我们要找一个合作伙伴，可能有五个人站在你门口都可以给你钱，有土钱、洋钱，有笨钱、聪明钱，你找谁？土钱的特点是决策快、变化大、干预多；洋钱决策慢、按规则来、干预不多，但是该管你的地方，又决不妥协。所以作为一个企业、一个领导人，这种能力就是你怎么在算不清的账里找到确定。 第三，做别人不做的事。例如履行企业公民的责任，去救灾、去环保，做各种各样的事情。这些事情是经理人不太愿意做的事情，因为又占精力又要出钱，董事长就要做他们不做的事情。","tags":[{"name":"读者","slug":"读者","permalink":"http://yutaiwei.github.io/tags/读者/"},{"name":"冯仑","slug":"冯仑","permalink":"http://yutaiwei.github.io/tags/冯仑/"}]},{"title":"总结js常用函数和常用技巧（持续更新）","date":"2016-08-26T15:16:27.000Z","path":"2016/08/26/总结js常用函数和常用技巧/","text":".jpg) 学习和工作的过程中总结的干货，包括常用函数、常用js技巧、常用正则表达式、git笔记等。为刚接触前端的童鞋们提供一个简单的查询的途径，也以此来缅怀我的前端学习之路。PS：此文档，我会持续更新。 Ajax请求jquery ajax函数我自己封装了一个ajax的函数，代码如下： 12345678910111213141516171819var Ajax = function(url, type success, error) &#123; $.ajax(&#123; url: url, type: type, dataType: 'json', timeout: 10000, success: function(d) &#123; var data = d.data; success &amp;&amp; success(data); &#125;, error: function(e) &#123; error &amp;&amp; error(e); &#125; &#125;);&#125;;// 使用方法：Ajax('/data.json', 'get', function(data) &#123; console.log(data);&#125;); jsonp方式有时候我们为了跨域，要使用jsonp的方法，我也封装了一个函数： 1234567891011121314151617181920212223242526272829303132function jsonp(config) &#123; var options = config || &#123;&#125;; // 需要配置url, success, time, fail四个属性 var callbackName = ('jsonp_' + Math.random()).replace(\".\", \"\"); var oHead = document.getElementsByTagName('head')[0]; var oScript = document.createElement('script'); oHead.appendChild(oScript); window[callbackName] = function(json) &#123; //创建jsonp回调函数 oHead.removeChild(oScript); clearTimeout(oScript.timer); window[callbackName] = null; options.success &amp;&amp; options.success(json); //先删除script标签，实际上执行的是success函数 &#125;; oScript.src = options.url + '?' + callbackName; //发送请求 if (options.time) &#123; //设置超时处理 oScript.timer = setTimeout(function () &#123; window[callbackName] = null; oHead.removeChild(oScript); options.fail &amp;&amp; options.fail(&#123; message: \"超时\" &#125;); &#125;, options.time); &#125;&#125;;// 使用方法：jsonp(&#123; url: '/b.com/b.json', success: function(d)&#123; //数据处理 &#125;, time: 5000, fail: function()&#123; //错误处理 &#125; &#125;); 常用正则验证表达式手机号验证1234var validate = function(num) &#123; var exp = /^1[3-9]\\d&#123;9&#125;$/; return exp.test(num);&#125;; 身份证号验证1var exp = /^[1-9]&#123;1&#125;[0-9]&#123;14&#125;$|^[1-9]&#123;1&#125;[0-9]&#123;16&#125;([0-9]|[xX])$/; ip验证1var exp = /^(\\d&#123;1,2&#125;|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d&#123;1,2&#125;|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d&#123;1,2&#125;|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d&#123;1,2&#125;|1\\d\\d|2[0-4]\\d|25[0-5])$/; 常用js函数返回顶部1234567891011$(window).scroll(function() &#123; var a = $(window).scrollTop(); if(a &gt; 100) &#123; $('.go-top').fadeIn(); &#125;else &#123; $('.go-top').fadeOut(); &#125;&#125;);$(\".go-top\").click(function()&#123; $(\"html,body\").animate(&#123;scrollTop:\"0px\"&#125;,'600');&#125;); 阻止冒泡12345678function stopBubble(e)&#123; e = e || window.event; if(e.stopPropagation)&#123; e.stopPropagation(); //W3C阻止冒泡方法 &#125;else &#123; e.cancelBubble = true; //IE阻止冒泡方法 &#125; &#125; 全部替换replaceAll1234var replaceAll = function(bigStr, str1, str2) &#123; //把bigStr中的所有str1替换为str2 var reg = new RegExp(str1, 'gm'); return bigStr.replace(reg, str2);&#125; 获取浏览器url中的参数值123var getURLParam = function(name) &#123; return decodeURIComponent((new RegExp('[?|&amp;]' + name + '=' + '([^&amp;;]+?)(&amp;|#|;|$)', \"ig\").exec(location.search) || [, \"\"])[1].replace(/\\+/g, '%20')) || null;&#125;; 深度拷贝对象12345678910111213function cloneObj(obj) &#123; var o = obj.constructor == Object ? new obj.constructor() : new obj.constructor(obj.valueOf()); for(var key in obj)&#123; if(o[key] != obj[key] )&#123; if(typeof(obj[key]) == 'object' )&#123; o[key] = mods.cloneObj(obj[key]); &#125;else&#123; o[key] = obj[key]; &#125; &#125; &#125; return o;&#125; 数组去重12345678910var unique = function(arr) &#123; var result = [], json = &#123;&#125;; for (var i = 0, len = arr.length; i &lt; len; i++)&#123; if (!json[arr[i]]) &#123; json[arr[i]] = 1; result.push(arr[i]); //返回没被删除的元素 &#125; &#125; return result;&#125;; 判断数组元素是否重复12345678var isRepeat = function(arr) &#123; //arr是否有重复元素 var hash = &#123;&#125;; for (var i in arr) &#123; if (hash[arr[i]]) return true; hash[arr[i]] = true; &#125; return false;&#125;; 生成随机数123function randombetween(min, max)&#123; return min + (Math.random() * (max-min +1));&#125; 操作cookie12345678910111213141516own.setCookie = function(cname, cvalue, exdays)&#123; var d = new Date(); d.setTime(d.getTime() + (exdays*24*60*60*1000)); var expires = 'expires='+d.toUTCString(); document.cookie = cname + '=' + cvalue + '; ' + expires;&#125;;own.getCookie = function(cname) &#123; var name = cname + '='; var ca = document.cookie.split(';'); for(var i=0; i&lt; ca.length; i++) &#123; var c = ca[i]; while (c.charAt(0) == ' ') c = c.substring(1); if (c.indexOf(name) != -1) return c.substring(name.length, c.length); &#125; return '';&#125;; 知识技巧总结数据类型underfined、null、0、false、NaN、空字符串。他们的逻辑非结果均为true。 闭包格式好处：避免命名冲突（全局变量污染）。 123(function(a, b) &#123; console.log(a+b); //30&#125;)(10, 20); 截取和清空数组123var arr = [12, 222, 44, 88];arr.length = 2; //截取，arr = [12, 222]; arr.length = 0; //清空，arr will be equal to []. 获取数组的最大最小值123var numbers = [5, 45822, 120, -215];var maxInNumbers = Math.max.apply(Math, numbers); //45822var minInNumbers = Math.min.apply(Math, numbers); //-215 浮点数计算问题10.1 + 0.2 == 0.3 //false 为什么呢？因为0.1+0.2等于0.30000000000000004。JavaScript的数字都遵循IEEE 754标准构建，在内部都是64位浮点小数表示。可以通过使用toFixed()来解决这个问题。 数组排序sort函数123456var arr = [1, 5, 6, 3]; //数字数组arr.sort(function(a, b) &#123; return a - b; //从小到大排 return b - a; //从大到小排 return Math.random() - 0.5; //数组洗牌&#125;); 1234567891011121314151617var arr = [&#123; //对象数组 num: 1, text: 'num1'&#125;, &#123; num: 5, text: 'num2'&#125;, &#123; num: 6, text: 'num3'&#125;, &#123; num: 3, text: 'num4'&#125;]; arr.sort(function(a, b) &#123; return a.num - b.num; //从小到大排 return b.num - a.num; //从大到小排&#125;); 对象和字符串的转换123var obj = &#123;a: 'aaa', b: 'bbb'&#125;;var objStr = JSON.stringify(obj); // \"&#123;\"a\":\"aaa\",\"b\":\"bbb\"&#125;\"var newObj = JSON.parse(objStr); // &#123;a: \"aaa\", b: \"bbb\"&#125; git笔记git使用之前的配置123451.git config --global user.email xxx@163.com2.git config --global user.name xxx3.ssh-keygen -t rsa -C xxx@163.com(邮箱地址) // 生成ssh4.找到.ssh文件夹打开，使用cat id_rsa.pub //打开公钥ssh串5.登陆github，settings － SSH keys － add ssh keys （把上面的内容全部添加进去即可） 说明：然后这个邮箱（xxxxx@gmail.com）对应的账号在github上就有权限对仓库进行操作了。可以尽情的进行下面的git命令了。 git常用命令1234567891011121314151617181、git config user.name / user.email //查看当前git的用户名称、邮箱2、git clone https://github.com/jarson7426/javascript.git project //clone仓库到本地。3、修改本地代码，提交到分支: git add file / git commit -m “新增文件”4、把本地库推送到远程库: git push origin master5、查看提交日志：git log -56、返回某一个版本：git reset --hard 1237、分支：git branch / git checkout name / git checkout -b dev8、合并name分支到当前分支：git merge name / git pull origin9、删除本地分支：git branch -D name10、删除远程分支： git push origin :daily/x.x.x11、git checkout -b mydev origin/daily/1.0.0 //把远程daily分支映射到本地mydev分支进行开发12、合并远程分支到当前分支 git pull origin daily/1.1.113、发布到线上： git tag publish/0.1.5 git push origin publish/0.1.5:publish/0.1.514、线上代码覆盖到本地： git checkout --theirs build/scripts/ddos git checkout --theirs src/app/ddos 结语希望本文总结的内容能给各位看官带来焕然一新的感觉。另外，如果你们有什么值得推荐的js技巧，欢迎在评论中补充，我可以收纳在本文中。 PS：此文档会持续新增内容。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yutaiwei.github.io/tags/javascript/"},{"name":"干货总结","slug":"干货总结","permalink":"http://yutaiwei.github.io/tags/干货总结/"}]},{"title":"正则的基础技巧","date":"2016-08-26T14:06:07.000Z","path":"2016/08/26/正则的基础技巧/","text":".jpg) 正则为什么要学习正则?更方便的校验，减少代码量，提升性能等等。 正则到底是什么?就是用来操作字符串来匹配捕获的一系列规则。 匹配：校验字符串是否符合我们的规则；返回一个布尔值 1reg.test() 捕获：将符合字符串规则的内容找出来；返回一个符合的字符串 正则的创建方式 字面量创建方式 1var reg = /^&amp;/ 实例创建 1var reg=new RegExp('^'+str) 二者区别 字面量创建不能进行变量拼接，但是，实例创建可以进行变量拼接； 字面量创建方式，特殊含义的字符不需要转移，但是，实例创建需要转义； 正则包括两个部分-元字符、修饰符 元字符：就是放在两个斜杠之间的代码 修饰符：g 全局 i 忽略大小写 m 换行； 特殊含义的元字符 符号 含义 \\ 转义 \\ 或 ( ) 分组 . 除了 \\n 以外的其他字符 \\n 换行 \\b 开头结尾和空格 ^ 开头 $ 结尾 \\s \\S 空格、非空格 \\d \\D 数字、非数字 \\w \\W 数字 字母 下划线、非(数字、字母、下划线) [a-z] 字母 [^a-z] 非字母 [abc] abc三个字母中的任何一个 [^abc] 除了这三个字母中的任何一个字符 代表次数的量词元字符 符号 含义 * 0到多 + 1到多 ? 0次或者1次 {n} 正好n次 {n,} n到多次 {n,m} n次到m次 修饰符 符号 含义 g 全局 i 忽略大小写 m 换行 小括号使用 提高优先级:凡是有|出现的时候，外面一定要加上( )来提高优先级；/^(18|19)$/ 分组 只匹配不捕获 (?: ) 正则的捕获 exec：exec拿到的是个数组，一般情况下这个数组有三项 1.符合大正则的内容 2.找到内容的索引 3.原始字符串； match replace 正则的两大特性 懒惰性：解决措施：全局g 贪婪性：解决措施：在两次元字符后面加上?号","tags":[]},{"title":"地铁站里的实验","date":"2016-08-17T02:17:06.000Z","path":"2016/08/17/地铁站里的实验/","text":".jpg) 作者：周云龙美国媒体二00七年的一个社会实验：一位男子在地铁站用小提琴演奏了巴赫的六首作品。他前面的地上，放一顶口子朝上的帽子。没有人知道，这位卖艺者是世界上最伟大的音乐家之一约夏．贝尔。他演奏的是一首世上最复杂的作品，用的是一把价值三百五十万美元的小提琴……在约夏．贝尔演奏的四十五分钟里，大约二千人经过，只有六个人停下来听了一会儿，大约二十人给了钱就匆匆离开，他总共收到三十二美元。而两天前，约夏．贝尔在波士顿一家剧院演出，所有门票售罄，聆听他演奏同样的乐曲，平均得花二百美元…… 这个实验，给人什么启示？电视圈的朋友甲点评说，环境影响人的评判能力t，环境决定一切！乙补充说，平台太重要啦！丙举例说，不是江苏卫视这样的平台，会做出《非诚勿扰》那样炫目的舞台吗？孟非一个歪瓜裂枣型的主持人能出得来吗？他还可能有那么大的影响力吗？ 约夏．贝尔在地铁里的演奏，据说是《华盛顿邮报》主办的关于感知、品味和人的优先选择的社会实验的一部分。实验结束后，《华盛顿邮报》提出了几个问题：一、在一个普通的环境下，在一个不适当的时间内，我们能够感知到美吗？二、如果能够感知到的话，我们会停下来欣赏吗？三、我们会在意想不到的情况下认可天才吗 地铁站的这个实验，内涵很丰富，操作蛮简单，它不过是利用了人们的审美惯性：地铁站里演唱的，都是为生活所逼卖艺的流浪汉。事实上，为生活所逼卖艺的人群中也可能有音乐天才。但是，要让以工薪阶层为主的“地铁一族”在行色匆匆之中能做出准确的判断，那是中彩的概率。说实话，高雅的音乐，本来就属于环境优雅的剧院，本来就属于自愿购票出入剧院的文人雅士。 美国地铁实验者最后得出的结论是：当世界上最好的音乐家，用世上最美的乐器来演奏世上最优秀的音乐时，如果我们连停留一会儿倾听都做不到的话，那么，在我们匆匆而过的人生中，我们又错过了多少其他东西呢？ 其实，与我们的错过相比，那些美好的人物、东西被错过，哪个更值得可惜呢？实验，可能只是虚拟的情境，但是，现实的生活中，就是现在，还很可能有?未被发现的音乐天才，正混迹于地铁站，任许多人走过、路过，也错过。 其实，一万人错过也无妨，但是，那双可以引导他走出地铁站走向大剧院的慧眼，不能错过。一个正常的健康的社会，也不该让他一直被错过。 身边的电视同行，常常有人拿“光头”孟非说事，我承认，平台确实很重要、环境也很重要。但是，要知道，孟非做过印刷厂工人，做过体育新闻的摄像记者，在这些并不引人关注的岗位上，就像有些昏暗、嘈杂的地铁站里，那么，谁最早发现了他的主持潜质？“发现”，有时倒还不难，又是谁最早大胆起用了没有主持经歷的他？他在民生新闻栏目做得如鱼得水之后，又是谁把他适时引入娱乐、综艺类节目的主持？主持转型一开始并不成功，可能还有好多非议吧，之后又是谁坚持继续给他试错的机会？ 或许，平台的“平”，核心价值可能就在于决策管理者的“水平”。所以，我在关注美国地铁站那个实验之后，最大的感触是，假定我路过那个地铁站了，假定我被音乐吸引了，停留了──我没有“错过”，而且我因为眼前的音乐人才而惊喜，因为他暂时的处境而纠结，那么，我又能有什么资格、有什么途径举荐他？接下来的问题更关键，在一个个更看重学歷、资歷、关系、背景的规则和潜规则设计里，又有谁愿意去重用他？谁能给他一个最适合的舞台？说到底，生活中的每一个个体，如何才能做有追求、有尊严的自主的人？ “我”错过又何妨？——只是错过了一道风景；“他”被错过情何堪！——或许错过的是一生。","tags":[{"name":"读者","slug":"读者","permalink":"http://yutaiwei.github.io/tags/读者/"},{"name":"周云龙","slug":"周云龙","permalink":"http://yutaiwei.github.io/tags/周云龙/"}]},{"title":"总结ES6常用的新特性","date":"2016-08-15T15:11:23.000Z","path":"2016/08/15/总结ES6常用的新特性/","text":".jpg) ES6是即将到来的新版本JavaScript语言的标准，他给我们带来了更”甜”的语法糖（一种语法，使得语言更容易理解和更具有可读性，也让我们编写代码更加简单快捷），如箭头函数（=&gt;）、class等等。用一句话来说就是： ES6给我们提供了许多的新语法和代码特性来提高javascript的体验 不过遗憾的是，现在还没有浏览器能够很好的支持es6语法，点这里查看浏览器支持情况，所以我们在开发中还需要用babel进行转换为CommonJS这种模块化标准的语法。 因为下面我会讲到一些es6新特性的例子，如果想要运行试试效果的话，可以点这里去测试es6的代码。 es6常用特性列举然后我下面简单的介绍一些很常用的语法特性，如果想完整的了解ES6，我推荐大家点这里 定义函数我们先来看一个基本的新特性，在javascript中，定义函数需要关键字function，但是在es6中，还有更先进的写法，我们来看： es6写法： 123456var human = &#123; breathe(name) &#123; //不需要function也能定义breathe函数。 console.log(name + ' is breathing...'); &#125;&#125;;human.breathe('jarson'); //输出 ‘jarson is breathing...’ 转成js代码： 123456var human = &#123; breathe: function(name) &#123; console.log(name + 'is breathing...'); &#125;&#125;;human.breathe('jarson'); 很神奇对不对？这样一对比，就可以看出es6的写法让人简单易懂。别着急，下面还有更神奇的。 创建类我们知道，javascript不像java是面向对象编程的语言，而只可以说是基于对象编程的语言。所以在js中，我们通常都是用function和prototype来模拟类这个概念。 但是现在有了es6，我们可以像java那样’明目张胆’的创建一个类了： 12345678910class Human &#123; constructor(name) &#123; this.name = name; &#125; breathe() &#123; console.log(this.name + \" is breathing\"); &#125;&#125;var man = new Human(\"jarson\");man.breathe(); //jarson is breathing 上面代码转为js格式： 12345678function Human(name) &#123; this.name = name; this.breathe = function() &#123; console.log(this.name + ' is breathing'); &#125;&#125;var man = new Human('jarson');man.breathe(); //jarson is breathing 所以我们看到，我们可以像java那样语义化的去创建一个类。另外，js中的继承父类，需要用prototype来实现。那么在es6中，又有什么新的方法来实现类的继承呢？继续看： 假如我们要创建一个Man类继承上面的Human类，es6代码： 123456789101112class Man extends Human &#123; constructor(name, sex) &#123; super(name); this.sex = sex; &#125; info()&#123; console.log(this.name + 'is ' + this.sex); &#125;&#125;var xx = new Man('jarson', 'boy');xx.breathe(); //jarson is breathingxx.info(); //arsonis boy 代码很简单，不作赘述，可以使用文章里提到的在线工具去试试效果就能明白了。需要注意的是：super()是父类的构造函数。 模块在ES6标准中，javascript原生支持module了。将不同功能的代码分别写在不同文件中，各模块只需导出(export)公共接口部分，然后在需要使用的地方通过模块的导入(import)就可以了。下面继续看例子： 内联导出ES6模块里的对象可在创建它们的声明中直接导出，一个模块中可无数次使用export。 先看模块文件app.js： 1234567891011121314export class Human&#123; constructor(name) &#123; this.name = name; &#125; breathe() &#123; console.log(this.name + \" is breathing\"); &#125;&#125; export function run()&#123; console.log('i am runing');&#125;function eat() &#123; console.log('i am eating');&#125; 例子中的模块导出了两个对象：Human类和run函数， eat函数没有导出，则仍为此模块私有，不能被其他文件使用。 导出一组对象另外，其实如果需要导出的对象很多的时候，我们可以在最后统一导出一组对象。 更改app.js文件： 123456789101112131415class Human&#123; constructor(name) &#123; this.name = name; &#125; breathe() &#123; console.log(this.name + \" is breathing\"); &#125;&#125; function run()&#123; console.log('i am runing');&#125;function eat() &#123; console.log('i am eating');&#125;export &#123;Human, run&#125;; 这样的写法功能和上面一样，而且也很明显，在最后可以清晰的看到导出了哪些对象。 Default导出导出时使用关键字default，可将对象标注为default对象导出。default关键字在每一个模块中只能使用一次。它既可以用于内联导出，也可以用于一组对象导出声明中。 查看导出default对象的语法： 12345... //创建类、函数等等export default &#123; //把Human类和run函数标注为default对象导出。 Human, run &#125;; 无对象导入如果模块包含一些逻辑要执行，且不会导出任何对象，此类对象也可以被导入到另一模块中，导入之后只执行逻辑。如： 1import './module1.js'; 导入默认对象使用Default导出方式导出对象，该对象在import声明中将直接被分配给某个引用，如下例中的”app”。 1import app from './module1.js'; 上面例子中，默认./module1.js文件只导出了一个对象；若导出了一组对象，则应该在导入声明中一一列出这些对象，如： 1import &#123;Human, run&#125; from './app.js' let与const在我看来，在es6新特性中，在定义变量的时候统统使用let来代替var就好了，const则很直观，用来定义常量，即无法被更改值的变量。 123for (let i=0;i&lt;2;i++) &#123; console.log(i); //输出: 0,1&#125; 箭头函数ES6中新增的箭头操作符=&gt;简化了函数的书写。操作符左边为输入的参数，而右边则是进行的操作以及返回的值，这样的写法可以为我们减少大量的代码，看下面的实例： 1234let arr = [6, 8, 10, 20, 15, 9];arr.forEach((item, i) =&gt; console.log(item, i));let newArr = arr.filter((item) =&gt; (item&lt;10));console.log(newArr); //[6, 8, 9]; 上面的(item, i)就是参数，后面的console.log(item, i)就是回到函数要执行的操作逻辑。 上面代码转为js格式： 12345678var arr = [6, 8, 10, 20, 15, 9];arr.forEach(function(item, i) &#123; return console.log(item, i);&#125;);var newArr = arr.filter(function(item) &#123; return (item &lt; 10);&#125;);console.log(newArr); 字符串模版ES6中允许使用反引号 ` 来创建字符串，此种方法创建的字符串里面可以包含由美元符号加花括号包裹的变量${vraible}。看一下实例就会明白了： 1234//产生一个随机数let num = Math.random();//将这个数字输出到consoleconsole.log(`your num is $&#123;num&#125;`); 解构若一个函数要返回多个值，常规的做法是返回一个对象，将每个值做为这个对象的属性返回。在ES6中，利用解构这一特性，可以直接返回一个数组，然后数组中的值会自动被解析到对应接收该值的变量中。我们来看例子： 12345function getVal() &#123; return [1, 2];&#125;var [x,y] = getVal(); //函数返回值的解构console.log('x:'+x+', y:'+y); //输出：x:1, y:2 默认参数现在可以在定义函数的时候指定参数的默认值了，而不用像以前那样通过逻辑或操作符来达到目的了。 123456789101112function sayHello(name)&#123; var name=name||'tom'; //传统的指定默认参数的方式 console.log('Hello '+name);&#125;//运用ES6的默认参数function sayHello2(name='tom')&#123; //如果没有传这个参数，才会有默认值， console.log(`Hello $&#123;name&#125;`);&#125;sayHello();//输出：Hello tomsayHello('jarson');//输出：Hello jarsonsayHello2();//输出：Hello tomsayHello2('jarson');//输出：Hello jarson 注意： sayHello2(name=&#39;tom&#39;)这里的等号，意思是没有传这个参数，则设置默认值，而不是给参数赋值的意思。 ProxyProxy可以监听对象身上发生了什么事情，并在这些事情发生后执行一些相应的操作。一下子让我们对一个对象有了很强的追踪能力，同时在数据绑定方面也很有用处。 12345678910111213//定义被监听的目标对象let engineer = &#123; name: 'Joe Sixpack', salary: 50 &#125;;//定义处理程序let interceptor = &#123; set(receiver, property, value) &#123; console.log(property, 'is changed to', value); receiver[property] = value; &#125;&#125;;//创建代理以进行侦听engineer = new Proxy(engineer, interceptor);//做一些改动来触发代理engineer.salary = 70;//控制台输出：salary is changed to 70 对于处理程序，是在被监听的对象身上发生了相应事件之后，处理程序里面的方法就会被调用。 结语总的来说，虽然支持es6的情况到目前还不是很乐观，但es6的新语法特性让前端和后端的差异越来越小了，这是一个新时代的开始，我们必须要了解这些新的前沿知识，才能跟上时代的步伐。","tags":[{"name":"es6","slug":"es6","permalink":"http://yutaiwei.github.io/tags/es6/"},{"name":"javascript","slug":"javascript","permalink":"http://yutaiwei.github.io/tags/javascript/"}]},{"title":"ES6的新写法","date":"2016-08-15T14:08:15.000Z","path":"2016/08/15/ES6的新写法/","text":".jpg) Let声明变量 let没有预解释 let定义的是块级作用域 123456789101112for(var i = 0;i&lt;3;i++)&#123; for(var i = 0;i&lt;3;i++)&#123; console.log(i) &#125;&#125;//i同时变化，输出012for(let i = 0;i&lt;3;i++)&#123; for(let i = 0;i&lt;3;i++)&#123; console.log(i) &#125;&#125;//形成块级作用域 输出012012012 let一个作用域内不可以重复声明 私有所用域的新写法 老写法 123~function()&#123;&#125; 新写法 12&#123;&#125;//一个花括号一个作用域 解构赋值 数组的解构 1234var [num1,num2] = arrconsole.log(num1,num2)//则num1等于arr[0]//num2等于arr[1] 对象的解构 123456let obj = &#123;name:'lkp',age:19,home:&#123;&#125;&#125;let name = obj.namelet age = obj.agelet&#123;name:name1,age:age1&#125; = obj;console.log(name1,age1)let&#123;name:&#123;province,city&#125;,hoddy:[one]&#125; 模板字符串1`此处添加一个变量$&#123;变量名&#125;` 箭头函数1234567891011let double = num =&gt; num*2;//声明一个函数名：箭头左边是参数右边是返回值，一进一出//如果多于一个参数，或者没有参数得话，左边要用小括号包裹let add = (a,b) =&gt; a+b//如果不只有返回值的话，需要用花括包裹，如果有返回值需要加returnlet add = (a,b) =&gt; &#123; console.log(a,b); return a+b;&#125;//箭头函数没有自己的this指针，只会引用外层this指针，定义阶段就已经确定箭头函数内部的没有this指针，也无法改变指向 数组的新方法 map filter find sort 声明的短属性12345let obj = &#123; name, age&#125;//当声明的变量名与变量值相等时，只写一个就可以 类123456789101112131415161718192021class Animal &#123; constructor()&#123; this.type = 'animal' &#125; says(say)&#123; console.log(this.type + ' says ' + say) &#125;&#125;let animal = new Animal()animal.says('hello') //animal says helloclass Cat extends Animal &#123; constructor()&#123; super() this.type = 'cat' &#125;&#125;let cat = new Cat()cat.says('hello') //cat says hello promise1234567891011121314151617181920212223242526272829class Promise &#123; //构造函数 constructor(task) &#123; //初始化一个私有变量 this._status = '初始态'; //开始执行task任务并且把绑定后的方法传进去 task(this.resolve.bind(this), this.reject.bind(this)); &#125;//成功方法 1. 把状态改为成功态 2.调用成功的回调 resolve(result) &#123; this._status = '成功态'; this._success(result); &#125;//失败的方法 1. 把状态改为失败态 2. 调用失败的回调 reject(err) &#123; this._status = '失败态'; this._fail(err); &#125; //用来给客户端 传入成功和失败的回调函数并保存在实例内部 then(success, fail) &#123; this._success = success; this._fail = fail; &#125;&#125;module.exports = Promise;promise有且只有一个方法，then方法，可以链式操作，执行一个成功的回调，一个失败的回调。 调用promise的方法123456789101112let promise = new Promise(function(resolve,reject)&#123; //这是我们的异步任务，里面会放一些异步任务代码 fs.readFile('1.txt','utf8',function(err,data)&#123; if(err)&#123; //如果失败了需要告诉 客户失败的原因 reject(err); &#125;else&#123; //如果成功了需要把结果送给客户 resolve(data); &#125; &#125;)&#125;); 同时执行多个并发promise.all请求，提高效率，提高可读性123Promise.all([xxx,xxx]).then(function(result)&#123; //promise参数中放的放的每一个回调函数，result中也是一个数据，为每一个回调的返回值。只有每个回调执行完成之后，才会执行then方法。&#125;) promise.race方法1类似all请求，会将先执行完的请求执行then方法","tags":[]},{"title":"ES6对数组的扩展","date":"2016-08-15T11:57:30.000Z","path":"2016/08/15/ES6对数组的扩展/","text":".jpg) ECMAScript6对数组进行了扩展，为数组Array构造函数添加了from()、of()等静态方法，也为数组实例添加了find()、findIndex()等方法。下面一起来看一下这些方法的用法。 Array.from()Array.from()将类数组(array-like)对象与可遍历的对象转化为数组并返回。例如将dom节点集合转化为数组，以前我们可能都会这样写： 1234var divs = document.querySelectAll(\"div\");[].slice.call(divs).forEach(function (node) &#123; console.log(node);&#125;) 现在我们可以这样写： 1234var divs = document.querySelectAll(\"div\");Array.from(divs).forEach(function (node) &#123; console.log(node);&#125;) 上面两种写法基本上是相同的。 Array.from()也可以将ES6中新增的Set、Map等结构转化为数组： 12// 将Set结构转化为数组Array.from(new Set([1, 2, 3, 4])); // [1, 2, 3, 4] 12//将Map结构转化为数组Array.from(new Map([\"name\", \"zlw\"])); // [\"name\", \"zlw\"] 字符串既是类数组又是可遍历的，所以Array.from()也可将字符串转化为数组： 1Array.from(\"zlw\"); // [\"z\", \"l\", \"w\"] Array.from()还有两个可选参数，完整语法如下： 1Array.from(obj, mapFn, thisArg) mapFn其实就是数组的map方法，对数组的每个元素处理。thisArg是执行环境的上下文。Array.from(obj, mapFn, thisArg)等同于Array.from(obj).map(mapFn, thisArg)。 Array.of()Array.of()将其参数转化为数组。如： 1Array.of(1, 2, 3); // [1, 2, 3] 我们知道用Array构造函数也可以实现同样功能： 1Array(1, 2, 3) // [1, 2, 3] 他们的不同之处在于： 123Array.of(3); // [3]Array(3) // [undefined, undefined, undefined] 当传入一个参数时，Array.of()会返回只有一个元素的数组，而Array()会返回长度为传入参数而元素都为undefined的数组。 Array.prototype.fill()fill()方法用一个值填充数组给定开始和结束位置之间的的所有值，语法如下： 1fill(value, start, end) 参数start、end是填充区间，包含start位置，但不包含end位置。如果省略，则start默认值为0，end默认值为数组长度。如果两个可选参数中有一个是负数，则用数组长度加上该数来确定相应的位置。例： 123[1, 2, 3].fill(4) // [4, 4, 4][1, 2, 3].fill(4, 1, 2) // [1, 4, 3][1, 2, 3].fill(4, -3, -2) // [4, 2, 3] Array.prototype.find()与Array.prototype.findIndex()find()方法返回数组中符合条件的第一个元素，如果没有则返回undefind。语法如下： 1array.find(callback, context); 参数包括一个回调函数和一个可选参数(执行环境上下文）。回调函数会遍历数组的所有元素，直到找到符合条件的元素，然后find()方法返回该元素。例： 1234567[1, 2, 3, 4].find(function(el, index, arr) &#123; return el &gt; 2;&#125;) // 3[1, 2, 3, 4].find(function(el, index, arr) &#123; return el &gt; 4;&#125;) // undefined findIndex()方法与find()方法用法类似，返回的是第一个符合条件的元素的索引，如果没有则返回-1。例： 1234567[1, 2, 3, 4].findIndex(function(el, index, arr) &#123; return el &gt; 2;&#125;) // 2[1, 2, 3, 4].findIndex(function(el, index, arr) &#123; return el &gt; 4;&#125;) // -1 Array.prototype.entries()、Array.prototype.keys与Array.prototype.values()entries()、keys与values都返回一个数组迭代器对象。例： 1234567891011121314var entries = [1, 2, 3].entries();console.log(entries.next().value); // [0, 1]console.log(entries.next().value); // [1, 2]console.log(entries.next().value); // [2, 3]var keys = [1, 2, 3].keys();console.log(keys.next().value); // 0console.log(keys.next().value); // 1console.log(keys.next().value); // 2var valuess = [1, 2, 3].values();console.log(values.next().value); // 1console.log(values.next().value); // 2console.log(values.next().value); // 3 迭代器的next()方法返回的是一个包含value属性与done属性的对象，而value属性是当前遍历位置的值，done属性是一个布尔值，表示遍历是否结束。 我们也可以用for...of来遍历迭代器： 123456789101112131415for (let i of entries) &#123; console.log(i)&#125; // [0, 1]、[1, 2]、[2, 3]for (let [index, value] of entries) &#123; console.log(index, value)&#125; // 0 1、1 2、2 3for (let key of keys) &#123; console.log(key)&#125; // 0, 1, 2for (let value of values) &#123; console.log(value)&#125; // 1, 2, 3 Array.prototype.copyWithin()copyWithin()方法语法如下： 1arr.copyWithin(target, start, end = this.length) 最后一个参数为可选参数，省略则为数组长度。该方法在数组内复制从start(包含start)位置到end(不包含end)位置的一组元素覆盖到以target为开始位置的地方。例： 123[1, 2, 3, 4].copyWithin(0, 1) // [2, 3, 4, 4][1, 2, 3, 4].copyWithin(0, 1, 2) // [2, 2, 3, 4] 如果start、end参数是负数，则用数组长度加上该参数来确定相应的位置： 1[1, 2, 3, 4].copyWithin(0, -2, -1) // [3, 2, 3, 4] 需要注意copyWithin()改变的是数组本身，并返回改变后的数组，而不是返回原数组的副本。 数组推导(array comprehensions)数组推导就是利用for...of循环基于现有的数组生成新数组。例： 1[for (i of [1, 2, 3]) i * i] // [1, 4, 9] 数组推导允许使用if语句： 12345// 单个if语句[for (i of [1, 2, 3]) if (i &lt; 3) i] // [1, 2]//多重if语句[for (i of [1, 2, 3]) if (i &lt; 3) if (i &gt; 1) i] // [2] 需要注意的是for...of总是写在最前面。 数组推导也允许使用多重for..of循环： 1[for (i of [1, 2, 3]) for (j of [4, 5, 6]) i * j] // [4, 5, 6, 8, 10, 12, 12, 15, 18] 数组推导中还可以包含数组推导： 1[for (i of [1, 2, 3]) [for (j of [4, 5, 6]) i * j]] // [[4, 5, 6], [8, 10, 12], [12, 15, 18]] 各大浏览器对ES6的支持可以查看kangax.github.io/es5-compat-table/es6/。","tags":[{"name":"ES6","slug":"ES6","permalink":"http://yutaiwei.github.io/tags/ES6/"},{"name":"Array","slug":"Array","permalink":"http://yutaiwei.github.io/tags/Array/"},{"name":"Array comprehensions","slug":"Array-comprehensions","permalink":"http://yutaiwei.github.io/tags/Array-comprehensions/"}]},{"title":"AngularJS按需加载js","date":"2016-08-02T15:57:39.000Z","path":"2016/08/02/AngularJS按需加载js/","text":".jpg) 前言Angular是一个单页面应用，随着系统的迭代，首屏代码会越来越大，所以对《AngularJS入门》中的代码进行改造，实现AngularJS可以按需加载js和css。 实现这个需求，有三个方案：1、利用requirejs。requirejs并不是按照angular规范开发的第三方插件，后期估计会有很多坑，放弃。 2、利用ui-router和ocLazyLoad。 每次“页面跳转”都要额外请求js并加载，浪费带宽增加页面加载时间，基本抛弃了预加载。 每一个路由都需要配置resolve属性，太low。 模块化程度太低，不利于以后代码移植和维护。 3、自己写需要的组件。最好的方案，然而技术要求太高，放弃。 综上，第三种方案暂时无法实现，放弃；第一种方案坑太多，放弃；第二种方案也不好，但是相对容易，而且是针对angular的插件，就它了。1234bower install angular#1.5.8bower install angular-ui-routerbower install oclazyloadbower install bootstrap 核心代码123456789101112131415161718192021222324252627282930313233&lt;!--dynamic/index.html--&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"zh\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;link rel=\"stylesheet\" href=\"bower_components/bootstrap/dist/css/bootstrap.min.css\"&gt; &lt;style&gt; body&#123; font-family: \"Microsoft Yahei\"; &#125; .navigator&#123; width: 500px;margin: 0 auto &#125; .navigator li&#123; color: #000;font-size: 14px; &#125; &lt;/style&gt; &lt;title&gt;按需加载js&lt;/title&gt;&lt;/head&gt;&lt;body ng-app=\"myApp\"&gt; &lt;ul class=\"navigator nav nav-pills\"&gt; &lt;li role=\"presentation\" class=\"active\"&gt;&lt;a href=\"#home\" ng-click=\"isActive($event)\"&gt;主页&lt;/a&gt;&lt;/li&gt; &lt;li role=\"presentation\" class=\"active\"&gt;&lt;a href=\"#page2\"&gt;Page2&lt;/a&gt;&lt;/li&gt; &lt;li role=\"presentation\" class=\"active\"&gt;&lt;a href=\"#page3\" ng-click=\"isActive($event)\"&gt;Page3&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div ui-view style=\"width: 500px;margin: 50px auto 0\"&gt;&lt;/div&gt;&lt;script src=\"bower_components/angular/angular.min.js\"&gt;&lt;/script&gt;&lt;script src=\"bower_components/angular-ui-router/release/angular-ui-router.min.js\"&gt;&lt;/script&gt;&lt;script src=\"bower_components/oclazyload/dist/ocLazyLoad.min.js\"&gt;&lt;/script&gt;&lt;script src=\"public/js/index.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/* *dynamic/public/js/index.js*/var myApp=angular.module(\"myApp\",[\"ui.router\",\"oc.lazyLoad\"]);myApp.config(function ($stateProvider,$urlRouterProvider) &#123; $urlRouterProvider.when(\"\",\"/home\"); $stateProvider.state('home',&#123; url:\"/home\", templateUrl: 'views/homepage.html', controller: 'homeController', resolve:&#123; loadMyCtrl:['$ocLazyLoad',function ($ocLazyLoad) &#123; return $ocLazyLoad.load(&#123; name:\"homeApp\", files:[\"public/js/homepage.js\"] &#125;) &#125;] &#125; &#125;); $stateProvider.state('page2',&#123; url:\"/page2\", templateUrl:'views/page2.html', resolve:&#123; loadMyCtrl:function ($ocLazyLoad) &#123; return $ocLazyLoad.load(&#123; name:'page2App', files:[\"public/js/page2.js\"] &#125;) &#125; &#125; &#125;) $stateProvider.state('page3',&#123; url:\"/page3\", templateUrl:'views/page3.html', resolve:&#123; loadMyCtrl:function ($ocLazyLoad) &#123; return $ocLazyLoad.load(&#123; name:'page3App', files:[\"public/js/page3.js\",\"public/js/page3-ext.js\"] &#125;) &#125; &#125; &#125;) &#125;); 12345&lt;!--dynamic/views/homepage.html--&gt;&lt;div id=\"home\" ng-controller=\"homeController\"&gt; &lt;h1&gt;首页&lt;/h1&gt; &#123;&#123;content&#125;&#125;&lt;/div&gt; 123456/* *dynamic/public/js/homepage.js*/angular.module('myApp').controller('homeController', function ($scope) &#123; $scope.content = '这是主页的内容';&#125;); 完整代码github自取：https://github.com/voidking/angulardemo/tree/master/dynamic 书签RequireJS官方文档http://requirejs.org/docs/start.html Dynamically Loading Controllers and Views with AngularJShttp://weblogs.asp.net/dwahlin/dynamically-loading-controllers-and-views-with-angularjs-and-requirejs angular应用如何实现按需加载http://www.alloyteam.com/2015/10/angular-application-how-to-load-on-demand/ 尝试通过AngularJS模块按需加载搭建大型应用（上）http://web.jobbole.com/86915/ 尝试通过AngularJS模块按需加载搭建大型应用（下）http://web.jobbole.com/87025/ angularjs ocLazyLoad分步加载js文件,angularjs ocLazyLoad按需加载jshttp://m.w2bc.com/article/158713 按需加载 AngularJS 的 Controllerhttp://beginor.github.io/2014/12/20/angularjs-controller-load-on-demand.html","tags":[{"name":"angularjs","slug":"angularjs","permalink":"http://yutaiwei.github.io/tags/angularjs/"},{"name":"前端","slug":"前端","permalink":"http://yutaiwei.github.io/tags/前端/"}]},{"title":"AngularJS入门篇","date":"2016-08-02T11:53:09.000Z","path":"2016/08/02/AngularJS入门篇/","text":".jpg) 前言AngularJS是一个JavaScript框架，它通过指令扩展了HTML，且通过表达式绑定数据到 HTML。顺便一提，什么是框架？比如struts2、spring、hibernate、thinkphp、wordpress等等。那么，什么是组件？比如jdbc、jquery、swiper、layer、arttemplate等等。一般来说，那些可复用的、用于简化开发工作的代码集合，大的叫框架，小的叫组件。有人说jquery是框架？当然可以，大小并没有明确边界。不要太纠结于概念，如无必要，勿增实体。 本文，主要学习归纳一下Angular的各种特性，包括双向数据绑定、定义应用和控制器、优化模板渲染延迟、自定义指令、作用域、HTTP请求获取数据、自定义服务、依赖注入、路由控制等。最后，会给出一个综合实例。 双向数据绑定单向数据绑定的原理：模板+数据=&gt;视图。目前大多数前端框架都是单向数据绑定，比如jQueryUI、BackBone、Flex。 双向数据绑定原理：模板+数据=&gt;视图，模板+视图=&gt;数据。 Angular采用的，就是双向数据绑定。 123456789101112131415&lt;!--helloworld.html--&gt;&lt;!DOCTYPE html&gt;&lt;html ng-app&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;双向数据绑定&lt;/title&gt; &lt;script src=\"http://code.angularjs.org/angular-1.0.1.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; Hello &#123;&#123;'World'&#125;&#125;!&lt;br/&gt; Your name: &lt;input type=\"text\" ng-model=\"yourname\" placeholder=\"World\"&gt; &lt;hr&gt; Hello &#123;&#123;yourname || 'World'&#125;&#125;!&lt;/body&gt;&lt;/html&gt; 定义应用和控制器angular对象，是Angular的根对象。类似于express框架中的express对象，类似于seajs框架的seajs对象，类似于浏览器的window对象。如果说angular对象是Angular中的班主任，那么应用（或者叫模块，app）就是Angular中的班长！而班主任不常出没，管事的就是班长。控制器（controller），就是普通同学小明，负责控制Angular应用程序中的数据。 123456789101112131415161718192021222324252627282930313233343536&lt;!--app.html--&gt;&lt;!DOCTYPE html&gt;&lt;html ng-app=\"myApp\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;定义应用和控制器&lt;/title&gt; &lt;style&gt; [ng\\:cloak], [ng-cloak], [data-ng-cloak], [x-ng-cloak], .ng-cloak, .x-ng-cloak &#123; display: none !important; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div ng-controller=\"myCtrl\"&gt; 名: &lt;input type=\"text\" ng-model=\"firstName\"&gt;&lt;br&gt; 姓: &lt;input type=\"text\" ng-model=\"lastName\"&gt;&lt;br&gt; &lt;br&gt; 姓名: &lt;span&gt;&#123;&#123;firstName + \" \" + lastName&#125;&#125;&lt;/span&gt;&lt;br&gt; 姓名2: &lt;span class=\"ng-cloak\"&gt;&#123;&#123;fullName()&#125;&#125;&lt;/span&gt;&lt;br&gt; 姓名3: &lt;span ng-bind=\"fullName()\"&gt;&lt;/span&gt; &lt;/div&gt; &lt;script src=\"http://code.angularjs.org/angular-1.0.1.min.js\"&gt;&lt;/script&gt; &lt;script&gt; var app = angular.module('myApp', []); app.controller('myCtrl', function($scope) &#123; $scope.firstName= \"John\"; $scope.lastName= \"Doe\"; $scope.fullName = function() &#123; return $scope.firstName + \" \" + $scope.lastName; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 优化模板渲染延迟在定义应用和控制器的例子中，我们看到，页面上先出现了表达式，之后才出现我们期望的结果。解决这个问题，常用的有两个办法。一个是使用ng-bind，另一个是添加ng-cloak样式。 自定义指令12345678910111213141516171819202122232425262728&lt;!--directive.html--&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;自定义指令&lt;/title&gt; &lt;script src=\"http://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js\"&gt;&lt;/script&gt; &lt;/head&gt;&lt;body ng-app=\"myApp\"&gt; &lt;runoob-directive&gt;&lt;/runoob-directive&gt; &lt;div runoob-directive&gt;&lt;/div&gt; &lt;div class=\"runoob-directive\"&gt;&lt;/div&gt; &lt;!-- 指令: runoob-directive --&gt; &lt;script&gt; var app = angular.module(\"myApp\", []); app.directive(\"runoobDirective\", function() &#123; return &#123; //restrict : \"A\", //restrict : \"C\", //restrict : \"M\", //replace : true, template : \"&lt;h1&gt;自定义指令!&lt;/h1&gt;\" &#125;; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 作用域12345678910111213141516171819202122232425262728&lt;!--scope.html--&gt;&lt;!DOCTYPE html&gt;&lt;html ng-app=\"myApp\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;作用域&lt;/title&gt; &lt;script src=\"http://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div ng-controller=\"myCtrl\"&gt; &lt;h1&gt;姓氏为 &#123;&#123;lastname&#125;&#125; 家族成员:&lt;/h1&gt; &lt;ul&gt; &lt;li ng-repeat=\"x in names\"&gt;&#123;&#123;x&#125;&#125; &#123;&#123;lastname&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; var app = angular.module('myApp', []); app.controller('myCtrl', function($scope, $rootScope) &#123; $scope.names = [\"Emil\", \"Tobias\", \"Linus\"]; $rootScope.lastname = \"Refsnes\"; &#125;); &lt;/script&gt; &lt;p&gt;注意 $rootScope 在循环对象内外都可以访问。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 上面的例子中，$scope的作用域为myCtrl这个ng-controller的范围，$rootScope的作用域为myApp这个ng-app的范围。 HTTP请求获取数据获取本地数据123456789101112131415161718192021222324&lt;!--http.html--&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;HTTP请求&lt;/title&gt; &lt;script src=\"http://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body ng-app=\"myApp\" &gt; &lt;div ng-controller=\"myCtrl\"&gt; &lt;h1&gt;欢迎你！&#123;&#123;username&#125;&#125;&lt;/h1&gt; &lt;/div&gt; &lt;p&gt; $http 服务向服务器请求信息，返回的值放入变量 \"username\" 中。&lt;/p&gt;&lt;script&gt; var app = angular.module('myApp', []); app.controller('myCtrl', function($scope, $http) &#123; $http.get(\"http.json\").then(function (response) &#123; $scope.username = response.data.username; &#125;); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; http.json中的内容为：123&#123; \"username\":\"voidking\" &#125; 需要注意的是，本例需要在服务器中访问。因为Angular的HTTP请求封装了XMLHttpRequest，而XMLHttpRequest的使用需要服务器环境。 获取服务器数据123456789101112131415161718192021222324252627282930313233343536373839&lt;!--http2.html--&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;HTTP请求服务器数据&lt;/title&gt; &lt;script src=\"http://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body ng-app=\"myApp\" &gt; &lt;div ng-controller=\"myCtrl\"&gt; &lt;h1&gt;欢迎你！&#123;&#123;username&#125;&#125;&lt;/h1&gt; &lt;/div&gt; &lt;p&gt; $http 服务向服务器请求信息，返回的值放入变量 \"username\" 中。&lt;/p&gt;&lt;script&gt; var app = angular.module('myApp', []); app.controller('myCtrl', function($scope, $http, $httpParamSerializer) &#123; $http(&#123; method:'POST', url:'/angulardemo/http.php', headers:&#123; 'Content-Type':'application/x-www-form-urlencoded' &#125;, dataType: 'json', data: $httpParamSerializer(&#123;username:'voidking'&#125;) &#125;).then(function successCallback(response) &#123; console.log(response.data); $scope.username = response.data.username; &#125;, function errorCallback(response) &#123; console.log(response.data); &#125;);; &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 新建http.php，内容如下：123456789&lt;?php $username = $_POST['username']; $result = array( 'code' =&gt; '0', 'ext' =&gt; 'success', 'username' =&gt; $username ); echo json_encode($result);?&gt; 自定义服务123456789101112131415161718192021222324252627282930313233343536373839&lt;!--service.html--&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;自定义Service&lt;/title&gt; &lt;script src=\"http://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body ng-app=\"myApp\" &gt; &lt;div ng-controller=\"myCtrl\"&gt; &lt;p&gt;自定义服务，用于转换16进制数：&lt;/p&gt; &lt;p&gt;255 的16进制是:&lt;/p&gt; &lt;h1&gt;&#123;&#123;hex&#125;&#125;&lt;/h1&gt; &lt;hr&gt; &lt;p&gt;在获取数组 [255, 251, 200] 值时使用过滤器:&lt;/p&gt; &lt;ul&gt; &lt;li ng-repeat=\"x in counts\"&gt;&#123;&#123;x | myFormat&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;script&gt; var app = angular.module('myApp', []); app.service('hexafy', function() &#123; this.myFunc = function (x) &#123; return x.toString(16); &#125; &#125;); app.controller('myCtrl', function($scope, hexafy) &#123; $scope.hex = hexafy.myFunc(255); $scope.counts = [255, 251, 200]; &#125;); app.filter('myFormat',['hexafy', function(hexafy) &#123; return function(x) &#123; return hexafy.myFunc(x); &#125;; &#125;]);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 当创建了自定义服务，并连接到应用上后，我们可以在控制器，指令，过滤器或其他服务中使用它。 依赖注入AngularJS 提供很好的依赖注入机制。什么是依赖注入？wiki 上的解释是：依赖注入（Dependency Injection，简称DI）是一种软件设计模式，在这种模式下，一个或更多的依赖（或服务）被注入（或者通过引用传递）到一个独立的对象（或客户端）中，然后成为了该客户端状态的一部分。该模式分离了客户端依赖本身行为的创建，这使得程序设计变得松耦合，并遵循了依赖反转和单一职责原则。与服务定位器模式形成直接对比的是，它允许客户端了解客户端如何使用该系统找到依赖。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293&lt;!--di.html--&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;AngularJS依赖注入&lt;/title&gt;&lt;/head&gt; &lt;body ng-app=\"mainApp\" &gt; &lt;h2&gt;AngularJS 简单应用&lt;/h2&gt; &lt;div ng-controller=\"CalcController\"&gt; &lt;p&gt;配置：&#123;&#123;constant&#125;&#125;&lt;/p&gt; &lt;p&gt;输入一个数字: &lt;input type = \"number\" ng-model = \"number\" /&gt;&lt;/p&gt; &lt;button ng-click = \"square()\"&gt;X&lt;sup&gt;2&lt;/sup&gt;&lt;/button&gt; &lt;p&gt;结果: &#123;&#123;result&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;hr&gt; &lt;div ng-controller=\"CalcController2\"&gt; &lt;p&gt;再输入一个数字: &lt;input type = \"number\" ng-model = \"number\" /&gt;&lt;/p&gt; &lt;button ng-click = \"square()\"&gt;X&lt;sup&gt;2&lt;/sup&gt;&lt;/button&gt; &lt;p&gt;结果: &#123;&#123;result&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script src=\"http://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js\"&gt;&lt;/script&gt;&lt;script&gt; var mainApp = angular.module(\"mainApp\", []); mainApp.config(function($provide) &#123; // 创建一个名叫MathService的provider $provide.provider('MathService', function() &#123; this.$get = function() &#123; var factory = &#123;&#125;; factory.multiply = function(a, b) &#123; return a * b; &#125; return factory; &#125;; &#125;); &#125;); // 创建一个名叫defaultInput的value mainApp.value(\"defaultInput\", 5); // 创建一个名叫constant的constant value mainApp.constant(\"constant\", \"constant value\"); // 将MathService、defaultInput、constant注入到控制器 mainApp.controller('CalcController', function($scope, MathService, defaultInput, constant) &#123; $scope.number = defaultInput; $scope.constant = constant; $scope.result = MathService.multiply($scope.number,$scope.number); $scope.square = function() &#123; $scope.result = MathService.multiply($scope.number,$scope.number); &#125; &#125;); /*--------以下是CalcController2的内容--------*/ // 创建一个名叫MathService2的factory mainApp.factory('MathService2', function() &#123; var factory = &#123;&#125;; factory.multiply = function(a, b) &#123; return a * b; &#125; return factory; &#125;); // 创建一个名叫CalcService2的service，并且注入MathService2 mainApp.service('CalcService2', function(MathService2)&#123; this.square = function(a) &#123; return MathService2.multiply(a,a); &#125; &#125;); // 将CalcService2注入到控制器 mainApp.controller('CalcController2',function($scope,CalcService2)&#123; $scope.number = 6; $scope.result = CalcService2.square($scope.number); $scope.square = function() &#123; $scope.result = CalcService2.square($scope.number,$scope.number); &#125; &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; provider()函数是用来创建provider对象的标准方法。 实际上，value()、constant()、factory()、service()全都是用来创建一个provider对象的方法，它们提供了一种方式来定义一个provider，而无需输入所有的复杂的代码。 路由控制AngularJS 路由允许我们通过不同的 URL 访问不同的内容。通过 AngularJS 可以实现多视图的单页Web应用（single page web application，SPA）。通常我们的URL形式为http://runoob.com/first/page ，但在单页Web应用中AngularJS 通过 # + 标记 实现，例如：123http://runoob.com/#/firsthttp://runoob.com/#/secondhttp://runoob.com/#/third 当我们点击以上的任意一个链接时，向服务端请的地址都是一样的 (http://runoob.com/)。 因为 # 号之后的内容在向服务端请求时会被浏览器忽略掉。 所以我们就需要在客户端实现 # 号后面内容的功能实现。 AngularJS 路由 就通过 # + 标记 帮助我们区分不同的逻辑页面并将不同的页面绑定到对应的控制器上。 AngularJS 模块的 config 函数用于配置路由规则。通过使用 configAPI，我们请求把$routeProvider注入到我们的配置函数并且使用$routeProvider.whenAPI来定义我们的路由规则。$routeProvider 为我们提供了 when(path,object) &amp; otherwise(object) 函数按顺序定义所有路由，函数包含两个参数:第一个参数是 URL 或者 URL 正则规则。第二个参数是路由配置对象。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!--router.html--&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"zh\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;路由控制&lt;/title&gt;&lt;/head&gt;&lt;body ng-app=\"ngRouteExample\" class=\"ng-scope\"&gt; &lt;div&gt; &lt;div id=\"navigation\"&gt; &lt;a href=\"#/home\"&gt;Home&lt;/a&gt; &lt;a href=\"#/about\"&gt;About&lt;/a&gt; &lt;/div&gt; &lt;div ng-view=\"\"&gt; &lt;/div&gt;&lt;script type=\"text/ng-template\" id=\"embedded.home.html\"&gt; &lt;h1&gt; Home &lt;/h1&gt;&lt;/script&gt;&lt;script src=\"http://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js\"&gt;&lt;/script&gt;&lt;script src=\"http://apps.bdimg.com/libs/angular-route/1.3.13/angular-route.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; angular.module('ngRouteExample', ['ngRoute']) .controller('HomeController', function ($scope, $route) &#123; $scope.$route = $route;&#125;) .controller('AboutController', function ($scope, $route) &#123; $scope.$route = $route;&#125;) .config(function ($routeProvider) &#123; $routeProvider. when('/home', &#123; templateUrl: 'embedded.home.html', controller: 'HomeController' &#125;). when('/about', &#123; templateUrl: 'about.html', controller: 'AboutController' &#125;). otherwise(&#123; redirectTo: '/home' &#125;); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 12&lt;!--about.html--&gt;&lt;h1&gt; About &lt;/h1&gt; 综合123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!--complex.html--&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"zh\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;综合实例&lt;/title&gt;&lt;/head&gt;&lt;body ng-app=\"ngRouteExample\" class=\"ng-scope\"&gt; &lt;div&gt; &lt;div id=\"navigation\"&gt; &lt;a href=\"#/page1\"&gt;Page1&lt;/a&gt; &lt;a href=\"#/page2\"&gt;Page2&lt;/a&gt; &lt;/div&gt; &lt;div ng-view=\"\"&gt; &lt;/div&gt;&lt;script src=\"http://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js\"&gt;&lt;/script&gt;&lt;script src=\"http://apps.bdimg.com/libs/angular-route/1.3.13/angular-route.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; var myApp = angular.module('ngRouteExample', ['ngRoute']); myApp.controller('Page1Controller', function ($scope, $route) &#123; $scope.$route = $route; $scope.content = '这是page1的内容'; &#125;); myApp.controller('Page2Controller', function ($scope, $route) &#123; $scope.$route = $route; $scope.content = '这是page2的内容'; &#125;) myApp.config(function ($routeProvider) &#123; $routeProvider. when('/page1', &#123; templateUrl: 'complex-page1.html', controller: 'Page1Controller' &#125;). when('/page2', &#123; templateUrl: 'complex-page2.html', controller: 'Page2Controller' &#125;). otherwise(&#123; redirectTo: '/page1' &#125;); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 12345&lt;!--complex-page1.html--&gt;&lt;div id=\"page1\" ng-controller=\"Page1Controller\"&gt; &lt;h1&gt;Page1&lt;/h1&gt; &lt;p&gt;&#123;&#123;content&#125;&#125;&lt;/p&gt;&lt;/div&gt; 12345&lt;!--complex-page2.html--&gt;&lt;div id=\"page2\" ng-controller=\"Page2Controller\"&gt; &lt;h1&gt;Page2&lt;/h1&gt; &lt;p&gt;&#123;&#123;content&#125;&#125;&lt;/p&gt;&lt;/div&gt; 后记至于输入验证、事件、动画、API等，本文不再讨论，用到时自行查阅文档。本文完整源码地址：https://github.com/voidking/angulardemo 记录一个hexo的坑：如果文中出现了双括号，而且双括号没有被代码块包含，那么解析会报错，无法生成页面。 查找到的解决办法：123&#123;% raw %&#125;内容&#123;% endraw %&#125; 经测试，无效，就用汉字代替好了。 书签AngularJS实战http://www.imooc.com/learn/156 AngularJS 教程 | 菜鸟教程http://www.runoob.com/angularjs/angularjs-tutorial.html AngularJS中文网http://www.apjs.net/ AngularJS中文社区http://angularjs.cn/ 图灵社区: 合集 : AngularJS入门教程http://www.ituring.com.cn/minibook/303 AngularJS: API: API Referencehttps://docs.angularjs.org/api ngCloakhttps://docs.angularjs.org/api/ng/directive/ngCloak AngularJS : Why ng-bind is better than 双括号 in angular?http://stackoverflow.com/questions/16125872/angularjs-why-ng-bind-is-better-than-in-angular Metronic3.3网页模板在线演示http://metronic.kp7.cn/ 框架到底是个什么东西？https://www.zhihu.com/question/32069908 理解AngularJS中的依赖注入http://sentsin.com/web/663.html Hexo的一个小BUG(Template render error)http://www.jianshu.com/p/738ebe02029b","tags":[{"name":"angularjs","slug":"angularjs","permalink":"http://yutaiwei.github.io/tags/angularjs/"},{"name":"前端","slug":"前端","permalink":"http://yutaiwei.github.io/tags/前端/"},{"name":"hexo","slug":"hexo","permalink":"http://yutaiwei.github.io/tags/hexo/"}]},{"title":"flex布局详解","date":"2016-07-26T14:01:10.000Z","path":"2016/07/26/flex布局详解/","text":".jpg) flex布局flex可以指定对齐方式，可以解决所有盒子的对齐方式。并利用上页面中的剩余空间。 首先要给最外层的元素设置 12display:flex//或者display:inlineflex 设定主轴的方向 主轴默认是从左往右的方向 交叉轴默认是从上往下的，与主轴垂直。1flex-direction:row|row-reverse// 超出容器是否换行 1234flex-wrap: wrap;//超出后换行flex-wrap: wrap-reverse;//超出后换行 从下往上 复合属性 12flex-flow: column wrap;//超出后换行并且竖直方向排列 确定主轴的对齐方式 12justify-content: flex-end;//flex-start flex-space-ground flex-space-between 交叉轴对齐方式 1234align-items: flex-end;//在交叉轴方向从底部对齐align-items: baseline;//在交叉轴方向从文字基线对齐 设置子容器在父容器中的对齐方式 会覆盖 align-items的值1align-self: center; 处理交叉轴的空白空间 12align-content: flex-start;//对多行起作用，超出的部分会自动留白，并且向头部靠拢，单行使用 align-items 安排容器的排列顺序 - order 12order: -1;//默认值是0，值越小越在前面，可以为负值 基本步骤为： 设置布局方式 设定主轴方向 子元素超过父容器是否换行 确定子元素在主轴或者交叉轴的对齐方式 order安排子元素的排列顺序 核心属性 flex-grow 扩展比例：当盒子中有剩余空间时起作用 默认值0 flex-shrink 收缩比例：当有溢出内容时起作用 默认值是1 flex-basis 基准值：当扩展容器或者收缩容器 时以此值为基准 默认值为auto//基准值为auto时计算中会默认取宽度 溢出比例计算方式为父元素的总宽度 x 基准值的和 y 扩展比例的总和 k ，如果3个盒子每个扩展比例为a、b、c则每个盒子的宽度为(x-y)*a/k+每个盒子自己的基准值 收缩比例的计算方式为：每个子元素算上收缩比例的基准值/所有子元素算上收缩比例的基准值 = 收缩的内容/溢出的内容 ==注意如果有内容，不能收缩到小于自身内容的宽度==","tags":[]},{"title":"利用box-shadow制作loading图","date":"2016-07-26T00:00:00.000Z","path":"2016/07/26/利用box-shadow制作loading图/","text":".jpg) 我们见过很多利用css3做的loading图，像下面这种应该是很常见的。通常制作这种loading，我们会一个标签对应一个圆，八个圆就要八个标签。但是这种做法很浪费资源。我们可以只用一个标签，然后利用box—shadow来制作一个loading图。 .loading { font-size: 30px; width: 1em; height: 1em; border-radius: 50%; margin: 100px auto; box-shadow: 0 -2em rgba(255, 0, 0, 1), 1.414em -1.414em rgba(255, 0, 0, 0.875), 2em 0 rgba(255, 0, 0, 0.75), 1.414em 1.414em rgba(255, 0, 0, 0.625), 0 2em rgba(255, 0, 0, 0.5), -1.414em 1.414em rgba(255, 0, 0, 0.375), -2em 0 rgba(255, 0, 0, 0.25), -1.414em -1.414em rgba(255, 0, 0, 0.125); animation: rotate 1s infinite forwards steps(8, end);} @keyframes rotate { 100% { -moz-transform: rotate(360deg); }} 首先，需要一个标签： &lt;div class=&quot;loading&quot;&gt;&lt;/div&gt; 然后是css： $fontSize: 30px; $radius: 2em; .loading { font-size: $fontSize; width: 1em; height: 1em; border-radius: 50%; margin: 100px auto; box-shadow: 0 -2em rgba(255, 0, 0, 1), 1.414em -1.414em rgba(255, 0, 0, 0.875), 2em 0 rgba(255, 0, 0, 0.75), 1.414em 1.414em rgba(255, 0, 0, 0.625), 0 2em rgba(255, 0, 0, 0.5), -1.414em 1.414em rgba(255, 0, 0, 0.375), -2em 0 rgba(255, 0, 0, 0.25), -1.414em -1.414em rgba(255, 0, 0, 0.125); } 单位用的是em，这样如果要修改圆的大小，就只需要修改font-size就可以了，如果用px的话，一旦需要修改大小，那么涉及单位的就都要修改了。 关键css就是： box-shadow: 0 -2em rgba(255, 0, 0, 1), 1.414em -1.414em rgba(255, 0, 0, 0.875), 2em 0 rgba(255, 0, 0, 0.75), 1.414em 1.414em rgba(255, 0, 0, 0.625), 0 2em rgba(255, 0, 0, 0.5), -1.414em 1.414em rgba(255, 0, 0, 0.375), -2em 0 rgba(255, 0, 0, 0.25), -1.414em -1.414em rgba(255, 0, 0, 0.125); 需要用到多重阴影，每一个阴影就是一个圆了。设置它们的坐标需要用到三角函数。先要设定一个半径(如2em)，然后360度平均分成8份，每份是45度，利用三角函数就可以计算阴影的偏移位置了。还有就是圆的颜色渐变，就是设置它们的不同透明度。 上面做出来的是静态的，还需要让它动起来： $fontSize: 30px; $radius: 2em; .loading { font-size: $fontSize; width: 1em; height: 1em; border-radius: 50%; margin: 100px auto; box-shadow: 0 -2em rgba(255, 0, 0, 1), 1.414em -1.414em rgba(255, 0, 0, 0.875), 2em 0 rgba(255, 0, 0, 0.75), 1.414em 1.414em rgba(255, 0, 0, 0.625), 0 2em rgba(255, 0, 0, 0.5), -1.414em 1.414em rgba(255, 0, 0, 0.375), -2em 0 rgba(255, 0, 0, 0.25), -1.414em -1.414em rgba(255, 0, 0, 0.125); animation: rotate 1s infinite forwards steps(8, end); } @keyframes rotate { 100% { transform: rotate(360deg); } } steps()这个函数可以让动画分步进行，而不是连贯性的。 好了，上面就是全部的代码了，很少。上面的box-shadow其实我是手算的，本来我想利用sass的for循环计算的，结果没有成功。希望高手能指点一下。","tags":[{"name":"css3","slug":"css3","permalink":"http://yutaiwei.github.io/tags/css3/"},{"name":"loading","slug":"loading","permalink":"http://yutaiwei.github.io/tags/loading/"}]},{"title":"css3 transform属性多个值的顺序问题","date":"2016-07-26T00:00:00.000Z","path":"2016/07/26/css3-transform属性多个值的顺序问题/","text":".jpg) 对于transform属性的多值的顺序问题，我自己就被困扰过。后来知道了跟顺序有关，但是不知道为什么。我想应该很多人跟我以前一样，知其然不知其所以然。如果不知道的，也许这篇文章会对大家有所帮助。 先来看一个例子。 html代码: &lt;div id=&quot;red1&quot;&gt;&lt;/div&gt; &lt;div id=&quot;red2&quot;&gt;&lt;/div&gt; css代码： body { margin: 0; } div { width:100px; height:100px; background:red; } #red1 { transform: rotate(45deg); } #red2 { transform: rotate(45deg) translate(100px, 100px); } 红框一transform属性只有一个值rotate(45deg)，红框二多了一个值translate(100px, 100px)，水平和竖直都平移100px，但是从图中可以看到红框2只有竖直方向有位移。这是怎么回事？ 其实，当旋转45度后，元素的整个坐标系都旋转了45度，如下图： 图1就是正常的坐标系，图2就是旋转45度后的坐标系。所以红框二就按旋转后的坐标系进行平移。因为我设置的值比较特殊，所以只有在竖直方向有位移。通过计算红框二竖直向下平移了100√2px，也就是红框对角线的长度。 我们再来看一个例子。 html代码: &lt;div id=&quot;red&quot;&gt;&lt;/div&gt; &lt;div id=&quot;green&quot;&gt;&lt;/div&gt; css代码： body { margin: 0; } div { width:100px; height:100px; position: absolute; top: 50px; left: 100px; } #red { background:red; transform: rotate(45deg) translate(100px, 100px); } #green { background:green; transform: translate(100px, 100px) rotate(45deg); } 图中可以看到，值的顺序对元素位置的影响。通过上面的介绍知道，红框先旋转再平移，即先旋转坐标系再平移，而绿框先按正常的坐标系平移，再旋转，所以它们的位置就不同了。 我们可以举一反三，比如3d旋转等都可以按上面的方法去分析。 (完)","tags":[{"name":" transform","slug":"transform","permalink":"http://yutaiwei.github.io/tags/transform/"},{"name":"css3","slug":"css3","permalink":"http://yutaiwei.github.io/tags/css3/"}]},{"title":"JavaScript正则表达式","date":"2016-07-15T04:37:03.000Z","path":"2016/07/15/JavaScript正则表达式/","text":".jpg) 前言正则表达式（Regular Expression）主要是用来描述一个句法规则的模式。其实说的通俗一点，就是利用字符和元字符的组合，对一些符合既定句法的模式进行模糊匹配。它的主要功能是文本查询和字符串操作。本文讨论一下JavaScript中的正则表达式用法。 定义正则表达式1、定义正则表达式有两种形式，一种是普通方式，一种是构造函数方式。2、普通方式：var reg=/表达式/附加参数表达式：一个字符串，代表了某种规则，其中可以使用某些特殊字符，来代表特殊的规则，后面会详细说明。附加参数：用来扩展表达式的含义，目前主要有三个参数：g：代表可以进行全局匹配。i：代表不区分大小写匹配。m：代表可以进行多行匹配。上面三个参数，可以任意组合，代表复合含义，当然也可以不加参数。例子：12var reg=/a*b/;var reg=/abc+f/g; 3、构造函数方式：var reg=new RegExp(“表达式”,”附加参数”);其中“表达式”与“附加参数”的含义与上面那种定义方式中的含义相同。例子：12var reg=new RegExp(\"a*b\");var reg=new RegExp(\"abc+f\",\"g\"); 4、普通方式与构造函数方式的区别普通方式中的表达式必须是一个常量字符串，而构造函数中的表达式可以是常量字符串，也可以是一个js变量，例如根据用户的输入来作为表达式参数等等：1var reg=new RegExp(document.forms[0].exprfiled.value,\"g\"); 表达式模式1、表达式模式，是指表达式的表达方式与样式， 即 var reg=/表达式/附加参数 中的“表达式”怎样去描述？2、从规范上讲，表达式模式分为简单模式和复合模式。3、简单模式：是指通过普通字符的组合来表达的模式，例如1var reg=/abc0d/; 可见简单模式只能表示具体的匹配。4、复合模式：是指含有通配符来表达的模式，例如：1var reg=/a+b?\\w/; 其中的+、?和\\w都属于通配符，代表着特殊的含义。因此复合模式可以表达更为抽象化的逻辑。复合模式中各个通配符的含义及其使用请阅读下文给出的参考文档。 表达式操作1、表达式操作，在这里是指和表达式相关的方法，我们将介绍六个方法。2、表达式对象（RegExp）方法： （1）exec(str)，返回str中与表达式相匹配的第一个字符串，而且以数组的形式表现，当然如果表达式中含有捕捉用的小括号，则返回的数组中也可能含有()中的匹配字符串，例如：12var regx=/\\d+/;var rs=regx.exec(\"3432ddf53\"); 返回的rs值为：{3432}12var regx2=new RegExp(\"ab(\\d+)c\");var rs2=regx2.exec(\"ab234c44\"); 返回的rs2值为：{ab234c,234}另外，如果有多个合适的匹配，则第一次执行exec返回一个第一个匹配，此时继续执行exec，则依次返回第二个第三个匹配。例如：123var regx=/user\\d/g;var rs=regx.exec(\"ddduser1dsfuser2dd\");var rs1=regx.exec(\"ddduser1dsfuser2dd\"); 则rs的值为{user1}，rs1的值为{user2}，当然注意regx中的g参数是必须的，否则无论exec执行多少次，都返回第一个匹配。后面还有相关内容涉及到对此想象的解释。 （2）test(str)，判断字符串str是否匹配表达式，返回一个布尔值。例如：12var regx=/user\\d+/g;var flag=regx.test(\"user12dd\"); flag的值为true。 3、String对象方法 （1）match(expr)，返回与expr相匹配的一个字符串数组，如果没有加参数g，则返回第一个匹配，加入参数g则返回所有的匹配例子：123var regx=/user\\d/g;var str=\"user13userddduser345\";var rs=str.match(regx); rs的值为：{user1,user3} （2）search(expr)，返回字符串中与expr相匹配的第一个匹配的index值。例子：123var regx=/user\\d/g;var str=\"user13userddduser345\";var rs=str.search(regx); rs的值为：0 （3）replace(expr,str)，将字符串中匹配expr的部分替换为str。另外在replace方法中，str中可以含有一种变量符号$，格式为$n，代表匹配中被记住的第n的匹配字符串（注意小括号可以记忆匹配）。例子：123var regx=/user\\d/g;var str=\"user13userddduser345\";var rs=str.replace(regx,\"00\"); rs的值为：003userddd0045例子2：123var regx=/u(se)r\\d/g;var str=\"user13userddduser345\";var rs=str.replace(regx,\"$1\"); rs的值为：se3userdddse45对于replace(expr,str)方法还要特别注意一点，如果expr是一个表达式对象则会进行全局替换（此时表达式必须附加参数g，否则也只是替换第一个匹配），如果expr是一个字符串对象，则只会替换第一个匹配的部分，例如：123var regx=\"user\"var str=\"user13userddduser345\";var rs=str.replace(regx,\"00\"); rs的值为： 0013userddduser345 （4）split(expr)，将字符串以匹配expr的部分做分割，返回一个数组，而且表达式是否附加参数g都没有关系，结果是一样的。例子：123var regx=/user\\d/g;var str=\"user13userddduser345\";var rs=str.split(regx); rs的值为：{3userddd,45} 表达式相关属性1、表达式相关属性，是指和表达式相关的属性，如下面的形式：12var regx=/myexpr/;var rs=regx.exec(str); 其中，和表达式自身regx相关的属性有两个，和表达式匹配结果rs相关的属性有三个，下面将逐一介绍。2、和表达式自身相关的两个属性： （1）lastIndex，返回开始下一个匹配的位置，注意必须是全局匹配（表达式中带有g参数）时，lastIndex才会有不断返回下一个匹配值，否则该值为总是返回第一个下一个匹配位置，例如：1234567var regx=/user\\d/;var rs=regx.exec(\"sdsfuser1dfsfuser2\");var lastIndex1=regx.lastIndex;rs=regx.exec(\"sdsfuser1dfsfuser2\");var lastIndex2=regx.lastIndex;rs=regx.exec(\"sdsfuser1dfsfuser2\");var lastIndex3=regx.lastIndex; 上面lastIndex1为9，第二个lastIndex2也为9，第三个也是9；如果regx=/user/d/g，则第一个为9，第二个为18，第三个为0。 （2）source，返回表达式字符串自身。例如：123var regx=/user\\d/;var rs=regx.exec(\"sdsfuser1dfsfuser2\");var source=regx.source; source的值为user\\d3、和匹配结果相关的三个属性： （1）index，返回当前匹配的位置。例如：1234567var regx=/user\\d/;var rs=regx.exec(\"sdsfuser1dfsfuser2\");var index1=rs.index;rs=regx.exec(\"sdsfuser1dfsfuser2\");var index2=rs.index; rs=regx.exec(\"sdsfuser1dfsfuser2\");var index3=rs.index; index1为4，index2为4，index3为4，如果表达式加入参数g，则index1为4，index2为13，index3会报错（index为空或不是对象）。 （2）input，用于匹配的字符串。例如：123var regx=/user\\d/;var rs=regx.exec(\"sdsfuser1dfsfuser2\");var input=rs.input; input的值为sdsfuser1dfsfuser2。 （3）[0]，返回匹配结果中的第一个匹配值，对于match而言可能返回一个多值的数字，则除了[0]外，还可以取[1]、[2]等等。例如：12345var regx=/user\\d/;var rs=regx.exec(\"sdsfuser1dfsfuser2\");var value1=rs[0];rs=regx.exec(\"sdsfuser1dfsfuser2\");var value2=rs[0]; value1的值为user1,value2的值为user2 实际应用1、实际应用一描述：有一表单，其中有一个“用户名”input域要求：汉字，而且不能少于2个汉字，不能多于4个汉字。实现：12345678910111213141516&lt;script&gt;function checkForm(obj)&#123; var username=obj.username.value; var regx=/^[\\u4e00-\\u9fa5]&#123;2,4&#125;$/g; if(!regx.test(username))&#123; alert(\"Invalid username!\"); return false; &#125; return true;&#125;&lt;/script&gt;&lt;form name=\"myForm\" onSubmit=\"return checkForm(this)\"&gt; &lt;input type=\"text\" name=\"username\"/&gt; &lt;input type=\"submit\" vlaue=\"submit\"/&gt;&lt;/form&gt; 2、实际应用二描述：给定一个含有html标记的字符串，要求将其中的html标记去掉。实现：1234567891011&lt;script&gt;function toPlainText(htmlStr)&#123; var regx=/&lt;[^&gt;]*&gt;|&lt;\\/[^&gt;]*&gt;/gm; var str=htmlStr.replace(regx,\"\"); return str;&#125;&lt;/script&gt;&lt;form name=\"myForm\"&gt; &lt;textarea id=\"htmlInput\"&gt;&lt;/textarea&gt; &lt;input type=\"button\" value=\"submit\" onclick=\"toPlainText(document.getElementById('htmlInput').value\"/&gt;&lt;/form&gt; 参考文档js正则表达式语法http://blog.csdn.net/zaifendou/article/details/5746988 正则表达式30分钟入门教程http://demo.voidking.com/reprint/正则表达式/正则表达式30分钟入门教程.htm 常用的正则表达式http://demo.voidking.com/reprint/正则表达式/常用的正则表达式.htm 正则表达式速查表http://demo.voidking.com/reprint/正则表达式/正则表达式速查表.htm 正则表达式测试器http://demo.voidking.com/reprint/正则表达式/正则表达式测试器.htm 正则表达式在线测试器详情请见：http://demo.voidking.com/reprint/regexpal/ deerchao大侠正则表达式原文地址http://www.jb51.net/tools/zhengze.html","tags":[{"name":"前端","slug":"前端","permalink":"http://yutaiwei.github.io/tags/前端/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yutaiwei.github.io/tags/JavaScript/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://yutaiwei.github.io/tags/正则表达式/"}]},{"title":"JavaScript之函数科里化","date":"2016-07-15T00:00:00.000Z","path":"2016/07/15/JavaScript之函数柯里化/","text":".jpg) 什么是柯里化(currying)？维基百科中的解释是：柯里化是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。意思就是当函数被调用时，返回的函数还需要设置一些传入的参数。首先来看一个简单的例子，有下面一个函数： function add(num1, num2) { return num1 + num2; } 我们把它改写成下面这样： var fn = function(a) { return function (b) { return a + b; } } 可以这样调用函数：fn(2)(3)。上面使用了匿名函数来实现多参数函数的方法，虽然这并不是柯里化的函数，但可以帮助我们理解柯里化的含义。 ###实现通用柯里化函数###我们可以在内置构造函数Function()的原型上来添加一个柯里化函数，这样所有的函数都可以调用。下面是通用柯里化函数的实现： Function.prototype.currying = function () { var that = this; var args = [].slice.call(arguments); return function () { return that.apply(null, args.concat([].slice.call(arguments))); } } 现在用柯里化函数将上面的add函数柯里化： var curriedAdd = add.currying(2); curriedAdd(3); // 5 也可以一次性传入两个参数： var curriedAdd = add.currying(2， 3); curriedAdd(); // 5 我们知道在原生对象的原型上扩展方法是不太好的，因为可能会导致命名冲突。所以最好不要把currying函数扩展在Function的原型上，下面是改写的currying函数： function currying(fn) { var args = [].slice.call(arguments, 1); return function () { return that.apply(null, args.concat([].slice.call(arguments))); } } 改写之后currying函数的第一个参数是要被柯里化的函数，可以这样调用： var curriedAdd = currying(add, 2); curriedAdd(3); // 5 或 var curriedAdd = currying(add, 2， 3); curriedAdd(); // 5 上面的add函数只是两个数字的相加，如果我们需要n个数字相加，上面的currying函数已经不能满足要求了，下面是修改后的currying函数： function currying(fn) { var argsArr = []; return function () { if (arguments.length === 0) { return fn.apply(null, argsArr); } else { [].push.apply(argsArr, arguments); } } } 多个数字相加： var add = function () { var num = 0; [].forEach.call(arguments, function (item, i) { num += item; }) return num; } var curriedAdd = currying(add); curriedAdd(2); curriedAdd(3); curriedAdd(4); curriedAdd(5); curriedAdd(); 这样做有什么好处呢？假如说我们只想知道这个月花了多少钱，而中间的某一天之前花了多少我们并不想知道，我们只在乎结果，不在乎过程，上面的currying函数很好地解决了这个问题。有的人说这样做可以节省性能，我倒觉得这和性能没多大关系，或者说这样做的目的并不是为了性能，因为每次计算结果和最后一起计算结果是一样的，都是要计算一样的次数。还有一个好处就是可以复用currying函数，比如我们要多个数字相乘或者其他操作，都可以用currying函数，处理数字只需修改fn参数就可以。 说到柯里化就不得不说Function.prototype.bind这个方法了，它也实现了函数的柯里化。我们可以自己来实现一个bind函数： function bind（fn, context） { var args = [].slice.call(arguments, 2); return function () { return fn.apply(context, args.concat([].slice.call(arguments))); } } 假如我们需要改变fn中的this上下文，就可以用bind函数，否则可以用currying函数。","tags":[{"name":"科里化","slug":"科里化","permalink":"http://yutaiwei.github.io/tags/科里化/"},{"name":"curry","slug":"curry","permalink":"http://yutaiwei.github.io/tags/curry/"},{"name":"currying","slug":"currying","permalink":"http://yutaiwei.github.io/tags/currying/"}]},{"title":"input绑定回车事件","date":"2016-07-10T02:26:43.000Z","path":"2016/07/10/input绑定回车事件/","text":".jpg) html部分：1&lt;input id=\"search-key\" type=\"text\" placeholder=\"请输入关键字\"&gt; JavaScript部分：1234567$('#search-key').keypress(function(event) &#123; var key = event.which; console.log(key); if(key == 13)&#123; //do something &#125;&#125;);","tags":[{"name":"前端","slug":"前端","permalink":"http://yutaiwei.github.io/tags/前端/"},{"name":"jquery","slug":"jquery","permalink":"http://yutaiwei.github.io/tags/jquery/"}]},{"title":"人因梦想而伟大","date":"2016-07-05T13:10:07.000Z","path":"2016/07/05/人因梦想而伟大/","text":".jpg) 作者：雷军 2014年11月21日晚，雷军在北大团中央主办的“活力中国说——一刻大型公益演讲”启动仪式上发表了演讲。北大国家发展研究院BiMBA对该活动提供了学术支持。部分MBA、EMBA校友有幸与小米科技创始人雷军先生展开了一场短暂而精彩的交流。以下为演讲实录。 每一个屌丝都渴望像马云一样逆袭 昨天我在乌镇参加了全球互联网峰会，在这个会议上有马云，也有苹果公司的高级副总裁。主持人抛出了一个问题，说：“雷军，你说你有一个目标，要用五到十年的时间，做成智能手机市场份额的全球第一”。我忙着点头，我的确说过。但是他没有问我，他去问苹果公司的高管，说：你怎么看？这个苹果公司的高管也很厉害，他说：“Easy to Say, Hard to Do”（说起来简单，做起来难）。在那一刻，我觉得很尴尬，主持人说：“雷军，你怎么想？” 我冷静了一下，我说：“马云在阿里巴巴上市的那一刻，说过一句话，‘梦想还是要有的，万一实现了呢’？”我的演说水平远远没办法跟马云相比，马云的号召力和演说水平，我是望尘莫及。除了我湖北普通话之外，我觉得我一个做技术和作为理工科的人来说，跟他的口才比不了，因为马云也是毕业于非常非常有名的名校，不亚于北京大学，叫杭州师范大学，专门培养老师的，真的比我能说，尤其是我听了马云在上市的时候还讲过说：像他这样的都能成功的话，80%的中国人都可以成功，这个听得我们每个人都热血沸腾。他说“我高考几次落榜，好不容易上了杭州师范大学还找不到工作”。当然马云今天有资格讲这个话，讲得也特别震撼，每个人，尤其每一个屌丝都渴望像马云一样逆袭。 创业时，“十来个人，七八条枪，要去做手机，有谁相信我们能赢呢？” 讲完马云这句名言以后，我又补了一段话。我说四年多前小米刚刚创业，在中关村，十来个人，七八条枪，要去做手机，有谁相信我们能赢呢？手机这个行业是刀山火海，前面有三星，有苹果，后面有联想，有华为。我们看到摩托罗拉不行了，诺基亚也不行了，黑莓也不行了，连HTC也不行了，最近索尼也不行了。这个市场竞争极为激烈，一个正常人讲到智能手机，就觉得这个市场竞争很激烈。 三年杀到全国第一，总该有点“全球第一”的梦想 三年前我们的产品刚刚发布。仅仅用了三年时间，谁又想过这十来个人的小公司，用了不到三年时间，有苹果、有三星、有华为、有联想，在这个市场里面杀到了全中国第一，全球第三。当我们今天有这样的业绩，有这样的起跑线，我觉得我们总应该有一点点梦想，用五到十年时间杀到全球第一吧。对吗？原来我们至少排在一百名开外。 功成名就后，人生四十再出发 所以梦想还是要有的，那四年前我梦想的动力来源于哪里呢？其实办小米对我来说是一个很难很难的事情，为什么呢？是因为我在办小米之前有幸参与了金山软件的创办，今天我依然是金山软件的董事长和大股东，而且我还有幸办过一个电子商务公司，叫卓越网，后来卖给了亚马逊，应该来说我的人生也足够了。所以在金山IPO之后我退休了，还干了三四年的投资，而且做天使投资，业绩还不错，绝对能排上中国天使投资界的第一排，肯定没问题。 那你说做投资总不能天天这么操心吧，是什么样的动力使我下定决心去干这么累的一件事情呢？这件事真的很累。我在那个阶段，在我做天使投资、从金山退休的那个阶段，我有一天晚上从梦中醒来，我问了自己一个问题：我40岁了，在别人眼里功成名就，已经退休了，还干着人人都很羡慕的投资，我还有没有勇气去追寻我小时候的梦想？ 我觉得岁数越大，谈梦想越难。大家现在都是最有梦想的时候，你们到了40岁的时候还有梦想吗？面对残酷的现实，还有几个能笑对今天，笑对明天呢？我当时问我自己，我还有没有勇气去试一把，这么试下去风险很高，有可能身败名裂，有可能倾家荡产，而且更重要的是我在别人眼里已经是一个成功者，我需要冒这么大的风险去做这么艰难的一件事情吗？其实我真的犹豫了半年时间。最后我觉得这种梦想激励我自己一定要去赌一把，我说只有这样做，我的人生才是圆满的，至少当我老了的时候，我还可以很自豪地说：“我曾经有过梦想，我曾经去试过，哪怕输了”。所以我最后下定了决心办了小米。 当“雷布斯”遇见乔布斯，《硅谷之火》点燃梦想 办小米刚开始我认为我100%会输，我想的全部是我怎么死，我真的很庆幸，我们居然只用了三年，完成了一个连我自己都没法相信的结果。那么我的梦想是什么？我为什么会这样的梦想？ 是因为我跟大家同样岁数的时候，在我18岁的那一年，曾经青春年少，无意之中在图书馆看了一本书，改变了我一生。那是我大学一年级第一学期，我上的是武汉大学，我在我们武大的图书馆看了一本书，这本书叫《硅谷之火》，那是1987年。这本书讲述的是七十年代末、八十年代初，那些硅谷的英雄创业的故事，其中主要的篇章就是讲乔布斯的故事。乔布斯在七十年代末、八十年代初就代表着美国创业。 我记得九十年代的时候，比尔·盖茨很成功的时候，比尔·盖茨讲“我不过是乔布斯第二”，乔布斯在八十年代就已经如日中天。当时看了这本书，激动的我自己心情久久难以平静。我清晰的记得看了这本书以后，我在武汉大学的那个操场上，沿着那个400米的跑道走了一圈又一圈，走了好几个通宵，我怎么能塑造与众不同的人生？ 我想的更多的是说在我们中国这个土壤上，我们能不能像乔布斯一样办一家世界一流的公司？我觉得只有这样，你才无愧于你的人生，才会使你自己觉得人生是有价值、有意义、有追求的。当然，在二十六七年前的中国，条件比今天差很多，要做点事情远没有今天容易。 当我有这样的梦想以后，我认为说起来容易，做起来难——放到口头上是没有用的，怎么能够落实到实际学习和工作中？我当时给我的第一个计划，在二十六七年前，就是两年修完大学所有的课程。我真的是武汉大学在八十年代不多的两个双学位，而且我绝大部分的成绩应该都是优秀，几乎所有的课。我记得我的成绩在我们同学里面排到全年级第六，我们全年级一百多人。 所以怎么能够落实到第一个梦想？就是我能够在一个赛道上把学习学完，因为我认为你还是要有基本功的沉淀，有了第一个基本功的沉淀，我们又给出了第二个目标。大家说你有没有本事在一级学报上发篇论文？我就用两年的时间在一级学报上发篇论文，我说我一定要完成第二个目标。为了琢磨这个我在图书馆里面读了很多一级学报，到底发什么文章呢，他们到底在做什么。 所以，有梦想是件简单的事情，关键是有了梦想以后，你能不能把这个东西付诸实践，你怎么去实践，你怎么给自己设定一个又一个可行的目标？当然，有了这样的目标还是不够的，因为要成功不是一件简单的事情，他需要你长时间的坚韧不拔，百折不挠。就像我自己，到了我40岁退休了以后，我还有没有勇气去试一把？ 所以非常感谢我们组委会给了我这个机会，今天我可以很自豪的跟大家分享，我在40岁的时候没有忘记我18岁的梦想，我去试了。虽然我知道今天的小米说成功为时过早，说谈击败苹果为时过早，但是“梦想总是要有的吧，万一实现了呢”？ 人因梦想而伟大 我比大家大概大两轮，大20多岁，我也跟很多年轻人经常交流梦想。我自己特别特别喜欢一句话，叫做“人因梦想而伟大”。在下午我们讨论的时候，还有人说这是美国哪个总统讲的，是，我说是我抄来的，我觉得我们在这里的每个人，只要你有了梦想，你就变得与众不同。周星驰也讲过一句名言，叫“人没有梦想，和咸鱼有什么差别”。所以你关键要有梦想，有了梦想是你迈向成功的第一步，有了第一步以后，你一定要为自己的梦想去准备各种坚实的基础。 成功需要勤奋和把握机遇 那么谈到梦想的实现，我最近还有一句话挺出名的，也是我抄来的。叫“台风来的时候，猪都会飞”，听说过吗？就是说你要成功了，要找台风口，当台风飞过来的时候，猪都可以飞，是猪你都可以飞。 当然了，我其实想表达两层的意思，尤其是给在座的同学们，我觉得第一个：没有坚实的基本功，没有勤奋是成功不了的：第二个，有了勤奋，有了坚实的基础也不一定能成功。 还需要什么呢？还需要台风口。还需要把握大的发展机遇，把这个机遇把握好，抓住这个机会，你才有机会成功。那么小米把握的是什么机会呢？为什么这个台风这么厉害呢？ 其实小米精准的踏到了智能手机换机的时间，诺基亚不行了，苹果刚刚起来，小米应运而生，用了一套全新的模式，在短短三年时间里面成了中国第一。其实整个成长速度远超想象，小米三年做下来，今年大概有多大规模呢？今年大概销售6500万只手机，营业额大概会在700亿人民币到800亿人民币，这是一个三四年的创业公司。这个应该已经创造了全球的奇迹，这背后是什么呢？这背后是坚实的基本功和非常好的对时机的把握。 给北大学生的三条锦囊妙计 所以我自己工作了20多年，我对各位同学们的建议就是： 第一条，要有梦想。第二条，要设定Step by Step努力的目标，要制定阶段性的目标，不要着急。第三条，要重视机遇的重要性。我觉得很聪明的一些同学都觉得聪明加勤奋天下无敌，其实仅有聪明和勤奋是远远不够的，怎么把握时代的机遇，怎么在大方向上正确，我觉得这一点也非常关键。 所以今天只有短短的一刻钟，感谢两位老师给我省了这么多时间，我就简单的讲到这里，谢谢大家。 来源：北大国家发展研究院BiMBA","tags":[{"name":"读者","slug":"读者","permalink":"http://yutaiwei.github.io/tags/读者/"},{"name":"雷军","slug":"雷军","permalink":"http://yutaiwei.github.io/tags/雷军/"},{"name":"演讲","slug":"演讲","permalink":"http://yutaiwei.github.io/tags/演讲/"}]},{"title":"青春有价","date":"2016-07-05T13:09:11.000Z","path":"2016/07/05/青春有价/","text":".jpg) 作者：薛涌 许多“一无所有”的年轻人，对房子、汽车望眼欲穿，几乎不惜牺牲一切。我则想说：如果你大学毕业时的裤子日后穿不进去了，这条裤子就不再属于你了。怎么没有人担心自己对这条裤子能拥有多久呢？我这么说，是觉得人们越来越只用一把尺子衡量生活：买了什么牌子的车？买了多大的房？人家有了，我有了没有？但大家都忘记了另外一把尺子：你为了得到，究竟失去了什么？如今房奴、车奴充斥于世，这充分反映了这种单一价值观对我们生活的塑造力。20多年前，我曾写过一篇随笔，讲新婚之后我们夫妻二人的生活状态。在我看来，当你买一件自己不真正需要的东西时，就开始受这个东西的奴役。比如，我要买一双时髦的旅游鞋，立即会在家庭财政上戳个窟窿。为了补这个窟窿，就得抽出时间去挣钱，哪怕是干不想干的事情。这等于拿自己生命的一部分去换这双鞋。所以，我必须想一想：这双鞋究竟有多重要？ 这就是我们当时的生活状况。当时我们俩只有我有工作，拿200多块的死工资，无房无奖金，两人在北京很难过下去。妻子则英文、日文俱佳，当时正赶上外企大举进军北京，机会多多。记得有一次，一家工厂的日本专家找不到翻译无法工作，请她去帮3天忙，一天100块。在那年月，这算是挺吓人的报酬了。 可她从不多干。理由是：我们不会把自己的青春减价出售。我们结婚时一无所有，但都知道自己还年轻，要用青春追求新的生活，即出国留学。当时留学很难，而我的英语几乎要从头开始学。所以，我们很清楚，要尽可能把青春投入自己的发展。20年后，如果我们建立了自己的事业，回首今天的艰辛，当是人生最为美好的时刻。难道就为了100块一天给卖了？不卖，坚决不卖！ 当然，生活要维持，必要的工作还是要干的。但是，如果我们除了食物外基本不消费，穿旧衣服，那么就能最大限度地降低出去工作的需要，把青春最大限度地留给自己。就这样，我们闷头发奋4年，妻子先考取了耶鲁大学的博士；缺乏英语才能的我，得以混了个家属的资格跟去，因为在旁听时小有表现，也成了那里的学生。想想都是多亏没有贱卖青春，留着给自己长了点本事。 到耶鲁后，我先是家属，后来读硕士课程，免学费但无奖学金。那时妻子拿的全额奖学金，其实比当地的最低生活线还少几百块。那时也有些校内打工的机会，我们在没有办法时也干过一点，但只要生活能维持，就不会干。道理还是：青春不减价拍卖。 在美国的头几年，我的衣服几乎全是街上邻居搬家清理旧货时买的，比如10美分一条的牛仔裤等等，尺寸不对也勉强凑合着穿。但那时却是我们求知生涯中最珍贵的，那时一无所有的状态，其实是最为富足的。如今年过半百，回想起来，最为庆幸的还是：青春有价，没有贱卖。当然，我们从来没有忘了锻炼身体，对裤子的所有权绝不肯放弃。","tags":[{"name":"读者","slug":"读者","permalink":"http://yutaiwei.github.io/tags/读者/"},{"name":"薛涌","slug":"薛涌","permalink":"http://yutaiwei.github.io/tags/薛涌/"}]},{"title":"仿淘宝图片放大器","date":"2016-07-04T12:55:17.000Z","path":"2016/07/04/仿淘宝图片放大器/","text":".jpg) 原理两个盒子，盒子1放小图片，盒子2放对应的大图片。盒子1里的图片正常显示，盒子2里的图片隐藏。在盒子1的图片标签中，加入大图的数据链接。当鼠标在盒子1上移动时，通过鼠标在盒子1的位置计算出盒子2中应该显示的大图的部分。 以下代码中，利用到了jquery.jqzoom.js插件。 代码12345&lt;div id=\"preview\" class=\"spec-preview\"&gt; &lt;span class=\"jqzoom\"&gt; &lt;img jqimg=\"images/b1.jpg\" src=\"images/s1.jpg\" /&gt; &lt;/span&gt; &lt;/div&gt; 123$(function()&#123; $(\".jqzoom\").jqueryzoom(&#123;xzoom:380,yzoom:380&#125;);&#125;); 参考文档jquery.jqzoom.js图片放大镜http://www.cnblogs.com/sydeveloper/p/3796330.html ImageZoom 图片放大效果http://www.cnblogs.com/cloudgamer/archive/2010/04/01/ImageZoom.html jQuery-实现图片的放大镜显示效果 jquery插件 放大镜http://www.jq-school.com/Article.aspx?kid=41 jQzoom简介http://www.oschina.net/p/jqzoom?fromerr=tUayHgqO","tags":[{"name":"前端","slug":"前端","permalink":"http://yutaiwei.github.io/tags/前端/"},{"name":"jQuery","slug":"jQuery","permalink":"http://yutaiwei.github.io/tags/jQuery/"},{"name":"插件","slug":"插件","permalink":"http://yutaiwei.github.io/tags/插件/"}]},{"title":"纯CSS实现一个微信logo，需要几个标签？","date":"2016-07-02T03:13:24.000Z","path":"2016/07/02/纯css实现一个微信logo，需要几个标签？/","text":"纯CSS实现一个微信logo并不难，难的是怎样用最少的html标签实现。我一直在想怎样用一个标签就能实现，最后还是没想出来，就只好用两个标签了。 首先需要两个标签元素： 123&lt;div class=\"bg\"&gt; &lt;div class=\"inner\"&gt;&lt;/div&gt;&lt;/div&gt; 先画个背景： 1234567.bg &#123; width: 300px; height: 300px; background-color: #08c406; border-radius: 10px; position: relative;&#125; 再画个大的椭圆： 123456789.inner &#123; width: 180px; height: 150px; border-radius: 50%; background-color: #fff; position: absolute; top: 60px; left: 35px;&#125; 小的椭圆利用.inner的::before伪元素实现： 1234567891011&amp;::before &#123; content: \"\"; width: 140px; height: 120px; border-radius: 50%; background-color: #fff; position: absolute; top: 60px; left: 90px; border: 2px solid #08c406;&#125; 下图时现在的结果： 里面的四个圆怎么画呢？可以利用CSS3的box-shadow属性实现，一般重复性的东西都会用这个属性，因为它可以制造出无数个一模一样的东西出来。 利用.bg的::before伪元素实现这些圆： 123456789101112&amp;::before &#123; content: \"\"; position: absolute; width: 16px; height: 16px; border-radius: 50%; background-color: #08c406; top: 150px; left: 155px; z-index: 2; box-shadow: 70px 0 #08c406, -70px -50px 0 2px #08c406, 0 -50px 0 2px #08c406;&#125; ::before本身会实现一个圆(一个小圆),然后利用box-shadow属性实现其它的三个圆。 来看看现在的效果： 现在就剩下两个角了，想想还有哪些东西没用上？还有两个伪元素，分别是.bg的::after和.inner的::after，刚好可以实现两个角。 这两个角其实就是平常的小三角，然后再旋转个45度，CSS实现小三角太常见了： 123456789101112131415161718192021.bg::after &#123; content: \"\"; border-width: 30px 12px; border-style: solid; border-color: #fff transparent transparent transparent; position: absolute; top: 182px; left: 50px; transform: rotate(45deg);&#125;.inner::after &#123; content: \"\"; border-width: 30px 10px; border-style: solid; border-color: #fff transparent transparent transparent; position: absolute; top: 155px; left: 200px; transform: rotate(-45deg);&#125; 最终效果： 全部css代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960@mixin pos($left, $top) &#123; position: absolute; left: $left; top: $top;&#125;.bg &#123; width: 300px; height: 300px; background-color: #08c406; border-radius: 10px; position: relative; &amp;::before &#123; @include pos(155px, 150px); content: \"\"; width: 16px; height: 16px; border-radius: 50%; background-color: #08c406; z-index: 2; box-shadow: 70px 0 #08c406, -70px -50px 0 2px #08c406, 0 -50px 0 2px #08c406; &#125; &amp;::after &#123; @include pos(50px, 182px); content: \"\"; border-width: 30px 12px; border-style: solid; border-color: #fff transparent transparent transparent; transform: rotate(45deg); &#125; .inner &#123; width: 180px; height: 150px; border-radius: 50%; background-color: #fff; @include pos(35px, 60px); &amp;::before &#123; @include pos(90px, 60px); content: \"\"; width: 140px; height: 120px; border-radius: 50%; background-color: #fff; border: 2px solid #08c406; &#125; &amp;::after &#123; @include pos(200px, 155px); content: \"\"; border-width: 30px 10px; border-style: solid; border-color: #fff transparent transparent transparent; transform: rotate(-45deg); &#125; &#125;&#125; 画这个logo最难的地方应该就是实现四个小圆的时候，因为CSS3不太熟的人可能不会想到利用box-shadow去实现。 大家还有其它的方法实现微信logo吗？有没有一个标签就能实现的？欢迎留下你的实现方式。","tags":[{"name":"CSS3","slug":"CSS3","permalink":"http://yutaiwei.github.io/tags/CSS3/"},{"name":"微信Logo","slug":"微信Logo","permalink":"http://yutaiwei.github.io/tags/微信Logo/"}]},{"title":"HTML5和CSS3学习资料","date":"2016-06-29T12:57:14.000Z","path":"2016/06/29/HTML5和CSS3学习资料/","text":".jpg) 跟KingDZ学HTML5之四 继续探究Canvas之路径http://www.cnblogs.com/hihell/archive/2011/08/23/2150413.html SVG 多边形http://www.runoob.com/svg/svg-polygon.html 理解SVG的图形填充规则http://blog.csdn.net/cuixiping/article/details/7848369 地理定位（navigator.geolocation）http://blog.csdn.net/smok56888/article/details/20628161 HTML5 地理位置定位（HTML5 Geolocation）原理及应用http://www.cnblogs.com/lhb25/archive/2012/07/10/html5-geolocation-api-demo.html HTML5 Web Worker的使用http://www.cnblogs.com/feng_013/archive/2011/09/20/2175007.html HTML 参考手册http://www.w3school.com.cn/tags/index.asp HTML5 测验http://www.w3school.com.cn/quiz/quiz.asp?quiz=html5 CSS3 border-image详解、应用及jQuery插件 利用css3-animation来制作逐帧动画https://www.qianduan.net/css3-animation/ css3 box-sizing属性http://www.cnblogs.com/zhaoran/archive/2013/05/24/3097482.html Selectors Level 3https://www.w3.org/TR/css3-selectors/ HTML5 Trickshttp://www.html5tricks.com/","tags":[{"name":"前端","slug":"前端","permalink":"http://yutaiwei.github.io/tags/前端/"},{"name":"艾佳生活","slug":"艾佳生活","permalink":"http://yutaiwei.github.io/tags/艾佳生活/"}]},{"title":"CSS实现文本溢出显示省略号","date":"2016-06-25T13:43:53.000Z","path":"2016/06/25/CSS实现文本溢出显示省略号/","text":".jpg) 单行文本溢出显示省略号1234width: 300px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; 如果字符串长度超过300px，那么超出部分就变成...。 多行文本溢出显示省略号1234display: -webkit-box;-webkit-box-orient: vertical;-webkit-line-clamp: 3;overflow: hidden; 因为使用了WebKit的CSS扩展属性，该方法适用于WebKit浏览器及移动端； -webkit-line-clamp用来限制在一个块元素显示的文本的行数。为了实现该效果，它需要组合其他的WebKit属性。常见结合属性：display: -webkit-box; 必须结合的属性 ，将对象作为弹性伸缩盒子模型显示 。-webkit-box-orient 必须结合的属性 ，设置或检索伸缩盒对象的子元素的排列方式 。 怎样在js中判断文本是否溢出问题描述：一段文字限定行数，使用css把多余文字显示为省略号，请问怎么通过js判断这段文字是否有文字显示为省略号？ 思路一王晨帅哥提供了一个思路：取消css的-webkit-line-clamp属性，看看元素高度是否发生了变化，变化了就是有文字显示为省略号。 好想法，最后小编改进后如下：这段文字在页面上放两份，一份限定行数，正常显示；另一份不限定行数，隐藏起来。然后，对比这两段文字的高度是否相同。具体实现：1234567891011121314151617181920212223242526272829// scss部分.info&#123; font-size: 1.2rem; margin-top: .6rem; display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: 4; overflow: hidden; p&#123; &amp;:not(:first-child)&#123; margin-top: .4rem; &#125;; line-height: 1.8rem; &#125;&#125;.info-hidden&#123; position: fixed; z-index: -10; visibility: hidden; font-size: 1.2rem; margin-top: .6rem; p&#123; &amp;:not(:first-child)&#123; margin-top: .4rem; &#125;; line-height: 1.8rem; &#125;&#125; 123456// js部分var $info = $('.info');var $info_hidden = $('.info-hidden');if($info.height() === $info_hidden.height())&#123; $('.more').hide();&#125; 思路二后来张伟林帅哥提供了一个更好的思路：既然已经知道了限定的行数，那么判断一个高度就可以了。结合line-height，高度用scrollheight，判断scrollheight &gt; line-height*你决定的行数。 小编马上搜索了一个scrollheight，发现，原来scrollHeight可以返回元素的完整高度。那么，比较一下scrollHeight和height不就可以了么？具体实现：1234567// js部分var $info = $('.info');console.log($info.height());console.log($info[0].scrollHeight);if($info.height() &gt;= $info[0].scrollHeight)&#123; $('.more').hide();&#125; 后记利用js也可以实现文本溢出显示省略号，可以参考书签中的dotdotdot，很形象的名字。。。 书签CSS实现单行、多行文本溢出显示省略号（…）http://www.daqianduan.com/6179.html jQuery.dotdotdothttp://www.bootcdn.cn/jQuery.dotdotdot/","tags":[{"name":"前端","slug":"前端","permalink":"http://yutaiwei.github.io/tags/前端/"},{"name":"css","slug":"css","permalink":"http://yutaiwei.github.io/tags/css/"}]},{"title":"JavaScript书签","date":"2016-06-25T13:16:19.000Z","path":"2016/06/25/JavaScript书签/","text":".jpg) 回调函数（callback）是什么？http://www.zhihu.com/question/19801131 读取JAVASCRIPT第一公民-函数http://www.cnblogs.com/YOUCAN/archive/2012/11/05/2754968.html 《JAVASCRIPT语言精髓与编程实践》，周爱民http://www.chnxp.com.cn/soft/2013-12/22670.html 无废话JavaScripthttp://blog.csdn.net/aimingoo/article/details/3022379 深入理解javascript原型和闭包http://www.cnblogs.com/wangfupeng1988/p/3977987.html JS的事件监听机制http://www.cnblogs.com/aji88/archive/2012/07/20/2600492.html js事件监听器用法实例详解http://www.jb51.net/article/67051.htm HTML 最佳实践http://www.imooc.com/article/3666 Node.JS编码规范指南教程：教你优雅地写JavaScript代码 前端JavaScript规范http://www.imooc.com/article/1402 为JavaScript程序员准备的10本免费书籍http://www.imooc.com/article/1767","tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yutaiwei.github.io/tags/Javascript/"},{"name":"书签","slug":"书签","permalink":"http://yutaiwei.github.io/tags/书签/"}]},{"title":"CSS3之初体验01","date":"2016-06-21T14:39:19.000Z","path":"2016/06/21/CSS3之初体验/","text":".jpg) 自CSS3流行以来，虽然以前看过一遍所有的新增属性，但其实在实际项目中用到的少之又少。所以没有形成系统性的认识，以及看到效果立马就能想到解决方案的能力。然后最近正好遇到一个需要绘制大量动画的需求，所以决定趁此机会好好研究一下这个既熟悉又陌生的css3。 在正式开始css3之前，先来介绍一些比较经典的css3实例，让大家好好感受一下css3的魅力，本文会提到以下几个css3的属性： border-radius、::after、attr和content、box-sizing、linear-gradient、radial-gradient、box-shadow border-radius 相信这个属性，写过css的同学都知道，用来产生圆角，比如画一个圆形： 123456div &#123; width:100px; height:100px; background:red; border-radius:100px; //border-radius:100%;&#125; 然后我们来看看它的语法：border-radius: [左上] [右上] [右下] [左下]，于是我们来画一个半圆 123456div &#123; width: 100px; height: 50px; background: red; border-radius: 50px 50px 0 0;&#125; 那如果要画一个椭圆该怎么办呢？你会发现上面的语法貌似做不到了，其实border-radius的值还有一种语法: x半径/y半径： 123456div &#123; width: 100px; height: 50px; background: red; border-radius: 50px/25px;&#125; 如果我要画半个椭圆，又要咋办呢？ 123456div &#123; width: 100px; height: 50px; background: red; border-radius: 100% 0 0 100% /50%;&#125; ::after这里拿个简单的例子来看，我们要画一个放大镜，如下图： 分析一下，这个放大镜可以由两个div组成，一个是黑色的圆环，一个是黑色把手（旋转45度）。所以我们就需要用两个div来实现吗？答案是NO，一个div也是可以的，我们可以借助::after来添加一个元素。同理如果需要三个div，我们还可以使用::before再添加一个元素。下面看一下代码： 12345678910111213141516171819div &#123; width: 50px; height: 50px; border-radius: 50%; border: 5px solid #333; position: relative;&#125;div::after &#123; content: ''; display: block; width: 8px; height: 60px; border-radius: 5px; background: #333; position: absolute; right: -22px; top: 38px; transform: rotate(-45deg);&#125; attr和content比如我们要实现一个悬浮提示的功能。传统方法，使用title属性就能实现，但是现在我们要更美观，可以使用css3提供的attr：能够在css中获取到元素的某个属性值，然后插入到伪元素的content中去。 假如我们的html代码如下： 1&lt;div data-title=\"hello, world\"&gt;hello...&lt;/div&gt; 我们来看看实现这个插件的css代码： 12345678910111213div &#123; position: relative;&#125;div:hover::after &#123; content: attr(data-title); //取到data-title属性的值 display: inline-block; padding: 10px 14px; border: 1px solid #ddd; border-radius: 5px; position: absolute; top: -50px; left: -30px;&#125; 当hover的时候，在元素尾部添加一个内容为data-title属性值的元素，所以就实现了hover显示的效果，如下图所示： box-sizing我们知道，在标准盒子模型中，元素的总宽＝content + padding + border + margin。 css中的盒子模型大家可能都知道，但是这个盒子模型的属性可能没有那么多人知道，box-sizing属性就是用来重定义这个计算方式的，它有三个取值，分别是：content-box（默认）、border-box、padding-box 一般来说，假如我们需要有一个占宽200px、padding10px、border5px的div，经过计算，要这么定义样式。 123456div &#123; width: 170px; //这里的宽度要使用200-10*2-5*2 = 170得到。 height: 50px; padding: 10px; border: 5px solid red;&#125; 然后我们来使用一下box-sizing属性。 1234567div &#123; box-sizing: border-box; width: 200px; //这里的宽度就是元素所占总宽度，不需要计算 height: 50px; padding: 10px; border: 5px solid red;&#125; linear-gradient做活动页面的时候我们经常会遇到这样的需求： 顶部的中间一张大banner图片，然后整个区域的背景色要根据图片背景色渐变。就可以使用这个属性了。 12345div &#123; width: 200px; height: 50px; background: linear-gradient(to right, red, yellow, black, green);&#125; 是不是很有趣？其实，linear-gradient还有更多有趣的功能，你可以根据下面的动图去感受一下： 你以为这就完了？等等，还有更强大的呢！repeating-linear-gradient，来感受一下： linear-gradient还有更加强大的功能，比如它可以给元素添加多个渐变，从而达到更NB的效果。 radial-gradient上面的linear-gradient是线性渐变，这个属性是径向渐变。下面的代码实现了一个chrome的logo。 1234567891011121314151617div.chrome &#123; width: 180px; height: 180px; border-radius: 50%; box-shadow: 0 0 4px #999, 0 0 2px #ddd inset; background: radial-gradient(circle, #4FACF5 0, #2196F3 28%, transparent 28%), radial-gradient(circle, #fff 33%, transparent 33%), linear-gradient(-50deg, #FFEB3B 34%, transparent 34%), linear-gradient(60deg, #4CAF50 33%, transparent 33%), linear-gradient(180deg, #FF756B 0, #F44336 30%, transparent 30%), linear-gradient(-120deg, #FFEB3B 40%, transparent 40%), linear-gradient(-60deg, #FFEB3B 30%, transparent 30%), linear-gradient(0deg, #4CAF50 45%, transparent 45%), linear-gradient(60deg, #4CAF50 30%, transparent 30%), linear-gradient(120deg, #F44336 50%, transparent 50%), linear-gradient(180deg, #F44336 30%, transparent 30%);&#125; 实现原理就是使用了多个渐变色放在div上，友协被遮住，视觉上就产生了想要的效果，是不是很强大！看了下图你就知道其实就是在div上加了很多个渐变。 box-shadow上面的例子大都是对css3新属性的了解和认识，这个实例则是有关于解决方案的例子。 需求：我们要实现下面这个效果图（三个边框：黑色，绿色，红色）： 解法一：假如没有css3知识，我们可以做这样做：用三个div，分别设置边框，然后分别控制宽高和位置来达到这个效果。显然，很复杂，这里就不贴代码了。 解法二：现在我们有css3的知识了，借助box-shadow就可以轻松解决这个问题。先来看看它的语法：box-shadow: [x偏移] [y偏移] [阴影模糊宽度] [阴影宽度] [颜色]，并且还能添加多个阴影，使用逗号隔开。 当然你还可以继续增加，四重边框，五重边框……都不再是问题啦。另外，还能加圆角，阴影会贴紧内层div。 使用这种方法，有一个缺点就是，不支持虚线边框。 解法三： 使用outline（只能支持两重边框） 使用这种方法的缺点就是，只能支持两层的边框，而且还不能根据容器的border-radius自动贴合。 总结通过这段时间对css3的深入了解，发现css3真的很强大，研究起来还是挺有趣的，只有想不到，感觉没有做不到。不过为了实现很酷炫的效果，可能需要编写大量的css代码，这个时候使用什么技术就需要我们自己来衡量了。","tags":[{"name":"CSS3","slug":"CSS3","permalink":"http://yutaiwei.github.io/tags/CSS3/"},{"name":"实例","slug":"实例","permalink":"http://yutaiwei.github.io/tags/实例/"}]},{"title":"css雪碧图","date":"2016-06-20T04:58:00.000Z","path":"2016/06/20/css雪碧图/","text":".jpg) 前言CSS雪碧 即CSS Sprite，也有人叫它CSS精灵，是一种CSS图像合并技术，该方法是将小图标合并到一张图片上，然后利用css的背景定位来显示需要显示的图片部分。优点：减少加载网页图片时对服务器的请求次数，提高页面的加载速度，减少鼠标滑过的一些bug。 制作雪碧图的制作，可以使用PS，也可以使用专门的雪碧图制作工具。制作时，最好制作成一列或者一行，定位时会方便一些。下面这个工具挺好用，分享给大家：https://yunpan.cn/cMKygj2hnrBBe 访问密码 f516 css雪碧图简单制作工具（源码）https://github.com/iwangx/sprite 如果要制作svg雪碧图，推荐使用AI。 定位位置雪碧图定位的关键，在于background-position。诀窍在于“调试”，在页面控制背景图上下左右移动，很快就定位好了。 以上面的雪碧图为例，假设我们要显示微博的图标，那么scss代码如下： 123456.icon-weibo&#123; width: 20px; height: 20px; background: url(../../img/test/index/icon.png) no-repeat; background-position: 0px -60px;&#125; 大小假设我们的要显示的图标比雪碧图大，或者比雪碧图小，该怎么办？background-size。 1234567.icon-weibo&#123; width: 40px; height: 40px; background: url(../../img/test/index/icon.png) no-repeat; background-position: -2px -116px; background-size: 118%;&#125; 移动端很多时候，我们并不使用px作为单位，而是rem或者百分比，这时候，该怎么控制雪碧图的位置和大小？利用svg图片。 1&lt;span class=\"i i_menu_0\"&gt;&lt;/span&gt; 123456789101112.i &#123; width: 0.8rem; height: 0.8rem; background: url(../images/ico_global.svg) no-repeat; display: inline-block; background-size: 1100%;&#125;.i_menu_0 &#123; background-position: 0% 0%; &#125;.i_menu_1 &#123; background-position: 10% 0%; &#125;.i_menu_2 &#123; background-position: 20% 0%; &#125;.i_menu_3 &#123; background-position: 30% 0%; &#125;.i_menu_4 &#123; background-position: 40% 0%; &#125;.i_menu_5 &#123; background-position: 50% 0%; &#125; 后记至于PS和AI的使用，在慕课网和网易云课堂上有很多优秀教程，不要错过。 书签CSS雪碧图的实现方法（即背景定位）http://www.suixin8.com/59.html CSS3技术-雪碧图自适应缩放http://www.imooc.com/wiki/detail/id/183 利用动态viewport+rem制作一张自适应的svg雪碧图iconhttp://www.open-open.com/lib/view/open1452229325136.html SVG的用法http://www.webhek.com/svg/","tags":[{"name":"前端","slug":"前端","permalink":"http://yutaiwei.github.io/tags/前端/"},{"name":"css","slug":"css","permalink":"http://yutaiwei.github.io/tags/css/"},{"name":"sprite","slug":"sprite","permalink":"http://yutaiwei.github.io/tags/sprite/"}]},{"title":"css阴影效果","date":"2016-06-20T02:50:25.000Z","path":"2016/06/20/css阴影效果/","text":".jpg) 有阴影的图，看上去高大上些？不管怎样，UI设计了阴影，咱就照做好了。语法：1box-shadow: h-shadow v-shadow blur spread color inset; 解释： 值 描述 h-shadow 必需。水平阴影的位置。允许负值。 v-shadow 必需。垂直阴影的位置。允许负值。 blur 可选。模糊距离。 spread 可选。阴影的尺寸。 color 可选。阴影的颜色。请参阅 CSS 颜色值。 inset 可选。将外部阴影 (outset) 改为内部阴影。 常见用法：123div&#123; box-shadow: 10px 10px 5px #0cc;&#125; 四个值分别是水平阴影位置、垂直阴影位置、模糊距离、颜色。 实际案例：123&lt;a href=\"\" class=\"confirm\"&gt; &lt;span&gt;马上去抢2G流量&lt;/span&gt;&lt;/a&gt; 12345678910111213141516.confirm&#123; display: inline-block; box-shadow: 0 .5rem 1.5rem #0cc; border-radius: 5px; margin-top: 12%; width: 98%; height: 17%; background: url(../../img/flowrate/blue.jpg) no-repeat; background-size: 100% 100%; color: #fff; span&#123; display: inline-block; margin-top: 3%; font-size: 1.5rem; &#125;&#125; 最终效果如下：","tags":[{"name":"前端","slug":"前端","permalink":"http://yutaiwei.github.io/tags/前端/"},{"name":"css","slug":"css","permalink":"http://yutaiwei.github.io/tags/css/"}]},{"title":"人生三乐","date":"2016-06-15T13:07:04.000Z","path":"2016/06/15/人生三乐/","text":".jpg) 作者：李银河 恋爱、读书、写作是人生三乐。恋爱时，人沉浸在激情之中，快乐感觉无以复加；读书时，人徜徉在智慧之中，心旷神怡；写作时，人寻寻觅觅，仿佛在寻宝的过程中，一旦有所收获，心花怒放，心情愉悦无与伦比。恋爱的机会可遇不可求。世界上好人很多，可不一定是你能对他产生激情的。人的情感、性情、经历、想法五花八门，不一定能够正好与你相遇，相知，相爱。所以一旦对某人产生激情之爱，务必珍惜，精心呵护，浸淫其中，最好能够保持终身。这当然是很不容易的事情，有太多偶然因素。但是万一有此幸运，快乐真是无与伦比。读书倒是可以完全随心所欲，只要有欲望，有时间，就可以在书林书海中尽情徜徉，沉入其中，乐不思蜀。虽然绝大多数的书都不值一读，但是真正的好书也足够人享用的了，尤其像我这样读书速度比较慢的（诵读速度），一本好书别人可以享用一天，我可以细细品尝三天。此生不必担忧把好书读尽，就像走进海盗的藏宝洞，满眼珍宝，享用不尽，快乐真是无与伦比。 写作则像探险，你不知道自己会写出什么，仿佛陷入一个迷宫，或者一个漆黑的洞穴，深一脚浅一脚，有时看到前面有一丝亮光，以为找到出路，一路发足狂奔，结果并没有走出去，心情不免沮丧。但是有时山重水尽疑无路，柳暗花明又一村，心中豁然开朗。看着自己的思绪像涓涓的流水，从内心的泉眼中汨汨涌出，晶莹剔透，绵绵不绝，那愉悦的感觉也是无与伦比。 无论生命还有多长时间，惟愿沉浸在恋爱、读书和写作之中。","tags":[{"name":"读者","slug":"读者","permalink":"http://yutaiwei.github.io/tags/读者/"},{"name":"李银河","slug":"李银河","permalink":"http://yutaiwei.github.io/tags/李银河/"}]},{"title":"js中数组对象排序","date":"2016-06-14T10:59:56.000Z","path":"2016/06/14/js中数组对象排序/","text":".jpg) 普通数组排序 js中用方法sort()为数组排序。sort()方法有一个可选参数，是用来确定元素顺序的函数。如果这个参数被省略，那么数组中的元素将按照ASCII字符顺序进行排序。如：123var arr = [\"a\", \"b\", \"A\", \"B\"];arr.sort();console.log(arr);//[\"A\", \"B\", \"a\", \"b\"] 因为字母A、B的ASCII值分别为65、66，而a、b的值分别为97、98，所以上面输出的结果是[&quot;A&quot;, &quot;B&quot;, &quot;a&quot;, &quot;b&quot;]。 如果数组元素是数字呢，结果会是怎样？ 123var arr = [15, 8, 25, 3];arr.sort();console.log(arr);//[15, 25, 3, 8] 结果是[15, 25, 3, 8]。其实，sort方法会调用每个数组项的toString()方法，得到字符串，然后再对得到的字符串进行排序。虽然数值15比3大，但在进行字符串比较时”15”则排在”3”前面。显然，这种结果不是我们想要的，这时，sort()方法的参数就起到了作用，我们把这个参数叫做比较函数。 比较函数接收两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等则返回0，如果第一个参数应该位于第二个之后则返回一个正数。例子： 1234567891011var arr = [23, 9, 4, 78, 3];var compare = function (x, y) &#123;//比较函数 if (x &lt; y) &#123; return -1; &#125; else if (x &gt; y) &#123; return 1; &#125; else &#123; return 0; &#125;&#125;console.log(arr.sort(compare)); 结果为[3, 4, 9, 23, 78]，返回了我们想要的结果。如果要按降序排序，比较函数写成这样即可： 123456789var compare = function (x, y) &#123; if (x &lt; y) &#123; return 1; &#125; else if (x &gt; y) &#123; return -1; &#125; else &#123; return 0; &#125;&#125; 我们并不能用比较函数比较一个不能转化为数字的字符串与数字的顺序： 12var arr = [\"b\", 5];console.log(arr.sort(compare)) 结果是[&quot;b&quot;, 5]。因为比较函数在比较时，会把先把字符串转化为数字，然后再比较，字符串b不能转化为数字，所以就不能比较大小。然而，当不用比较函数时，会比较ASCII值，所以结果是[5, &quot;b&quot;]。 数组对象排序如果数组项是对象，我们需要根据数组项的某个属性对数组进行排序，要怎么办呢？其实和前面的比较函数也差不多： 12345678910111213var arr = [&#123;name: \"zlw\", age: 24&#125;, &#123;name: \"wlz\", age: 25&#125;];var compare = function (obj1, obj2) &#123; var val1 = obj1.name; var val2 = obj2.name; if (val1 &lt; val2) &#123; return -1; &#125; else if (val1 &gt; val2) &#123; return 1; &#125; else &#123; return 0; &#125;&#125;console.log(arr.sort(compare)); 输出结果为[Object { name=&quot;wlz&quot;, age=25}, Object { name=&quot;zlw&quot;, age=24}]，可以看到数组已经按照name属性进行了排序。我们可以对上面的比较函数再改造一下： 123456789101112var compare = function (prop) &#123; return function (obj1, obj2) &#123; var val1 = obj1[prop]; var val2 = obj2[prop];if (val1 &lt; val2) &#123; return -1; &#125; else if (val1 &gt; val2) &#123; return 1; &#125; else &#123; return 0; &#125; &#125;&#125; 如果想按照age进行排序，arr.sort(compare(&quot;age&quot;))即可。 但是对age属性进行排序时需要注意了，如果age属性的值是数字，那么排序结果会是我们想要的。但很多时候我们从服务器传回来的数据中，属性值通常是字符串。现在我把上面的数组改为： 1var arr = [&#123;name: \"zlw\", age: \"24\"&#125;, &#123;name: \"wlz\", age: \"5\"&#125;]; 可以看到，我把age属性由数字改为了字符串，第二个数组项的age值改为了&quot;5&quot;。再次调用arr.sort(compare(&quot;age&quot;))后，结果为： 1[Object &#123; name=\"zlw\", age=\"24\"&#125;, Object &#123; name=\"wlz\", age=\"5\"&#125;] 我们的期望是5排在25前面，但是结果不是。这是因为当两个数字字符串比较大小时，会比较它们的ASCII值大小，比较规则是：从第一个字符开始，顺次向后直到出现不同的字符为止，然后以第一个不同的字符的ASCII值确定大小。所以”24”与”5”比较大小时，先比较”2“与”5”的ASCII值，显然”2“的ASCII值比”5”小，即确定排序顺序。 现在，我们需要对比较函数再做一些修改： 1234567891011121314151617var compare = function (prop) &#123; return function (obj1, obj2) &#123; var val1 = obj1[prop]; var val2 = obj2[prop]; if (!isNaN(Number(val1)) &amp;&amp; !isNaN(Number(val2))) &#123; val1 = Number(val1); val2 = Number(val2); &#125; if (val1 &lt; val2) &#123; return -1; &#125; else if (val1 &gt; val2) &#123; return 1; &#125; else &#123; return 0; &#125; &#125;&#125; 在比较函数中，先把比较属性值转化为数字Number(val1)再通过!isNaN(Number(val1))判断转化后的值是不是数字(有可能是NaN)，转化后的值如果是数字，则比较转换后的值，这样就可以得到我们想要的结果了， 调用arr.sort(compare(&quot;age&quot;))得到： 1[Object &#123; name=\"wlz\", age=\"5\"&#125;, Object &#123; name=\"zlw\", age=\"24\"&#125;] 可以看到，确实是按正确的方式排序了。 这篇文章所讲的都是基础的，没什么技术含量，只是最近项目中遇到了对数组对象进行排序的问题，所以在这里写出来分享一下，相信总能帮到一些朋友。","tags":[{"name":"js数组排序","slug":"js数组排序","permalink":"http://yutaiwei.github.io/tags/js数组排序/"},{"name":"sort","slug":"sort","permalink":"http://yutaiwei.github.io/tags/sort/"}]},{"title":"css中常用的重置代码","date":"2016-06-14T00:00:00.000Z","path":"2016/06/14/css中常用的重置代码/","text":".jpg ) 在制作页面时，经常会遇到需要自定义一些标签的默认行为(如：input的占位符等)，但这些默认的设置的css一般比较难记住,所以有必要自己做一下记录。下面是我经常用到的一些重设默认行为的css。 1、占位符在&lt;input&gt;标签中设置placeholder属性时，有时候因为需求，要修改占位符的默认颜色或者字体大小，这是就可以用下面的css: // firefox input::-moz-placeholder { color: red; font-size: 18px; } // IE input:-ms-input-placeholder { color: red; font-size: 18px; } // chrome input::-webkit-input-placeholder { color: red; font-size: 18px; } 需要注意的是不同浏览器写法不同： 都要加上各自浏览器的前缀(如-webkit-)； firefox的placeholder的前面没有input-； firefox与chrome都是::两个冒号，而IE则是一个:; 低版本的浏览器与新版本浏览器可能写法不同； ###2、下拉框的小三角### select标签会出现小三角,通常这个小三角我都会去掉，或者用背景图片的方式替换为符合要求的样子。去掉小三角的css： -webkit-appearance: none; -moz-appearance: none; 在IE浏览器中目前还没找到可以去掉小三角的方法。 ###3、input[type=number]右边的spinners### nput[type=number]通常用在移动端设备上，浏览器会识别number输入类型，然后改变数字键盘来适应它。但是它会出现spinners，一般不需要它。去掉spinners的css如下： // firefox input[type=&apos;number&apos;] { -moz-appearance:textfield; } // chrome input[type=number]::-webkit-inner-spin-button, input[type=number]::-webkit-outer-spin-button { -webkit-appearance: none; margin: 0; } ###4、-webkit-tap-highlight-color### 在移动端浏览器上(如是微信、QQ内置浏览器)，当你点击一个链接或者通过Javascript定义的可点击元素的时候，会出现蓝色边框，我是很讨厌这个边框的，所以一般我会去除： -webkit-tap-highlight-color: rgba(255, 255, 255, 0); 将高亮色设为透明，这样就看不到蓝色边框了。 ###5、滚动条### webkit现在支持拥有overflow属性的区域，列表框，下拉菜单，textarea的滚动条自定义样式。有时候需要把滚动条去掉，特别是页面中出现几条滚动条的时候： ::-webkit-scrollbar { width: 0; } 设置滚动条的宽度为0就可以去除滚动条了。如果需要自定义滚动条样式可以点击http://www.xuanfengge.com/css3-webkit-scrollbar.html，里面介绍了如何自定义滚动条样式。 上面记录了我在项目中常用的比较不容易记忆的css代码。如果朋友们也有比较常用的不太容易记住的css代码，欢迎帮忙补充。","tags":[{"name":"placeholder","slug":"placeholder","permalink":"http://yutaiwei.github.io/tags/placeholder/"},{"name":"小三角","slug":"小三角","permalink":"http://yutaiwei.github.io/tags/小三角/"},{"name":"spinners","slug":"spinners","permalink":"http://yutaiwei.github.io/tags/spinners/"},{"name":"滚动条","slug":"滚动条","permalink":"http://yutaiwei.github.io/tags/滚动条/"}]},{"title":"关于程序员的经典语录","date":"2016-06-11T10:41:14.000Z","path":"2016/06/11/关于程序员的经典语录/","text":".jpg) 原文来自：http://geek.csdn.net/news/detail/11487 关于程序员的经典语录A：借我1000块。B：拿去，1024，我给你凑了个整儿。 Programming is like sex: one mistake and you’re providing support for a lifetime. –Michael Sinz编程就像做爱，你得为一个错误提供一辈子的支持。 程序员对测试人员说：＂在我机器上没问题啊！＂ ＂我测试了一下，确实在我机器上没问题啊＂ 少壮不努力，老大写程序。 世界上只有两句真理： 人一定会死。 程序一定有 Bug. 如果你想动手开发什么全新技术，你不需要几百万美元的资金，你只需要在冰箱里面放满比萨和可乐，再有一台便宜的计算机，和为之献身的决心。——卡马克 做网站就像zuoai，首先你要懂得“How To Make Love”，简称HTML；如果觉得你对HTML已经精通了，你应该学学3P（ASP，PHP，JSP) 。。。 嫁人就嫁程序员，钱多话少死得早。","tags":[{"name":"语录","slug":"语录","permalink":"http://yutaiwei.github.io/tags/语录/"},{"name":"程序员","slug":"程序员","permalink":"http://yutaiwei.github.io/tags/程序员/"}]},{"title":"你要学习","date":"2016-06-09T01:50:15.000Z","path":"2016/06/09/你要学习/","text":".jpg) 本文原作者不详，yutaiwei整理。 你要是天天一大早六点起床，吃顿好饭，奔去教室背两篇新三，八点坐直在教室的前排，使劲不分心地听完两节还是四节课，课间练字背单词看报纸，放学奔去食堂抢份好饭，吃完回宿舍，洗洗衣服拖拖地消化下…再听VOA，一倍速听完听1.5，1.5听完听2倍，听困了上床歇中觉，下午继续坐直在前排听完四节课，放学去食堂抢个馒头奔回寝室啃完，收拾好书包就去教室上自习，拼到十点半赶在关门前回宿舍，洗漱完了继续听VOA听新三，听累了看书，看累了上床睡觉。周六带一天干粮去泡死在图书馆，周日半天上街采购，半天整内务看闲书，晚上继续滚教室自习，想考北大清华耶鲁牛津的，周日就别放假，你还有个鬼空去迷茫，去忧伤啊！ 你要是想到以后吃不起肉，旅不起游，看不起最新大片，连买份三块钱的南方周末都要犹豫挣扎下，你还敢迷茫敢忧伤啊！你当你是少年维特啊，维特的烦恼之所以迷人，那是人家名字前还有少年两个字。你要是混到中年，住不起房，开不起车，泡不起妞，天天对着现实哼哼唧唧，鬼会去聆听你那”凄美感伤”的烦恼。你说说你都这么把年纪了，还玩什么淡淡的忧伤，深深的迷茫啊，再不拼命，毕业就要去要饭了，就算天上掉个馅饼，你还要比别人先发现张嘴去接着提前准备呢。你迷茫个鬼忧伤个死啊，看人家谈恋爱你羡慕什么，还怕以后找不到老婆吗，看人家拿offer满世界跑你眼红什么，没看到人家怎么呕心沥血苦尽甘来么。还不滚去啃书拼命去，上个P网，偷个P闲！ 寂寞。一个人早起晚睡不难，但在一群晚起早睡的人中早起晚睡不简单。没人陪你占座，没人陪你背书，没人陪你写作。学习就是孤独的。没人经常短信你，没人经常鼓励你，没人一直关注你。不管是打雷下雨下雹子还是刀子，都要早起前行去学习，你的伙伴会贪睡不去，但不可以是你。你的同桌室友饭友学友各种友都可以中途打断他们的计划，你不可以！你要学习。你一个人背着书包跑来跑去，你以为很傻很土很幼稚吗？别人笑，是羡慕，你笑，是自信。 欲望。想睡懒觉，想看电影，想吃大餐。但是他们都是花时间的事，占用学习时间的事。可以放假，可以休息。 可要是每天多睡2小时，一年就多睡掉30.4天，一个月没了。每天看两集电视，又是一个月没了。食堂，寝室，教室，你就只能去这三个地方。厕所你都要算好时间再去。 享乐。他去看演唱会了，他去唱K了，他们去开房了。都和我无关，因为我要学习。他们打游戏，他们蜜月旅游，都和我无关，因为我要学习。 你好意思一把年纪了还吃爸妈的么。你有touch nano shuffle iPhone macbook，是你挣的么?你穿Burberry喷Dior拎Prada，你儿子用什么?你爸给你买房买车，你付得起物管，付得起年检么？你穿什么，用什么，开什么，住什么，什么都不算。你读什么，看什么，想什么，做什么，什么都重要。 教室前排的帅哥在你来之前就在那GRE，你走了，他还在GRE。他GRE他GRE他GRE，你连六级的分都刷不高。 你智商不高，情商不高，各种商不高；你背景不够，资本不够，各种不够；你还不学习？ 你高中傻乎乎的把自己家的全套钥匙送给女朋友，你以为很浪漫很抒情很温柔很韩剧？你不学习，你连一个钥匙串都买不起。 你追求加内特詹姆斯科比麦蒂邓肯霍华德……你不学习，连一张季前赛门票都买不起。 你想去荷兰，想去普林斯顿，想去各种地方。你不学习，你就继续想吧。 别人花言巧语追女朋友，别人周末上街大包小包，别人假期飞来飞去。都不关我事，我要学习。 别人逃课，兼职，游戏，都不关我的事，我要学习。 你说我没智商，没背景，没资本。没关系，我要学习。 你说我固执，老套，OUT。没关系，我要学习。 所以，学习就是一件要耐的住寂寞放的下欲望舍的得享乐的事。你好意思那么懒那么不守时那么吃那么玩那么啰哩叭嗦不看书么！你好意思穿着各种签名在校园里面游荡，你好意思整天淘宝京东？ 你要学习，你要学习，你要学习！","tags":[{"name":"学习","slug":"学习","permalink":"http://yutaiwei.github.io/tags/学习/"},{"name":"励志","slug":"励志","permalink":"http://yutaiwei.github.io/tags/励志/"}]}]