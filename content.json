[{"title":"Express入门","date":"2017-07-13T14:09:59.000Z","path":"2017/07/13/Express入门/","text":"Express是node的后台快速开发框架创建http服务12345678910111213141516171819let http = require('http');let fs = require('fs');let url = require('url');http.createServer(function (req,res) &#123; var urlObj = url.parse(req.url,true); var pathname = urlObj.pathname; if (pathname == '/')&#123; res.end('首页') &#125; else if(pathname == '/user')&#123; res.end('用户') &#125; else &#123; res.statusCode = 404; res.end('Not Found') &#125;&#125;).listen(3000,function () &#123; console.log('3000端口成功监听')&#125;); 也可以写成12345let express = require('express');let app = express();app.listen(8080,function()&#123; console.log('8080端口已经成功启动，服务器监听正常')&#125;) express 是一个node模块12- npm install express//安装express方法 注意文件夹名字不能与module模块名字相同 1234567891011121314151617let express = require('express');let app = express();app.get('/',function (req,res) &#123; res.end('首页');&#125;);app.get('user',function (req,res) &#123; res.end('用户');&#125;);app.get('*',function (req,res) &#123; res.end('页面未找到'); //*代表所有路径&#125;);//get方法对应http的方法名 /对应于根路径express.listen(9090,function () &#123; console.log('9090监听成功')&#125;); 中间件 中间件的含义： 是一个函数,可以设置一些公共的逻辑，对所有的路由生效，next也是一个函数，调用它表示继续向下执行 中间件的作用：进行权限判断，添加一些公共的方法 1234app.use(function (req,res，next) &#123; res.setHeader('Content-Type','text/html,charset:utf-8'); next();&#125;); 路由中间件 是一个中间件，但是里面包含了路由规则，把路由进行分类，把不同的路由写在不同的模块里例如 12345678let express = require('express');let app = express();let user = require('./routes/user');let article = require('./routes/article');app.use('/user',user);app.use('/article',article);app.listen(9090);// 有请求到来的时候，先匹配路径前缀 如果匹配才交由后面的路由中间件来处理 ==使用cmd命令模拟发送post请求==1curl -v http://www.baidu.com node实现页面跳转(重定向) 返回到来时的页面 1res.redirect('back'); 跳到指定的页面 1234app.post('/signup',function(req,res)&#123; res.redirect('/signin'); //参数是一个URL地址，不是文件路径&#125;); express 中经常用到的模块汇总请求体解析模块——body-parser 可以将前台get方法传过来的路径内容，或者post方法传过来的参数直接解析 1234567891011npm install body-parser --savelet bodyParser = require('body-parser');app.use(bodyParser.urlencoded(&#123;extended:true&#125;));//extended:true 当extended为false的时候，键值对中的值就为'String'或'Array'形式，为true的时候，则可为任何数据类型。//请求体解析还有这种写法app.use(bodyParser.json());//urlencoded解析body中的urlencoded字符， 只支持utf-8的编码的字符,也支持自动的解析gzip和 zlib，.json这个方法返回一个仅仅用来解析json格式的中间件，能接受任何body中任何Unicode编码的字符。 ==一般请求中有json发送的时候就需要调用bodyParser.json的方法==以上内容写完之后，可以直接在如果是get方法传进来的参数可以用1res.qurey.xxx中获取到 如果是post方法传进来的参数可以用1res.body.xxx中获取到 1234567可以获取的请求内容console.log(req.method); console.log(req.url); console.log(req.path);// req.path = pathname console.log(req.query); console.log(req.headers); console.log(req.body); ==node还可以通过自带的req.params来获取请求url中的参数值== 路径解析模块——path 处理有关文件路径的内容 1let path = require('path'); 绝对路径：==path.resolve== 123456789path.resolve('foo/bar', '/tmp/file/', '..', 'a/../subfile');// 返回 /tmp/subfile// 此方法的参数类似于命令行中的cd命令eg:cd foo/barcd /tmp/file/cd ..cd a/../subfile// cd ..返回上一层 使用适合当前系统的链接符号，连接多个路径：==path-join== 12345console.log(path.join(__dirname,'path.js'));//参数只能是字符串eg：var str = path.join('./path/./', './upload', '/file', '123.jpg');console.log(str); // path/upload/file/123.jpg 路径整理：==path.normalize== 123var str = path.normalize('./path//upload/data/../file/./123.jpg');console.log(str); // path/upload/file/123.jpg//将杂乱的路径例如： path//upload/../file/./123.jpg整理为 path/upload/file/123.jpg正常路径 解析路径：==path.parse== 把一个路径解析为一个 {root:’’, dir:’’, base:’’, ext:’’, name:’’} 这样的对象。 123456789path.parse('/home/user/dir/file.txt')// returns&#123; root : \"/\", dir : \"/home/user/dir\", base : \"file.txt\", ext : \".txt\", name : \"file\"&#125; 更多path模块的使用方法参见：http://www.cnblogs.com/52cik/p/learn-node-path.html 在node环境中每个模块下，都可以通过1234__dirname// 获取当前文件所在的目录的绝对路径__filename//当前文件所在的绝对路径 express路由：Router 可以通过router配置路由 123456789101112131415let router = express.Router();eg:let express = require('express');//router也是一个容器，此容器下面可以配置路由let router = express.Router();router.get('/signup',function(req,res)&#123; res.end('注册');&#125;);router.get('/signin',function(req,res)&#123; res.end('登录');&#125;);router.get('/signout',function(req,res)&#123; res.end('退出');&#125;);module.exports = router; express控制cooike：cookie-parsercookie可以应用在很多场景，例如保存未登录账户的用户的购物车信息引入cookie-parser1let cookiePaser = require('cookie-parser'); 使用cookie-parser需要传入一个秘钥1app.use(cookieParser('mima')); 向客户端写cooike1res.cookie('name','zfpx') 读取客户端的cooike1req.cookies 通过domain来设置向哪个域名发送此次写入的cookie1res.cookie('path-name','zfpx',&#123;domain:'a.zfpx.cn'&#125;); path路径是指向哪个路径发请求的时候会发送此cookie1res.cookie('path-name','zfpx',&#123;path:'/read1'&#125;); 获取服务器时间12expires的参数是一个绝对的时间 2017年1月15日12:33:29res.cookie('expire-name','zfpx',&#123;expires:new Date(Date.now()+10*1000)&#125;); 设置cooike的生命周期12开始倒计时，到10秒后销毁此cookieres.cookie('maxAge-name','zfpx',&#123;maxAge:10*1000&#125;); eg：利用express实现一个访问量统计12345678910let express = require('express');let cookieParser = require('cookie-parser');let app = express();app.use(cookieParser());app.get('/visit',function(req,res)&#123; var visit = isNaN(req.cookies.visit)?1:parseInt(req.cookies.visit)+1; res.cookie('visit',visit); res.send(`欢迎您第$&#123;visit&#125;次访问`);&#125;);app.listen(3333); express的静态资源节点 static通过设置中间件的方式，将客户端发送来的静态资源请求找到设置的对应的文件路径，并将该路径下找到的同名文件返回给客户端。1234567eg:app.use(express.static(path.join(__dirname, 'public')));//解析public文件夹在服务器上的绝对路径，并将客户端发送的所有静态文件请求都从public上查找，并将找到的同名文件返回给客户端eg2:var resolve =file=&gt;path.resolve(__dirname, file);app.use('/dist',express.static(resolve('./dist')));//客户端访问时，带有/dist的路径的进行解析，并将/dist路径下的同名文件进行返回。","tags":[]},{"title":"jQuery 学习总结","date":"2017-05-14T14:01:59.000Z","path":"2017/05/14/jQuery 学习总结/","text":"选择器基本选择器当前 HTML 元素：$(this)按ID查找： $(&#39;#abc&#39;)按tag查找：$(&#39;p&#39;)按class查找： $(&#39;.red&#39;)按属性查找： $(&#39;[name=email]&#39;)组合查找：$(&#39;tr.red&#39;)多项选择器：$(&#39;p.red,p.green&#39;) 层级选择器层级选择器：$(&#39;ancestor descendant&#39;)子选择器：$(&#39;parent&gt;child&#39;)过滤器：一般不单独使用，附加在选择器上，:first-child，:last-child，nth-child(2)，nth-child(even)，nth-child(odd) 表单相关:input， :file，:checkbox，:radio，:focus，:checked，:enabled，:disabled 查找和过滤查找在某个节点的所有子节点中查找，使用find()方法，它本身又接收一个任意的选择器： var ul = $(‘ul.lang’); // 获得var dy = ul.find(‘.dy’); // 获得JavaScript, Python, Scheme 从当前节点开始向上查找，使用parent()对于位于同一层级的节点，可以通过next()和prev()方法。 过滤filter()方法可以过滤掉不符合选择器条件的节点： var langs = $(‘ul.lang li’); // 拿到JavaScript, Python, Swift, Scheme和Haskellvar a = langs.filter(‘.dy’); // 拿到JavaScript, Python, Scheme map()方法把一个jQuery对象包含的若干DOM节点转化为其他对象: var langs = $(‘ul.lang li’); // 拿到JavaScript, Python, Swiftvar arr = langs.map(function () { return this.innerHTML;}).get(); 用get()拿到包含string的Array：[‘JavaScript’, ‘Python’, ‘Swift’] 一个栗子将一个待提交的表单转换为JSON字符串 {&quot;name&quot;:&quot;Michael&quot;,&quot;email&quot;:...}： 1234567var items = $('#test-form input');var formData = &#123;&#125;;var arr = items.map(function()&#123; formData[this.name] = this.value&#125;).get();json = JSON.stringify(formData); 操作 dom修改Text和HTMLtext()和html()方法分别获取节点的文本和原始HTML文本。无参数调用时是获取文本，传入参数就变成设置文本。 12j1.html('&lt;span style=\"color: red\"&gt;JavaScript&lt;/span&gt;');j2.text('JavaScript &amp; ECMAScript'); 修改csscss()方法和addClass()方法可以修改DOM节点的style属性，并具有最高优先级。jQuery对象的所有方法都返回一个jQuery对象（可能是新的也可能是自身），因此可以进行链式调用。 123$('#test-css li.dy&gt;span').css('background-color', '#ffd351').css('color', 'red');div.addClass('highlight'); // 添加highlight这个class 获取DOM信息1234// 某个div的大小:var div = $('#test-div');div.width(); // 600div.height(); // 300 attr()和removeAttr()方法用于操作DOM节点的属性： 123div.attr('name'); // 'Test'div.attr('name', 'Hello'); // div的name属性变为'Hello'div.removeAttr('name'); // 删除name属性 还有prop()和is()方法： 1234var radio = $('#test-radio');radio.attr('checked'); // 'checked'radio.prop('checked'); // trueradio.is(':checked'); // true 操作表单val()可以统一处理各种输入框的取值和赋值的问题。 12var input = $('#test-input'), select = $('#test-select'); 修改dom结构append()把DOM添加到最后，prepend()则把DOM添加到最前。 同级节点可以用after()或者before()方法。 要删除DOM节点，拿到jQuery对象后直接调用remove()方法就可以了。 事件事件分类鼠标事件：click， dblclick， mouseenter， mouseleave， mousemove （鼠标在DOM内部移动时触发）， hover 键盘事件：keydown（键盘按下时触发） ， keyup（键盘松开时触发） ，keypress（按一次键后触发） 其他事件：focus，blur，change，submit，ready（当页面被载入并且DOM树完成初始化后触发） ready事件的使用： 12345$(document).ready(function () &#123; $('#testForm).submit(function () &#123; alert('submit!'); &#125;);&#125;); 也可简化为： 123$(function () &#123; // init...&#125;); 事件参数所有事件都会传入Event对象作为参数，可以从Event对象上获取到更多的信息（比如获取鼠标位置和按键的值）： 12345$(function () &#123; $('#testMouseMoveDiv').mousemove(function (e) &#123; $('#testMouseMoveSpan').text('pageX = ' + e.pageX + ', pageY = ' + e.pageY); &#125;);&#125;); 取消绑定可以通过 off(eventName, function)实现， 比如移除click绑定的 function 操作： 12345678function hello() &#123; alert('hello!');&#125;a.click(hello); // 绑定事件// 10秒钟后解除绑定:setTimeout(function () &#123; a.off('click', hello);&#125;, 10000); 如果只用一个参数，使用off(eventName)可以移除click事件的所有处理函数。 如果无参数，使用off() 一次性移除已绑定的所有类型的事件处理函数。 事件触发事件的触发总是由用户操作引发的，如果希望用代码触发change事件，可以直接调用无参数的change()方法来触发该事件： 123var input = $('#test-input');input.val('change it!');input.change(); // 触发change事件 动画动画分类以下动画可以传入毫秒数或者&#39;slow&#39;，&#39;fast&#39;字符串作为参数。 显示隐藏：show() / hide() / toggle() 收缩展开：slideUp() / slideDown() / slideToggle() 淡入淡出：fadeIn() / fadeOut() / fadeToggle() 自定义动画：animate()，需要传入的参数是DOM元素最终的CSS状态和时间。还可以再传入一个函数，当动画结束时，该函数将被调用。 示例一123var div = $('#test-show-hide');div.hide(3000); // 在3秒钟内逐渐消失div.show('slow'); // 在0.6秒钟内逐渐显示 示例二 12345678910var div = $('#test-animate');div.animate(&#123; opacity: 0.25, width: '256px', height: '256px'&#125;, 3000, function () &#123; console.log('动画已结束'); // 恢复至初始状态: $(this).css('opacity', '1.0').css('width', '128px').css('height', '128px');&#125;); 串行动画通过delay()方法还可以实现暂停，这样，可以实现更复杂的动画效果： 1234567891011121314var div = $('#test-animates');// 动画效果：slideDown - 暂停 - 放大 - 暂停 - 缩小div.slideDown(2000) .delay(1000) .animate(&#123; width: '256px', height: '256px' &#125;, 2000) .delay(1000) .animate(&#123; width: '128px', height: '128px' &#125;, 2000);&#125; 为什么有的动画没有效果因为jQuery动画的原理是逐渐改变CSS的值，如 height 从100px逐渐变为0。但是很多不是block性质的DOM元素，对它们设置height根本就不起作用，所以动画也就没有效果。 jQuery也没有实现对background-color的动画效果。 一个栗子在执行删除操作时，给用户显示一个动画比直接调用remove()要更好。在表格删除一行的时候添加一个淡出的动画效果： 12345678function deleteFirstTR() &#123; var tr = $('#test-table&gt;tbody&gt;tr:visible').first(); tr.fadeOut('slow', function()&#123; $(this).remove(); &#125;)&#125;deleteFirstTR(); AJAXajax()ajax(url, settings)函数需要接收一个URL和一个可选的settings对象，常用的选项有： async：是否异步执行AJAX请求，默认为 truemethod：发送请求的方法，默认为 GETcontentType ：发送POST请求的格式data：发送的数据，可以是字符串、数组或objectheaders： 发送的额外的HTTP头dataType：接收的数据格式 更多参数详情可参考 jQuery ajax() jQuery的jqXHR对象类似一个Promise对象，可以用链式写法来处理各种回调：123456789var jqxhr = $.ajax('/api/categories', &#123; dataType: 'json'&#125;).done(function (data) &#123; ajaxLog('成功, 收到的数据: ' + JSON.stringify(data));&#125;).fail(function (xhr, reason) &#123; ajaxLog('失败: ' + xhr.status + ', 原因: ' + reason);&#125;).always(function () &#123; ajaxLog('请求完成: 无论成功或失败都会调用');&#125;); get()1234var jqxhr = $.get('/path/to/resource', &#123; name: 'Bob Lee', check: 1&#125;); 第二个参数如果是object，jQuery自动把它变成query string然后加到URL后面，实际的URL是： /path/to/resource?name=Bob%20Lee&amp;check=1 post()1234var jqxhr = $.post('/path/to/resource', &#123; name: 'Bob Lee', check: 1&#125;); 实际构造的数据 name=Bob%20Lee&amp;check=1作为POST的body被发送。 getJSON()jQuery也提供了getJSON()方法来快速通过GET获取一个JSON对象：123456var jqxhr = $.getJSON('/path/to/resource', &#123; name: 'Bob Lee', check: 1&#125;).done(function (data) &#123; // data已经被解析为JSON对象了&#125;); jQuery 插件基础给jQuery对象绑定一个新方法是通过扩展$.fn对象实现的。 默认值的处理，有两种方法，一是利用&amp;&amp;和 ||短路操作符，： var a = options &amp;&amp; options.a || ‘hello’; 二是使用jQuery提供的辅助方法$.extend(target, obj1, obj2, ...)，它把多个object对象的属性合并到第一个target对象中，遇到同名属性，总是使用靠后的对象的值，也就是越往后优先级越高： 12345// 把默认值和用户传入的options合并到对象&#123;&#125;中并返回:var opts = $.extend(&#123;&#125;, &#123; backgroundColor: '#00a8e6', color: '#ffffff'&#125;, options); 步骤编写一个jQuery插件的原则： 给$.fn绑定函数，实现插件的代码逻辑； 插件函数最后要return this;以支持链式调用； 插件函数要有默认值，绑定在$.fn..defaults上； 用户在调用时可传入设定值以便覆盖默认值。 示例一：一个highlight方法 12345678910111213141516171819202122$.fn.highlight = function(options)&#123; // 合并默认值和用户设定值: var opts = $.extend(&#123;&#125;, fn.highlight.defaults, options); this.css('backgroundColor', opts.backgroundColor) .css('color', opts.color); return this; &#125;// 设定默认值:$fn.highlight.defaults = &#123; color: '#d85030', backgroundColor: '#fff8de'&#125;// 调用$.fn.highlight.defaults.color = '#659f13';$.fn.highlight.defaults.backgroundColor = '#f2fae3';$('#test-highlight p:first-child span').highlight();$('#test-highlight p:last-child span').highlight(&#123; color: '#dd1144'&#125;); 示例二：使用filter()方法实现针对特定元素的扩展 12345678910111213141516171819202122$.fn.external = function () &#123; // return返回的each()返回结果，支持链式调用: return this.filter('a').each(function () &#123; // 注意: each()内部的回调函数的this绑定为DOM本身 var a = $(this); var url = a.attr('href'); if (url &amp;&amp; (url.indexOf('http://')===0 || url.indexOf('https://') === 0 a.attr('href', '#0') .removeAttr('target') .append(' &lt;i class=\"uk-icon-external-link\"&gt;&lt;/i&gt;') .click(function () &#123; if(confirm('你确定要前往' + url + '？')) &#123; window.open(url); &#125; &#125;); &#125; &#125;);&#125;// 调用$('#main a').external();","tags":[{"name":"前端","slug":"前端","permalink":"http://yutaiwei.github.io/tags/前端/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yutaiwei.github.io/tags/JavaScript/"}]},{"title":"windows快捷键","date":"2017-02-26T10:52:09.000Z","path":"2017/02/26/windows快捷键/","text":"闲来无事，找了好多关于windows快捷键。还不懂的小伙伴可以来围观了，其实我知道的也不多。 F1帮助 F2改名 F3搜索 F4地址 F5刷新 F6切换 F10菜单 CTRL+A全选 CTRL+C复制 CTRL+X剪切 CTRL+V粘贴 CTRL+Z撤消 CTRL+O打开 SHIFT+DELETE永久删除 DELETE删除 ALT+ENTER属性 ALT+F4关闭 CTRL+F4关闭 ALT+TAB切换 ALT+ESC切换 ALT+空格键窗口菜单 CTRL+ESC开始菜单 拖动某一项时按CTRL复制所选项目 拖动某一项时按CTRL+SHIFT创建快捷方式 将光盘插入到CD-ROM驱动器时按SHIFT键阻止光盘自动播放 Ctrl+1,2,3… 切换到从左边数起第1,2,3…个标签 Ctrl+A 全部选中当前页面内容 Ctrl+C 复制当前选中内容 Ctrl+D 打开“添加收藏”面版(把当前页面添加到收藏夹中) Ctrl+E 打开或关闭“搜索”侧边栏(各种搜索引擎可选) Ctrl+F 打开“查找”面版 Ctrl+G 打开或关闭“简易收集”面板 Ctrl+H 打开“历史”侧边栏 Ctrl+I 打开“收藏夹”侧边栏/另:将所有垂直平铺或水平平铺或层叠的窗口恢复 Ctrl+K 关闭除当前和锁定标签外的所有标签 Ctrl+L 打开“打开”面版(可以在当前页面打开Iternet地址或其他文件…) Ctrl+N 新建一个空白窗口(可更改,Maxthon选项→标签→新建) Ctrl+O 打开“打开”面版(可以在当前页面打开Iternet地址或其他文件…) Ctrl+P 打开“打印”面板(可以打印网页,图片什么的…) Ctrl+Q 打开“添加到过滤列表”面板(将当前页面地址发送到过滤列表) Ctrl+R 刷新当前页面 Ctrl+S 打开“保存网页”面板(可以将当前页面所有内容保存下来) Ctrl+T 垂直平铺所有窗口 Ctrl+V 粘贴当前剪贴板内的内容 Ctrl+W 关闭当前标签(窗口) Ctrl+X 剪切当前选中内容(一般只用于文本操作) Ctrl+Y 重做刚才动作(一般只用于文本操作) Ctrl+Z 撤消刚才动作(一般只用于文本操作) Ctrl+F4 关闭当前标签(窗口) Ctrl+F5 刷新当前页面 Ctrl+F6 按页面打开的先后时间顺序向前切换标签(窗口) Ctrl+F11 隐藏或显示菜单栏 Ctrl+Tab 以小菜单方式向下切换标签(窗口) Ctrl+Enter 域名自动完成[url=]http://www.**.com[/url](内容可更改,Maxthon选项→地址栏→常规)/另:当输入焦点在搜索栏中时,为高亮关键字 Ctrl+拖曳 保存该链接的地址或已选中的文本或指定的图片到一个文件夹中(保存目录可更改,Maxthon选项→保存) Ctrl+小键盘’+’ 当前页面放大20% Ctrl+小键盘’-‘ 当前页面缩小20% Ctrl+小键盘’*’ 恢复当前页面的缩放为原始大小 Ctrl+Alt+S 自动保存当前页面所有内容到指定文件夹(保存路径可更改,Maxthon选项→保存) Ctrl+Shift+小键盘’+’ 所有页面放大20% Ctrl+Shift+小键盘’-‘ 所有页面缩小20% Ctrl+Shift+F 输入焦点移到搜索栏 Ctrl+Shift+G 关闭“简易收集”面板 Ctrl+Shift+H 打开并激活到你设置的主页 Ctrl+Shift+N 在新窗口中打开剪贴板中的地址,如果剪贴板中为文字,则调用搜索引擎搜索该文字(搜索引擎可选择,Maxthon选项→搜索) Ctrl+Shift+S 打开“保存网页”面板(可以将当前页面所有内容保存下来,等同于Ctrl+S) Ctrl+Shift+W 关闭除锁定标签外的全部标签(窗口) Ctrl+Shift+F6 按页面打开的先后时间顺序向后切换标签(窗口) Ctrl+Shift+Tab 以小菜单方式向上切换标签(窗口) Ctrl+Shift+Enter 域名自动完成 Alt+1 保存当前表单 Alt+2 保存为通用表单 Alt+A 展开收藏夹列表 资源管理器 END显示当前窗口的底端 HOME显示当前窗口的顶端 NUMLOCK+数字键盘的减号(-)折叠所选的文件夹 NUMLOCK+数字键盘的加号(+)显示所选文件夹的内容 NUMLOCK+数字键盘的星号(*)显示所选文件夹的所有子文件夹 向左键当前所选项处于展开状态时折叠该项，或选定其父文件夹 向右键当前所选项处于折叠状态时展开该项，或选定第一个子文件夹 自然键盘 【窗口】显示或隐藏“开始”菜单 【窗口】+F1帮助 【窗口】+D显示桌面 【窗口】+R打开“运行” 【窗口】+E打开“我的电脑” 【窗口】+F搜索文件或文件夹 【窗口】+U打开“工具管理器” 【窗口】+BREAK显示“系统属性” 【窗口】+TAB在打开的项目之间切换辅助功能按右边的SHIFT键八秒钟切换筛选键的开和关按SHIFT五次切换粘滞键的开和关按NUMLOCK五秒钟切换切换键的开和关左边的ALT+左边的SHIFT+NUMLOCK切换鼠标键的开和关左边的ALT+左边的SHIFT+PRINTSCREEN切换高对比度的开和关","tags":[{"name":"win7","slug":"win7","permalink":"http://yutaiwei.github.io/tags/win7/"},{"name":"快捷键","slug":"快捷键","permalink":"http://yutaiwei.github.io/tags/快捷键/"}]},{"title":"清白家风","date":"2017-01-29T13:17:35.000Z","path":"2017/01/29/清白家风/","text":"作者：子沫 现在是最关注教育的年代，也可以说是最没有教育的年代，因为分数代替了教育，疯狂追求效果的快餐社会，让家风和家教都荡然无存。这不能不说是一个大的缺憾。前段时间，重读寿岳章子的京都系列之一《千年繁华》，一个日本的女教授，从出生到去世，一直生活在京都古城，写这本书时，她住在父母留下的一栋老房子里已五十四年了，这栋房子盖得非常好，通风状况不错，夏天可以不用空调。这书是她回忆自己在京都生活的点点滴滴。我喜欢这本书，很大程度上却是被她的家风和家教所打动。在一个小城，满满当当小家情怀和世间情谊。 她说，我的双亲并非生性奢华，但对饮食非常讲究。如何吃表现寿岳家的生活精神。 她家里六席榻榻米中间摆了一张矮饭课，代表着家里的某精神象征。无论是吃饭还是喝茶，全家人都会聚拢在这张餐桌周围。开心地谈天说地。有时候，只需一张桌就可聚拢一家人，可是，很多人家里有豪华的餐桌，却常常失去了温馨的氛围，这是钱买不来的。 “家里很多年一直用火盆，生火是父亲的拿手绝活，将前一天晚上埋入灰烬里的火种稍微翻弄一下，添少许木炭，黑炭会慢慢烧红，热水壶也跟着发出腾的响声。烤土司面包，年糕，鱼干，孩子们围绕在母亲身边，也常常烤海苔，一有香味传出，父亲就会从书房走出来：煮什么东西？算我一份吧。”这样的场景真是令人神往。一家人动手做点什么，吃是一件共同的事，一件循序渐进的事，一个过程。 她说起一道母亲常做的料理“山药泥”，这个段落我看了几遍。“母亲去世后，我动手做过两三回，每次我总是边做边流泪。从前这可是一道充满欢乐的料理。山药放在大研钵里研磨一两千下，再加入高汤，从这步骤开始就是全家总动员，四个人都到厨房集合，研钵放在厨房地板上，我或弟弟负责扶稳研钵，母亲一点一点将一大早就熬好的汤，沿着钵体的边缘缓缓加入。使用大量昆布和柴鱼煮出来的高汤比清汤味道浓些，如果一开始全部倒入，山药泥和高汤的美味无法自然调和在一起，将高汤缓缓倒入研钵后，听到父亲指示，再打一颗蛋到研钵里，使用研磨棒时不可以粗鲁地碰撞到研钵体的边缘或底部，正确的力道是让棒轻轻游走在山药泥间。这道料里是父亲的家族传承下来的，制作工程相当复杂。”做好后，每个人的白米饭里浇上山药泥，一家人一起品尝，胃口大开，欢声笑语。这个过程，怎么看都像是一种神圣的仪式，父母能够给孩子留下什么？钱？房子？海外留学？统统不是，这些太过表像，很多年后，能够留下的只是某种对事对物的珍重和珍惜。我们在丢失什么？情怀，耐心，还有万事万物的敬畏。 “关于要不要在家吃饭这件事，如果说好要在家吃饭就绝对要遵守约定，这在我们家可是铁的纪律。有一次母亲发了很大脾气，就是因为父亲不回吃饭没打招呼：从结婚那天开始，我跟你父亲一起生活的时日就一天天减少，所以每一天都是非常珍贵的。正因为如此，我才想和心爱的人多点时间一起用餐，但是他却不明白我的心意，所以，我才会这么生气。”这句话让章子记忆深刻，也真的让我震惊，家也是要有纪律的，每个家都要有精神，这个精神是别人怎么变，我们家仍然在坚持属于我们的纪律。 寿岳家的餐桌就像是心灵交流的场所。 每个季节的佳肴，初夏时节，白萝卜的叶子细嫩铺满白米饭，初秋时的细姜丝淋上麻油。四季流转。情怀分明。在餐桌间细细流淌。 还有一些被人忽略的细节，而这些细节也是真正的教养所在。有人说，这是个有教育没有教养的社会，所以才会出现越来越多的问题儿童，问题中年，问题老年。 有一个削苹果的细节：“母亲要求削苹果时手不能碰果肉，切成两半，果蒂切成小三角形，切半的水果再对切，即可去皮，将切成四分之一大小的水果端出，手碰到果肉，就犯了母亲的大忌。现在，每当我看到别人切水果，就会用不怀好意的眼神观察”。只是一个削苹果的细节，却能观察一个人的教养。就像我看到有的女人把“不抖腿”列入了孩子的家教，一个人，最容易引起别人反感的也是一些细节不到位吧。一个人成不成功并不重要，重要是不要成为令人讨厌的人。 “每天使用的抹布一定要煮沸消毒好几次，厨房要彻底打扫干净，洗菜和洗碗的地方不可混用。钱不可以直接放餐桌上”他们家还有很多诸如此类的生活纪律。“若非长途旅行，绝不会在电车上吃东西，不仅吃相难看，最重要是非常不卫生。现在年轻妈妈们太漫不经心了。出租车司机说小孩把冰淇淋，巧克力弄得到处是；餐厅里小孩胡乱碰盘子，玩弄食物，没有一点用餐的卫生观念，这是我母亲最不喜欢看到的。对于这件事，专注且全心全意。绝对遵守餐桌礼仪。”这才是家风，从小就要求做到的，长大再去做就成了自然而然的事。我在想，为什么有些人看上去那低调谦和，舒适如沫春风，都是有道理的。他们活在一个良好的家教环境里，这个也是与钱无关的。餐桌就是一种家教，只不过被太多人忽略或认为不重要罢了。 “我们常用外出踏青，母亲带出来的爱心便当，特别收藏的糖果盒里，撒上黑芝麻的饭团。多层餐盒里则是竹笋，水煮蛋，木盒的沉香味。我们从不跑太远去旅行，顶多是回父亲的故乡。旅行的大半乐趣来自于母样亲手做的饭团便当。”真好，木盒的沉香味，这样有爱心便当的旅行，让孩子们明白了家的乐趣，而不是钱的乐趣。旅行只是换个地方用餐罢了，并不是你到过什么很高大上的地方，吃什么昂贵的大餐，一家人在一起就很开心了，在免费的绿水青山中，晒晒太阳，呼吸新鲜的空气就好，很多东西真的是钱买不来的。人与人最大的区别是钱买不来的东西你拥有多少？ 还有一个关于全家大扫除的情景让我记忆深刻。“一家人的大扫除可说是精彩万分。父亲带头，上半身披上一条大浴巾，下半身一件短衬裤，威风凛凛地出场。用旧棉布制作掸子，用旧毛巾缝制作抹布，毛巾折三折，大针脚夫缝合起来，我目前积存了两百条亲手做的抹布。除了一般湿抹布外，还有好几条干用抹布，擦走廓的，桌子，橱柜的，分门别类到有点复杂的程度。”连抹布都是亲手制作，都能留有回忆，一家人齐齐动手去做一件事。这样的事某种程度上已成了一个家庭事件。真是精彩，有滋有味。 我记得章子提到的这样的场景：“春天的时候，母亲开始在院子里晒布，缝衣。我也永远忘不了母亲在茶室中，面向南面窗户缝制和服的背影，同样的背影也会出现在书房，她在书房中做翻译，或替父亲的诗集上色。总之，我家的家风就是勤奋，认真地生活。” 勤奋，认真并不是过时的词，它才是最好的清白家风。他们只是普通人家，却有着平实的家风。这种家风才是孩子们最重要的成长养料。 细雨的夜晚，这个住在古城里几辈子的人家深深地打动了我。他们也只是普通人。","tags":[{"name":"读者","slug":"读者","permalink":"http://yutaiwei.github.io/tags/读者/"},{"name":"子沫","slug":"子沫","permalink":"http://yutaiwei.github.io/tags/子沫/"}]},{"title":"程序猿笑话，放松一下","date":"2016-12-28T10:15:20.000Z","path":"2016/12/28/程序猿笑话，放松一下/","text":"原文来自：http://www.itjhwd.com/cxyxiaohua-2/ 1、新春对联上联：为系统而生，为框架而死，为debug奋斗一辈子下联：吃符号的亏，上大小写的当，最后死在需求上！横批：杯具程序员。2、程序员其实可痛苦的了……需求一做一改，一个月就过去了；嚎~需求再一改一调，一季度就过去了；嚎~程序员最痛苦的事儿是啥，知道不？就是，程序没做完，需求又改了；程序员最最痛苦的事儿是啥，知道不？ 就是，系统好不容易做完了，方案全改了；程序员最最最痛苦的事儿是啥，知道不？ 就是，系统做完了，狗日的客户跑了；程序员最最最最最痛苦的事儿是啥，知道不？ 就是，狗日的客户又回来了,程序给删没了！ 3、男：我是程序猿。女：哦，程先生，你好。男：客气了，叫我序猿就好~ 4、我是你的什么，你是我的程序猿，啊？？原来我是猴子啊，酱紫我就可以让你耍coding啦！！！ 5、怎么使用面向对象的方式变得富有？继承。 6、一男子在路边一根接着一根地抽烟。一个女士走过来对他说：“嘿，你不知道你是在慢性自杀吗？注意看看烟盒上的警告信息。”“没关系”，男子悠然自得地又吸了一口：“我是个程序猿。”“嗯？这和你是程序猿有什么关系？”“我们一点儿也不在乎警告（warning），我们只在乎错误（error）。” 7、问：程序员最讨厌康熙的哪个儿子。答：胤禩。因为他是八阿哥（bug）。 8、换一个电灯泡需要几个程序员？一个也不要，这是硬件问题 9、危楼高百尺，手可写代码；举头望明月，低头写代码；王师北定中原日，家祭无忘写代码； 10、孤帆远影碧空尽，唯见代码眼前流 11、十个顶尖软件工程师参加培训管理人员的课程。老师提出了这样一个问题：“假如你供职的公司是为航空电子设备提供软件的。有一天你乘飞机出差，当你上了飞机后你发现一个牌子上写着这个飞机用的是你的团队开发的Beta版软件，你会下飞机吗？”九个软件工程师举了手。老师看着第十个问道：“你为什么愿意留在飞机上？”这人回答说：“如果是我的团队写的这个软件，飞机根本无法起飞，根本谈不上坠毁。” 12、换一个电灯泡需要几个C++程序员？你还在用面向过程的思维考虑问题。一个设计良好的电灯泡类必然封装了换灯泡的方法，所以你要做的就是调用“换电灯泡”方法 13、电脑是高速的笨蛋，程序员是低速的笨蛋。 14、爱情观爱情就是死循环，一旦执行就陷进去了。爱上一个人，就是内存泄漏–你永远释放不了。真正爱上一个人的时候，那就是常量限定，永远不会改变。女朋友就是私有变量，只有我这个类才能调用。情人就是指针用的时候一定要注意，要不然就带来巨大的灾难。 15、笑话二：女人篇有的女人就是Windows虽然很优秀，但是安全隐患太大。有的女人就是MFC她条件很好，然而不是谁都能玩的起。有的女人就是C#长的很漂亮，但是家务活不行。有的女人就是C++,她会默默的为你做很多的事情。有的女人就是汇编虽然很麻烦，但是有的时候还得求它。有的女人就是SQL，她会为你的发展带来莫大的帮助。 17、世界上最遥远的距离不是生与死，而是你亲手制造的BUG就在你眼前，你却怎么都找不到她。。。 18、杀一个程序员不需要用枪，改三次需求就可以了 19、十行代码九个警告八个错误竟然敢说七日精通六天学会五湖四海也不见如此三心二意之项目经理简直一等下流。 20、网络聊天的时候，想表达对方是猪，一般人会打“xxx你这个猪。”，程序员会打 xxx.isPig = TRUE。 21、假如生活欺骗了你，找50个程序员问问为什么编程；假如生活让你想死，找50个程序员问问BUG改完了没有；假如你觉得生活拮据，找50个程序员问问工资涨了没有；假如你觉得活着无聊，找50个程序员问问他们一天都干了什么！ 22、c程序员看不起c++程序员，c++程序员看不起java程序员，java程序员看不起c#程序员，c#程序员看不起美工，周末了，美工带着妹子出去约会了…一群傻X程序员还在加班！ 23、一个合格的程序员是不会写出诸如“摧毁地球”这样的程序的，他们会写一个函数叫“摧毁行星”而把地球当一个参数传进去。 24、Borland说我很有前途，Sun笑了；Sun说我很有钱，IBM笑了；IBM说我很专业，Sybase笑了；Sybase说我数据库很牛，Oracle笑了；Oracle说我是开放的，Linux笑了；Linux说我要打败Unix，微软笑了；微软说我的系统很稳定，我们都笑了。 25、一程序员告老还乡，想安度晚年，于是决定在书法上有所造诣。省略数字……，准备好文房4宝，挥起毛笔在白纸上郑重的写下：Hello World 26、真正的程序员喜欢兼卖爆米花，他们利用CPU散发出的热量做爆米花，可以根据米花爆裂的速度听出正在运行什么程序。 27、【程序猿的三重境界】第一重：无尽bug常作客，困闷调试伴不眠。第二重：千行代码过，bug不沾身。第三重：编码间，bug灰飞烟灭。 28、程序猿xx遭遇车祸成植物人，医生说她活下来的希望只有万分之一，唤醒更为渺茫。她的同事和亲人没放弃，并根据程xx对testing痴迷的作风，每天都在她身边念：“你测的模块上线后回滚了…”奇迹发生了，程xx醒来第一句话：确认那模块是我测的？ 29、学&lt;数据结构&gt;的童鞋注意了，告诉大家一个真相，中国实行计划生育最终目的是为了能够用二叉树进行统计管理，因为二叉树最多可以生两个孩子，多了就超生。 30、程序员找不到对象，一般有三种情况：1、 C# JAVA都有对象，但是经常找不到对象。2、ASM C直接没有对象。3、javascript都是伪对象，最多算暧昧。但C++日子一直都好过，因为C++是多继承，富二代呀！！！ 31、一群男程序员酒后乱逛，正要集体侵犯一个女子。女子见势不妙，问：那你们说最好的编程语言是什么？程序员们就地讨论了三天三夜不欢而散，女子趁机顺利脱身。 32、开着MyEclipse，独自彷徨在悠长、悠长又寂寥的雨巷，我希望逢着一个和我一样的调试代码的姑娘。她是有需求一样的凌乱，设计一样的荒唐，测试一样的忧愁，在代码里哀怨，哀怨又彷徨；她彷徨在这寂寥的雨巷。 33、某小偷潜入某IT公司欲行窃，没想到始终有人，他只好等啊等啊等，结果始终有一大拨人在加班。过了一个月，小偷终于逮到机会溜出来，同伙问：去哪了？小偷：在IT公司呆了一个月。同伙：收获不错吧？小偷苦笑：别TM提了，三十个大夜下来，我现在已经学会写程序了。 34、真的猛士，敢于直面混乱的程序，敢于正视变幻的需求。 35、《未来的云计算服务》张总在办公室下载了苍井空，按下CTRL+X后就回家了。晚上躺在床上按下CTRL+V继续观看，旁边的小蜜惊呆了，张总淡淡的说：云剪贴。 36、如果你的朋友最近没和你联系，要理解！只有三种可能：第一，他死了；第二，他改行当程序猿了；第三，需求又改了！ 37、某日和同学聊起对象问题，我答道：哥最不缺的就是对象了，要知道哥是程序员，每天不知道要new多少个对象出来，而且想要啥类型就有啥类型。如果你想要，哥给你来个for循环嵌套，new上她千个百个 38、我是个程序员，一天我坐在路边一边喝水一边苦苦检查bug。 这时一个乞丐在我边上坐下了，开始要饭，我觉得可怜，就给了他1块钱。 然后接着调试程序。他可能生意不好，就无聊的看看我在干什么，然后过了一会，他缓缓地指着我的屏幕说，这里少了个分号… 39、锄禾日当午，不如coding苦，对着C++，一调一下午；锄禾日当午，不如coding苦，调了一下午，BUG还得补； 锄禾日当午，不如coding苦，Bug刚补完，结构需重组；锄禾日当午，哪有coding苦，Bug改不完，无言见列祖。 40、最后祝大家在以后的日子里：男生象Oracle般健壮，女生象win7般漂亮，桃花运象IE中毒般频繁，钱包如Gmail容量般壮大，升职速度赶上微软打补丁，追女朋友像木马一样猖獗，生活像重装电脑后一样幸福，写程序敲代码和聊天一样有激情。","tags":[{"name":"程序员","slug":"程序员","permalink":"http://yutaiwei.github.io/tags/程序员/"},{"name":"笑话","slug":"笑话","permalink":"http://yutaiwei.github.io/tags/笑话/"}]},{"title":"沿着最初的理想走下去","date":"2016-12-19T02:22:06.000Z","path":"2016/12/19/沿着最初的理想走下去/","text":"作者：沈杰辉 电影《10件或更少》中，女主人公是一位年轻貌美、聪慧能干的西班牙女郎，但与她终日相伴的是一家郊区小超市的“10件以下商品收银台”——她深深厌恶着那里机械而繁重的工作，以及自己无比失败的婚姻。后来某天一位老牌演员忽然闯入女主人公的生活场域，并同行整日，以其豁达性情与深厚阅历为这个25岁女孩一洗心头蒙尘，让她看见其实自己的生活没那么糟糕。整部电影节奏温柔、文艺，且抛出一个相当有趣的数字游戏：说出10件以下你喜欢或讨厌的事情。影片告诉你，真正活得积极有味的灵魂，喜欢的事情会远远多于10件。 寻常市井中，如片中老演员那般“乐活”的姿态实属寥若晨星，多的是女主人公式平凡奋斗的年轻人群，在纷扰都市里搏未来生存的日子毋庸置疑要和无尽辛劳与烦忧形影相伴：疲于奔命、薪水不高、压力过大、工作单调、闲暇稀少……努力不去抱怨已属高度乐观，强颜欢笑从少有的闲适感里挖出10件喜欢之事显然过于梦幻。 令我们真正在意的事不多，10件或更少。我觉得对于在大都市闯荡打拼的年轻人而言，生活的天平其实并不需要那么多砝码，即使你此刻手里仅简简单单攥着一两个前行的理由，维系心灵的平衡和有序才是你应当在意的事情。何时何地，同自己的心和平相处，比什么都重要。 朋友圈里有不少刚离开大学校园、投身社会一年半载的职场新鲜人，与他们交流的若干片段剪辑在一起完全是一部反映青年心态的纪录片，一个经典的情节便是职场新人频频换工作，而其中心境平和者屈指可数。“没意思”“不耐烦”是常见的解释理由，不少人的状态全然表现为一种持续奔波的茫然，他们对自己驻扎过的每一任东家都心存不满，抱怨职业与个人志趣不合，或者自怜明珠暗投被繁琐杂事消耗青春，或者全程一无所获未得到明显技能培养……打游击式换工作一大圈，消极状态却一如从前。这一类职场新人起步时喜好不明，却格外看重自己每一步前行有什么收获，时时计算一份工作给予内心满足感的砝码分量，可谓“步步惊心”。然而反复计较砝码的得失，却不知回头审视和调整内心天平的平衡，导致年纪轻轻竟暮气沉沉，聊起工作即如怨妇。 想说说与众不同的一个。朋友J小姐自中学起便有志于媒体，高三当其他人抱着数理化题库和高考作文指南按部就班备考，她“不务正业”地挤出所有闲暇阅读报刊上的优质新闻报道。上大学担任校刊主编，在宿舍通宵达旦写稿排版，假期通通用于各大社会媒体的实习。毕业季新闻系同学都一窝蜂涌向公务员和外企，她上海的家里也托人给安排了妥舒适稳定的工作，男友留校读研，她却执拗一人拖着行李箱一路北上——那家知名媒体仅提供实习机会并没有承诺offer，“我就是喜欢做新闻，活这么多年唯有这件事带给我快乐。”背对着千里之外家人忧心忡忡的目光，J小姐白日里在偌大的北京城为了一纸新闻四处奔波，晚上回到“蜗居”租房还要对付永远堵塞的下水管道，摆弄不太娴熟的厨艺准备隔日餐食。 大学班级微信群里渐渐涌现各种晒优越感的签约消息，也有人褒贬不明地嘀咕一句：瞧，咱们班也就北漂的那位同学还有新闻理想呢。J小姐淡淡一笑，打开WORD文档继续编辑采访稿。那家知名媒体最终破例给了她offer，还记得她签三方后和我说，最喜欢杨德昌导演的《一一》，因为拍得透彻、明亮，人不可能看到生活的另一面，所以为了避免患得患失，遵从内心的喜好去选择总是没错的，心安为上。 这是几年前的事了，最近一次联系J小姐，她居然人在香港，听筒中依稀可辨四周熙熙攘攘的市井声，没想到她跑去了更远的异乡追随梦想的感召。听到故人问候，J小姐语气里满是激动，吐了一串“好开心”。聊起前程，压力大，异地恋，但暂时不打算回来。“沿着最初的理想走下去，生活的确更累了，不过精神也更安定了。”时光轻飘飘溜走好些年，J小姐生活的天平上始终只有两个砝码——喜欢，理想，可就是少得可怜的两个抽象理由让她心灵世界的运转井然有序，不汲汲于眼前得失，活得骄傲、平和而自在。 说起工作，许多青年将其理解为选择的问题。的确，如今职业选择的范围和自由度都变大了，在一处干得不如意还有若干出口和门路。但这不应成为青年逃避矛盾的万能借口，丰富的选择是为了让每个人更明晰内心真实的喜爱和在乎的人生志向，收获属于自己的生活平衡。 生活不如意事常八九，而人心自有平衡的法则。朋友J小姐执着地追随初心，安然迎接每一场征程赋予的阳光或风雪，然后更加热情有力地拥抱命运在下一个路口的安排。电影《10件或更少》中，老演员教导西班牙女孩，要不顾一切争取抓紧自己在意的任何人生砝码——比如果断甩掉沉闷的小超市去建筑公司面试——但更关键的一点是，无论故事的结尾何种选择降临，你都要学会乐在其中，享受轻重疾徐的步调，不去抱怨。这，就是我们心灵平衡的要义。 人心当有平衡的法则，生活不纠结，世道再难，也能呼吸顺畅。","tags":[{"name":"读者","slug":"读者","permalink":"http://yutaiwei.github.io/tags/读者/"},{"name":"励志","slug":"励志","permalink":"http://yutaiwei.github.io/tags/励志/"},{"name":"理想","slug":"理想","permalink":"http://yutaiwei.github.io/tags/理想/"}]},{"title":"讲故事写小说","date":"2016-12-09T02:35:19.000Z","path":"2016/12/09/讲故事写小说/","text":"原作者不详，yutaiwei整理。 小说其实就是给读者讲故事，讲好一个故事，也就写好了一部小说。 对于新人来说，在讲故事以及编故事方面，都有一些生涩之处，今天这个帖子里，会单就编故事方面，写一些我总结出来的经验。一家之言，多有偏颇，抛砖引玉，欢迎讨论。 故事的概念，没必要用一些很虚无缥缈的解释来进行曲解，故事就是故事，只是多个人物共同演绎出来的一段有趣的事件而已。故事本身的定义是简单的，真正的难的是如何编好编故事。 在编故事写提纲方面，网文同道已经有许多人总结过一些经验，其中有两个方法最为简单实用，第一个方法是七要素，在设计故事的时候，全都围绕“奇遇、升级、寻宝、泡妞、发财、欺人、助人”这七个要素来展开设计；第二个方法是九线，这种方案是围绕“1、主角智慧性格2、配角炮灰3、技能4、伙伴5、装备6、冒险7、身世8、势力9、后宫”这九种要素来展开设计。 七要素跟九线的设计思路是一致的，只不过是考虑的要素不同而已，这两种技巧以前已经有人写过了，好奇的可以去百度，我就不赘述了。 除了网络写手总结的这两套经验之外，传统小说的一些编故事的技巧，实际上也是非常好用的，比如说语文课本上关于“起点，经过，结果”的记述。这正是一个故事完整的结构，由此为出发点，同样能编出有意思的故事。 在编故事方面，编剧也是此中的行家里手，也有许多关于编故事的技巧跟方法，我研究了一些编剧的指南，其中有位资深老编剧提供的一种方法也非常不错，这里也重点提一下。这位老编剧所推崇的方法是“人物构建法”，这种方法是先确立一整套人物关系，将每个人物之间的矛盾想好，然后让这些人物动起来，思考这些人物在面临各种情况下会如何处理，让这些人物进行碰撞，不断碰撞的过程中，故事自然也就出来了，当碰撞到极限，有了结果时，故事也就随之结束。 人物构建法在网文中是很少有人应用的，但是影视剧中很多人在用。在网络小说中，有许多路人甲角色，往往存在的意义就是领便当，出场极短。在影视剧当中，虽然也有路人甲，但数量要远远低于网络小说，每个人物都很重要。所以影视剧很重视人物关系以及人物的作用，会下大力气进行设计。 人物构建法是个颇为精深的技巧，没个几千字是交代不清楚的，我这里只详述其中一个关键性技巧，用好这一个技巧，就很厉害了。 在小说的人物关系之中，为了凸出矛盾，人物之间不是敌方就是我方，十分明显，但这种设定太过简单了，而且也无法摩擦出巧妙的故事，所以在设计的时候，可以多多考虑双重关系，让人物之间的关系变得复杂起来。 举例来讲，主角有个杀父仇人，但不知道这个仇人到底是谁，后来主角爱上了一个女人，结果这个女人正是主角的杀父仇人。这样的复杂关系，会让主角对女主角又爱又恨，进而演绎出一段相爱相杀的虐恋。 这个例子是比较虐的，但只要技巧在手，无论怎么运用都可以，将这个技巧用在爽上面是一样的。 举例二，主角有个敌人，实力不如对方，一直处于下风，直到某天主角学了一门医术，而这么医术正好能治这位敌人父亲的病，敌人为了求主角给父亲治病，只能各种讨好，以及甘愿当牛当马，受人驱使，甚至还得把宝宝妹妹介绍给主角……这个就是以爽快为出发点的例子了。 关系一旦对调并复杂化，马上就会产生许多乐趣，这便是设计人物关系的精髓所在。 以上，都是别人总结的技巧，接下来，才是我总结的一种技巧，这才是这个帖子的重点讲解对象。 七要素跟九线，固然是很实用的编故事技巧，不过局限性很大，全都围绕着一些固定的要素来写，就会产生固定思路，很难跳脱出去。 起点、经过、结果，固然是故事的正确结构，可是光知道结构，对于编故事方面的帮助却收效甚微。 人物构建法能创造出很棒的人物关系，但运用起来的难度较大，一来容易因为戏份分摊导致主角形象降低，二来会导致反派人物太深入人心不方便干掉，三来容易导致人物关系过于复杂，无法处理清楚，四来容易造成人物关系纠结成网，无法跳转新副本，导致滞留在一处，五来如果女人太聪明，就无法开后宫了……总而言之，我在运用以上几种技巧编故事的时候，全都遇到了各种难处，觉得不甚好用，所以自己苦思了一段时间，还真想出了一个新办法出来。 我给这个这个新办法取名为“事件组合法”。 顾名思义，这个办法就是利用大大小小的事件组成一个完整的提纲出来，大事件套着小事件，小事件连着小事件，众多小事件组成大事件。 事件的概念是什么？ 事件……就是事件，并非什么深奥的东西。 在这点上还是举例来讲，一举例大家就全明白了。 逃课的男主角在街上闲逛时，遇到了请病假的女主角，两人恰好今天都没有去上课，感觉很有意思，在街上聊了几句，然后去看了场电影，吃了顿饭——这就是一个小事件。 男主角遭遇退婚，受到羞辱，经过一番修炼之后，杀上女方的家里找场子——这就是一个大事件，很长线的大事件。 大事件全都是由小事件组成的，一步步推演发展，铺垫渲染，最终达到整个事件的最高潮。 用这种方法来编写提纲的时候，就是思考许多个事件，然后将事件组合起来。在此过程中，还得结合人物关系，小说风格，题材分类，主角外挂，力量体系等元素进行思考，光拿事件进行拼凑是不行的。 比如要编写一个以重生为外挂的玄幻小说，风格定位为传统爽文，力量体系为斗气，在确立了这些东西之后，就可以展开思考了。 前期第一个大事件是门派被灭，主角重生后的目的是阻止这件事情的发生，以这个大事件为前期主线，开始对小事件进行设计。 第一个小事件是主角被同门欺负，导致昏迷，醒来后已经是重生者了，将此来做为开头，稳扎稳打。第二个事件是同门小师妹来问长问短，给主角送药。第三个事件是从门派隐秘处挖一根灵草，修复身体，提升功力……以此类推，逐步推进剧情。 之前提过了，用事件进行组合得结合多方面进行思考，不能生搬硬套，否则只会不伦不类。 在刚才那个例子当中，设定的是玄幻题材，玄幻题材经过这些年的发展，已经产生了许多常见的事件，用这些事件来编故事，才能编出带有玄幻风味的故事，如果采用跨题材事件来编故事，很容易导致故事走形。 玄幻的事件，修真的事件，都市的事件，历史的事件……全都各有其特色，彼此之间有一些可以通用，有一些不能通用，需要分清楚。 搞笑的事件，悲伤的事件，热血的事件，紧张的事件……在风格方面，事件也有其另一番面貌，也需要重点加以考虑，只有各方面完美结合，才能创造出一个合格的好故事。 编故事是一个浩大的工程，无论是再好的技巧，也无法让这变成一个轻松的活儿，我提供的这个事件组合法，也只是一个思考问题的出发点而已。 想要真正做到念头通达，挥洒自如，还是得多积累，多磨练。","tags":[{"name":"小说","slug":"小说","permalink":"http://yutaiwei.github.io/tags/小说/"}]},{"title":"金钱能买来幸福吗","date":"2016-10-20T14:38:18.000Z","path":"2016/10/20/金钱能买来幸福吗/","text":"译者：裘霜 金钱能买来幸福吗？这是一个古老的问题。 在过去几年中，新的研究让我们对获得和感受之间的关系有了更深入的了解。在许多国家，经济学家一直在审视收入和幸福的关系；心理学家对人类个体的研究发现了在涉及现金时，是什么真正令我们怦然心动。 乍看起来，结果似乎有点显而易见：是的，从广义上说，高收入者比勉强摆脱贫困的人更快乐。 不过，对发现进行更深入的探究之后，他们得到了大量更令人惊讶、也更加有用的结论。 简而言之，最新研究表明，财富本身并不能为美好生活提供任何保证。比高收入更为重要的，是人们如何花钱。举例来说，与为自己花钱相比，为别人花钱更令人愉快。而且，当人们把钱花在自己身上时，花钱旅游、增长见识，比购买物质产品更让人感到持久的幸福。 让我们看看对于指导人们更明智地使用金钱、最大限度地提升幸福感方面，最新研究有哪些高见。 经历的价值超出想象 最近，瑞安·豪威尔被一个难题所困扰。过去10年间进行的大量研究表明，相对于物质商品，生活经历赋予我们的快乐明明更持久，可为什么人们在考虑如何花钱时，还是常常否定经历的价值，优先购买物质产品？ 作为旧金山州立大学心理学副教授，瑞安·豪威尔决定一探究竟。他发现，人们之所以认为买东西能够更好地体现金钱的价值，是因为经历总是转瞬即逝，但物质产品却一直在那里，看得见、摸得着，可以反复使用。所以，尽管人们偶尔会花一大笔钱去度假或购买演唱会门票，但在手头不甚宽裕的情况下，他们坚持把有限的金钱用来购买物质产品。豪威尔说：“人们认为经历只能提供短暂的快乐，但实际上，它能提供更多的快乐和更持久的价值。” 美国康奈尔大学心理学教授托马斯·季洛维奇也得出了类似的结论。“人们常常进行理性的计算：我的钱有限，要么出去玩，要么买东西。如果我出去玩，会很不错，但很快就结束了；如果我买东西，至少可以永远拥有它。这在事实上是正确的，但在心理层面上却未必，因为一旦买到手，我们很快会对自己物质财富习以为常。”这种过程叫做“享乐适应”，它使得人们难以通过购买物质感受到长久的幸福。新衣服或时髦汽车可以让人获得短暂的快感，但我们很快就认为它们理所当然了。 另一方面，季洛维奇教授认为，经历往往能够满足我们更多潜在的心理需求。旅行虽然很快结束，但我们可以经常与其他人共享自己的经历，不但能与他人有更广泛的联系，还有利于形成更高的认同感。如果您攀登过喜马拉雅山，那么，即使很久以后所有钟爱的小玩意儿都被抛在脑后，您还可以常常回忆和谈论这段经历。 更重要的是，我们往往不会拿自己的经历跟他人攀比，而物质方面的攀比要突出得多。季洛维奇教授说：“想象一下您刚刚买了一台新电脑，非常喜欢、满足，接着您的一位朋友出现了，说他也刚买了一台电脑，显示屏比您那台更亮、处理器更快。您该觉得多不爽啊！但是，如果您和您的朋友同时去度假，哪怕朋友去的地儿比您去的地儿更酷炫，您仍然拥有自己的经历和回忆，便不会那么闹心了。” 季洛维奇教授和他的同事们还发现，期待一段美妙的经历，要比等着购买实际有形的商品更能带来快感。等待一个事件的发生一般会令人兴奋，而期待物质性的东西则“似乎让人不耐烦”。 不要对所购物品习以为常 拥有更多物质并不总让我们欣喜，其中一个主要原因是我们习以为常了。“人类极其擅于习惯生活中的变化，尤其是积极的变化。”加州河滨大学心理学教授索尼娅·吕波密斯基说，“如果您的收入增加了，会给您带来快乐，但您的愿望也会跟着水涨船高。增加的收入也许能让您在更好的小区买更大的房子，结果那里的邻居们也更有钱，您想要的反而更多了。您已经踩上了‘享乐跑步机’，试图让它停下来或减慢速度，确实是一种挑战。” 吕波密斯基教授说，一种可行的方法是尽量有意识地欣赏和感谢您所拥有的，时常提醒自己敝帚自珍，将“享乐跑步机”的速度减缓下来。具体做法很简单，比如每天安排固定的时间，数数自己的幸福，又或者您可能想记日记，或者向他人表达感激之情。关键是要找到一种方法，对自己所拥有的一切保持清醒的认识，避免简单地把它们摆在四周。 吕波密斯基教授坦承，因为您是在与自己的自然倾向作斗争，所以，感激和赞赏很难持久。如果您的日记或每日感谢变成了乏味的例行公事，就不再有什么作用了。您可能需要变换使用其他技巧。 增加多样性、新颖性或惊喜，也可以帮助您更珍惜自己的所有。比方说，如果把一幅画挂在同一面墙的同一个位置，除了刚买回家的那段日子，您不会再多看它一眼。但是，如果把它与另一个房间的另一幅画对调，您就会用新鲜的眼光观看两幅画，而且会更欣赏它们。 吕波密斯基教授还建议，应尝试与他人分享您的所有，并敞开心扉，迎接新体验。这意味着您可以把自己的东西借给别人，或者与他人分享。吕波密斯基教授做了一个实验，给实验对象每人家里寄去一大包巧克力，告诉其中一些人尽可能多吃，告诉另一些人不准吃，第三组人可以自行选择吃多少。 结果如何呢？现在再面对巧克力，与可以敞怀吃、或按照通常食量吃的人相比，被禁止吃巧克力的人吃得更有滋有味。“暂时放弃一些东西确实有助于我们保持乐在其中的能力。”吕波密斯基教授说。 试着给别人钱 说到钱，一种自相矛盾的现象是，虽然赚更多的钱可能会提升我们的幸福感，但是，给别人钱却比为自己花钱更令人快乐。 这一结果是从吕波密斯基教授的一系列研究中发现的。一开始她在校园里向学生随意派发现金，并告诉一些人要把钱花在自己身上，告诉另一些人把钱花在别人身上。结果显示，后者比前者更开心。 此后，吕波密斯基教授反复在世界各地的不同国家重复这一实验，并将实验方式拓展为让人们送出自己的钱，而不是从教授那里白得的现金，以观察人们是否依然高兴。她发现，在加拿大、南非和乌干达等不同国家，施舍金钱都让人们更快乐，无一例外。即使在那些贫困国家，当人们囊中羞涩时，送出自己的钱仍然令人快乐不已。 吕波密斯基教授还与来自100个国家的经济学家分析了盖洛普世界民意调查数据，结果发现，向慈善机构捐款的人更加快乐，在穷国和富国皆是如此。“我们能够在加拿大观察到与南非和乌干达等地一模一样的效果，在我的从业生涯中，这无疑是最大的惊喜。”她说，“很多人的想法是，等我有钱了，就向慈善机构捐款，但实际上我们看到的乐于奉献的人，往往是正在贫困线上挣扎、努力满足自身基本需要的人。” 就幸福而言，指针的移动与您拥有的金钱数额关系不大，但与您的捐款所产生的效应密切相关。如果您看到自己的钱让别人的生活有所不同，就会使您快乐，即使您出资的数额微不足道。 还要确保花钱买时间 同样重要的一点是，您买回来的东西会怎样影响您安排自己的时间。在郊区购置大宅似乎是一个不错的主意，但研究人员发现，在其他条件不变的前提下，长时间通勤时间会降低总体生活满意度。据计算，您需要加薪40%，才能抵消1小时通勤所增加的痛苦。 “花钱买时间更划算，”吕波密斯基教授说，“不要购买一辆更花哨的汽车，除了每天上下班的时候坐在车里，您不会在其他时间需要它。与其在郊区买别墅，每天长时间通勤，不如在市区购买一处离工作地点很近的小房子，如此一来，您就可以利用日落前1小时与您的孩子在公园里踢踢球。” 另一种为自己购买时间的方式是把不喜欢的工作外包出去。聘请私人助理曾经是富人的专利，但现在人们可以更方便、更实惠地雇佣自由职业者，或在网络上找专业人士，帮自己完成日常管理，或单个任务。 目前，吕波密斯基教授正在做的研究涉及到人们外包任务后如何安排因此所节省的时间，以及这样做是否使他们更快乐。初步调查结果表明，通过为自己购买时间，大多数人确实变得更加快乐，但前提是他们使用时间的方法正确无误。如果人们将它视为是“意外得到的时间”，并真的用它做点计划之外、让我们更加快乐的事，我们才能在情感上受益。 不过，虽然购买时间不失为一个好主意，但总是用金钱来衡量时间的价值却未必可行。一旦人们把自己的时间当做金钱，便不太可能花时间去做没有经济收益的事，即使是少量时间也不行。因此，将时间当做金钱也会造成一些破坏性后果。 钱只会在一定程度上带来幸福 幸福的第一个衡量指标是“可评估性”，吕波密斯基教授将其定义为：“从某种意义上说，您的生活是美好的——您对自己的生活满意，正在朝着人生目标迈进。”经济学家们对世界各地的经济数据和幸福调查进行了广泛的研究比对，非常明显的证据表明，在世界各地几乎每一个国家，富人都比穷人更幸福，富裕国家的人比贫穷国家的人更幸福。 幸福的另一个要素是“情感性”，吕波密斯基教授解释说，这是指一个人经历愉悦、喜欢和安宁等正面情绪和与此相对的负面情绪的频率。“您也许整体上对自己的生活感到满意，但其实真正开心的时候不多。”她说，“当然了，快乐的人也会体验到负面情绪，只是没那么频繁。所以幸福其实是由‘可评估性’和‘情感性’两个部分组成。” 当研究者审视情感性指标时，一户家庭的年收入一旦达到7.5万美元，他们的幸福感便不再随着钱的增多而递增。总之，当您钱不多的时候，额外一点点钱就会让您开心很久，因为您有能力满足更多基本需求了。然而，一旦您积累了一定财富，再想“买到”更多幸福就变得难上加难。 切忌入不敷出 最后，虽然关于金钱与幸福的许多研究都侧重于如何花钱而不是如何省钱，研究者认为，入不敷出将招致灾难。关照好您的基本需求，确保一定程度上的金融安全，是非常重要的。 季洛维奇教授认为，虽然他的研究表明，相对于物质产品而言，生活经历能够给予人们更多幸福，但人们首先当然应该购买必需品。尽管他的研究结果可以涵盖各个收入水平的人群，但却不适用于收入非常低的人群。他说：“那些人真的无法自由支配收入，手里的钱几乎全部用于购买必需品了。” 研究还表明，债务对幸福感产生不利影响，而储蓄和金融安全往往会提升幸福感。一项关于英国家庭的调查发现，那些债务水平较高的人群拥有较低的幸福感，而一项针对已婚夫妇的研究则显示，更多债务意味着更多婚姻冲突。“储蓄有利于促进幸福;债务不利于幸福。但是，债务的弊端大于储蓄所带来的好处。”吕波密斯基教授说，“从幸福的角度来看，更重要的是摆脱债务，而不是增加储蓄。” 所以，在您走出去、花大钱享受梦想假期之前，请确保您已经照顾好自己的基本需要，还清了债务，并有足够的钱防范生活中最糟糕的事情从天而降。如果您为了获得一流的人生经历而举债度日，那么，当信用卡账单到来时，一流的人生经历所带来的快乐将被还款压力一笔勾销。","tags":[{"name":"读者","slug":"读者","permalink":"http://yutaiwei.github.io/tags/读者/"},{"name":"裘霜","slug":"裘霜","permalink":"http://yutaiwei.github.io/tags/裘霜/"}]},{"title":"你总会信仰些什么","date":"2016-10-19T02:24:06.000Z","path":"2016/10/19/你总会信仰些什么/","text":"作者：白岩松 读书读久了，你总会信仰些什么。 当我们翻开一本书，要在翻开的这本书里头寻找到什么呢？这个话题似乎要从我们刚刚出生来到这个世界上开始说起。当人生的这本书刚刚翻开，在未来漫长的岁月里，在这本书里，我们又要寻找到什么呢？也许两者的答案有很多是相似的。首先翻开一本书，我们希望知道自己是谁，我的家乡在哪里，而世界又在哪里。如果我不打开书，我会以为世界就像我生活的这座城市一样，有草原，有森林，有很多和善的人们。但是当我打开书才知道，《上下五千年》里有那么多的历史；当我打开书的时候，我知道在《一千零一夜》里还有另外一个跟我们完全不一样的世界；当我打开书的时候才知道有好人、有坏人；当我打开书的时候才知道，北京、江苏、四川或者其他的地方怎么怎么样。了解的事情越来越多了，这个世界开始变得越来越大了，结果一个又一个少年该如同我一样，开始向往外面的世界。如果没有书，你不会知道世界是个什么概念，即便后来当你的年岁足够大了，当你来到一个又一个陌生的国度里，你竟然发现一切似乎没那么陌生，因为早在白纸黑字上，早在字里行间，早在曾经翻开的一本又一本书当中，你曾经如此亲密地靠近过它，世界变得不再那么遥远，也不再那么陌生了。 说起来真的有意思，总有很多人问我，对我影响最大的一本书是什么？我的答案永远是一样的，当然是《新华字典》了。如果要是没有《新华字典》，没有我从最简单的一个又一个汉字开始认识起，一直到后来，我怎么会有勇气、有能力翻开一本又一本或厚或薄的书呢？如果我不能翻开那些书，我的很多困惑、我的很多未知怎么能在我的面前陆续打开呢？成长是什么？成长不仅是年岁慢慢增长，更重要的是内心所累积的一个又一个问号慢慢地得到答案。 当你的答案越来越多，当你的问号开始慢慢地被抻直的时候，你就是在成长。最小的时候可能在读《十万个为什么》，获取一个又一个答案，如果没有那些书，答案不出现在你的面前，你就永远像是一个仰望星空的孩子。虽然在这一生当中葆有好奇，葆有问号，永远是一个最重要的事情，但是，在你成长的过程中，如果你的一个又一个问题不能得到解答的话，成长怎么可能变成现实呢？从你最初好奇的一加一等于二，到后来一加一等于二不再是一个简简单单的数学题，而是人生，是大的哲学，是你如何去捍卫常识；当别人因为自己的利益，能喊出一加一等于三，甚至等于四的时候，你还有勇气去坚持说一加一等于二。你想想我们走了多远的路程了。从最初只是一个最简单的小学的数学题到后来与常识、与正义、与真理有关，如果没有那一本又一本翻开的书，你怎么可能有这种成长呢？总有人问我读书有什么好处。我说用几个“解”来回答你吧，它可以解惑，它可以解气，有的时候你有很多这种郁闷和生气，打开书看到有与你同样生活在这个世界上的人，或者古人甚至都提前把那种呐喊替你发泄出来，你就觉得挺解气的。 另外，还解决你的很多挣扎和困惑。翻开一本又一本书的时候，你看到答案，拥有了一种解决的方案，道路变得更加清晰了。当然千万别忘了，看书还有另外的功能，那就是有的时候还解闷。哪怕现在人们开玩笑连解手的时候，都需要有那些看起来不那么累的书能陪伴你度过人生当中永远不会没有的这种时光。一天总是琐碎的，但是累加在一起却可能会获取很多知识，因此，我觉得一个能提供这么多“解”的书，会帮助一个又一个人更好地走这样一个成长的道路。 在我们寻找的无数答案当中，最后一种答案可能非常的重要。它帮助我们寻找到平静和幸福，我们可能都记着这样的一句话，“华北之大，已经安放不下一张平静的书桌了”。那是一个屈辱的时代。但是现代在物质大潮快速奔涌而来的时候，这句话可以稍微地变一变了，变成什么呢？ “中国之大，找到一颗平静的心简直太难了。”但是不平静又怎么可能幸福呢？我曾经有过这样的经历，周围是乱的，自己的心里也是乱的，当你打开书想在书里找到平静的时候，最初几页是很难的。但是当最初的几页慢慢读进去了，你就觉得好书真像是一堵又一堵的墙，开始慢慢地升腾起来，把外面的车水马龙还有那些喧嚣的声音都阻拦在了外面。这个时候，你觉得那颗躁动的心慢慢地安静下来，这个世界你似乎又可以在白纸黑字里闻得到花香，听得到鸟的声音，大自然仿佛又回到了你的身边。更重要的是没有平静怎么可能幸福呢？ 那么，幸福与读书、与平静有什么关系吗？很有关系，幸福是由三个关键词构成的，那就是物质、情感和精神。只有物质基础、情感依靠、精神支柱这三种因素的分数都不错，加起来你的幸福指数才高。而读书与这三者紧密相关，“读书无用论”的论调早已经慢慢消散了，那个时代也结束了。 早有调查显示，人们读书和知识获取的水平和你的工资收入是成正比的，我想只有你的读书足够多了，你才会更有创意，才会更自信，你才会更有底气，才能获取更多的物质回报。但是这还不是最重要的。书读得多了，你在情感方面会是一个充沛的、获益很多的人，你的依靠会更充实，更重要的是在读书中会寻找到我们的信仰和精神支柱。中国人的信仰千百年来并不是仅仅靠宗教来支撑的，它就在唐诗宋词当中，在爷爷姥姥讲给你的故事里，在《三国演义》里，在《红楼梦》里，在《西游记》里，在无数的经典书籍当中，至今依然被文人用那种美丽的方块字写在字里行间。 读书读久了你总会信一些什么，信一些什么就有了敬，有了畏，因为信仰我认为最重要的是“敬畏”二字。有了敬，有了畏，知道什么是最好的我要去做，知道什么是不好的我不能逾越它，就如同社会这条奔腾的大河两边有了安全的河床，敬和畏这两个河床在，不管这条河流如何奔涌，总是安全的。我们现在正处在慢慢建两边河床的过程中。 因此，如果更多的中国人能够多读书，能够让自己的心平静下来，能在这里慢慢找到幸福感并且找到自己的话，中国就会变得更好。也许读书不能解决所有的问题，但是读书可以改变很多，可以让我们一个又一个人变得更好。 当我们一个又一个人变得更好的时候，你什么样，中国就什么样。","tags":[{"name":"读者","slug":"读者","permalink":"http://yutaiwei.github.io/tags/读者/"},{"name":"白岩松","slug":"白岩松","permalink":"http://yutaiwei.github.io/tags/白岩松/"}]},{"title":"Mongodb的使用","date":"2016-09-19T14:03:55.000Z","path":"2016/09/19/Mongodb的使用/","text":"一个基于分布式文件储存的开源数据库 设置一个数据库的启动路径 12345mongod --dbpath=D:\\mangodata//mongod 为启动服务的可执行命令//-path 指定数据存放目录//此目录一定要提前创建好//如果显示waiting for connections on port 27017即为成功 MAC用户 http://www.zhufengpeixun.cn/doc/html/node%E5%91%A8%E6%9C%AB%E5%A4%A7%E7%BA%B2/5.mongodb.html 客户端命令 切换数据库 1use zfpx2017 查看当前数据库 1db 插入文档 1db.stu.insert(&#123;name:'zfpx'&#125;) 查找 1db.stu.find() 主键 一个文档中，最主要的键，是全局唯一的，永远不会变的—身份证号 node下使用 1234567891011let mongoose = require('mongoose');mongoose.Promise=Promise;//连接数据库 mongodb://ip:端口号/数据库名字mongoose.connect('mongodb://127.0.0.1/201612node');//定义数据库的模型骨架 不能直接操作数据库let PersonSchema = new mongoose.Schema(&#123; name:String, age:Number&#125;);//定义一个模型 Person-&gt;person-&gt;转复数形式 值就是集合的名称的来源let Person = mongoose.model('Person',PersonSchema); node下增加一条数据 123456Person.create(&#123;name:'zfpx',age:8&#125;,function(err,result)&#123; console.log(result);&#125;);Person.create(&#123;name:'zfpx',age:8&#125;).then(function(result)&#123; console.log(result);&#125;); node下查找一条数据 12345678910111213141516171819202122232425262728293031323334/** * find 查询所有符合条件的文档 [] undefined * findOne 查询最多一条符合条件的文档 对象 undefined */Person.findOne(&#123;_id: '5882d3272198e02a605a6e2f'&#125;,function(err,result)&#123; console.log(result);&#125;);//find方法也可以添加参数，限制查询的条件//控制返回的字段数量 name// 1 表示包含 ，只显示此字段，其他字段都不要// 0 表示排除 排除此字段，其他的都要Person.find(&#123;&#125;,&#123;name:0,age:0&#125;,function(err,docs)&#123; console.log(err); console.log(docs);&#125;);//也可以直接根据ID查询//根据ID查询对象Person.findById('5882e22c4c2d3b2d88067ed5',function(err,doc)&#123; console.log(doc);&#125;);//查询分页/** * 1.每页3条 * 2.查询第二页的数据 * 3.根据年龄倒序排列 */let pageSize = 3;let pageNum = 3;//排序 -1 倒序 1 表示升序//对服务器的数据请求是在exec的发出 的Person.find(&#123;&#125;).skip(pageSize*(pageNum-1)).limit(pageSize).sort(&#123;age:-1&#125;).exec(function(err,result)&#123; console.log(result);// 2 3 4 4 3 2&#125;) node下修改一条数据 1234567//&#123; ok: 1, nModified: 1, n: 1 &#125;// n匹配的条数 nModified实际更新的条数// 更新的时候，最多只会更新一条// multi 匹配多少条 更新多少条 3 4 默认是falsePerson.update(&#123;name:/g/&#125;,&#123;age:100&#125;,&#123;multi:true&#125;,function(err,result)&#123; console.log(result);&#125;); node下删除一条数据 123 Person.remove(&#123;&#125;,function(err,result)&#123; console.log(result.result);&#125;);","tags":[]},{"title":"让伤疤微疼","date":"2016-09-05T13:24:56.000Z","path":"2016/09/05/让伤疤微疼/","text":"作者：王纯 去朋友家做客，发现他的书桌上有一个小记事本，封面上写着“让伤疤微疼”。不觉好奇，朋友让我打开看。只见他的本子上写着：某年某月某天，做了个小手术，虽然不是大毛病，但要记得，是该储蓄健康了，伤疤好了，别忘了疼。还有，某年某月某天，工作失误，第一次犯这样的低级错误，主要原因是马虎，同样的错误不能犯第二次。某年某月某天，母亲突然晕倒，到医院检查是血压高，多关注老人的身体，千万不能忽略了，爱可能会来不及。诸如此类，都是生活中遇到的一些问题，提醒自己一定要警醒，所以他说“让伤疤微疼”。 我不由被朋友的良苦用心打动了。生活中，我们很多人都太容易“好了伤疤忘了疼”。 我一个远方的表舅，事业蒸蒸日上，他也是全身心投入到事业中，加班加点是常有的事。没想到他突然间脑出血，在医院接受治疗时，他叹着气说：“人呐，真没必要拼死拼活地干。身外之物，生不带来，死不带去，只有身体和健康是自己的。”大家也都劝他，把工作放放，少挣点没关系。他点头答应。 刚出院的时候，表舅的手脚还不利落，在家休养。他养花种菜，过得也很开心，大家都以为他想开了。没过多久，他的手脚完全恢复了，虽然每天都吃药，但他感觉没事了。正好有一笔大生意来了，他不顾家人劝阻，接了下来。他以为身体没事，可工作起来费心劳神，他很快就挺不住了。突然有一天，一头栽倒，再也没有起来。 大家都说，表舅吃了“好了伤疤忘了疼”的亏。 其实，复杂多变的生活和工作中，总会出现这样那样的问题。问题的出现，对我们来说是个很好的提醒。有时还有一些让你很受伤的事，刺痛你，但我们习惯了时过境迁，把伤痛忘得一干二净。 让伤疤微疼，是一种智慧。把经历的伤痛默默记在心上，时时提醒自己，伤疤虽然结痂，但要让自己微疼。过去的一切，都是宝贵的经验，失败和伤痛更是一种难得的财富，要懂得利用。 让伤疤微疼，也需要勇气。有了伤疤，有些人千方百计选择各种“疤痕灵”消除伤疤，说是忘记伤痛，重新开始。其实最明智的做法是，在伤疤上纹上一朵淡淡的花，提醒自己，曾经伤过。人要有直面伤疤的勇气，要留有疼痛的记忆。只有这样，才能让自己少受伤害。 每个人都有大大小小的伤疤，身体、工作、情感、生活等等。有让伤疤微疼的能力，就有了获得智慧人生和幸福人生的能力。","tags":[{"name":"读者","slug":"读者","permalink":"http://yutaiwei.github.io/tags/读者/"},{"name":"王纯","slug":"王纯","permalink":"http://yutaiwei.github.io/tags/王纯/"}]},{"title":"赚钱以外的功夫","date":"2016-09-05T12:56:11.000Z","path":"2016/09/05/赚钱以外的功夫/","text":"作者：冯仑 我发现一个非常有趣的现象，李嘉诚在创业的时候，许多人都比他有钱，但后来那些人不见了，或者财富排在他后面。比尔?盖茨创业的时候，比他钱多的人也很多，但盖茨今天成了首富。中国许多企业家也是如此。为什么？ 因为，在中国由计划经济向市场经济，由封闭向开放，由野蛮的市场经济向文明法制的市场经济转型过程中，最重要的恰好是钱以外的因素。 就像你驾驶一辆汽车在高速公路上要并线转弯，既要车不能翻，还要保持速度，这非常难。这时候的问题不在于汽油，而在于司机的技巧，这个技巧就是钱以外的东西。钱以外的能力究竟是什么能力？我讲四种。 一、将自己的姿态放低 钱以外的能力之一是做人的能力，特别是做人的姿态。我发现凡是生意做得不错的人，都善于把自己的姿态放得很低，在中国文化里这叫给别人面子，就是你得把人尊敬一下。凡是刚开始做生意的时候，他们的姿态都很重要，就是很谦恭、谦虚、谦卑。按北京话来说，挣钱要像孙子，花钱要像大爷。 二、价值观 钱以外的第二个能力是价值观。价值观是我们判断是非善恶的简单标准。你之所以做这件事而不做那件事，之所以这么做而不是那么做，就是价值观。MBA经常讲差异化竞争，差异化的战略在产品、在营销方法这些方面，几乎都可以模仿。真正不能模仿的是价值观，这就是为什么有些人能够成功，有些人不能够成功。 所谓价值观，就是在你心里跟你的合作伙伴、同事、朋友建立金钱关系的时候，你需要拿一个尺度来衡量、来决策，而这个东西会引导你朝不同的方向去走。例如，我们看马云，不要看马云成功的故事，而应该看马云是怎样在微观决策的时候，判断细小的是非。比如马云在上市的时候，他只拿了5%的股份，这就是价值观。还有一些人，会把70%的股份变成自己的。而这个价值观会导致未来非常多的人生故事和结局。 三、毅力和耐心 钱以外的第三种能力就是毅力、时间。为什么坚持这件事很重要？因为如果你没有理想，就不可能有毅力。所有的人在做事情的时候，最后不是比一个结果，而是比一个过程。一件事情的性质由什么决定，我认为取决于两方面。第一，取决于时间，时间不同，对这件事的评价完全不一样。第二，取决于你跟谁做。 做企业也是这样。如果我们在做了三年的时候垮掉了，大家可能把我们随意看待。当我们30年还在这儿的时候，大家开始有一些敬意。当300年后这个公司还在的时候，大家开始顶礼膜拜。所以时间是一个很好的东西，它可以考验你的价值观和做人的姿态。中国历史传统中，没有把事往快里办的办法，大部分都教我们把事往慢里办。通过慢能够把事做好，所以叫事缓则圆，以缓找到方法，以圆作为皈依，这就是中国人的智慧。所以你要有毅力。 四、正确判断未来 上面讲的都是刚开始挣钱，怎样能挣到钱的故事。当一个企业已经发展得不错的时候，实际上也面临着更大的挑战，钱以外的能力，就是你对未来的看法，对社会的看法是不是准确。 我在公司已经做了17年董事长，没有做过一天经理。我发现我能干的工作并不多，但是很费神。因为我就干三件事情：第一，看别人看不见的地方；第二，算别人算不清的账；第三，做别人不做的事情。 这其实非常难。第一，你永远要看别人看不见的地方。当一个企业正常发展时，要看那些看不见的东西，包括风险、机会，很多我们还不知道的未来变化的趋势。这些工作需要企业的领导花很多时间。所以我经常说，我要跟神、跟先知做邻居，这样才能看见别人看不见的地方，我们要有一个方法去看趋势、模式、危险、机会，这些很重要。这些东西属于钱以外的东西，并不是说花多少钱就有这个能力，而是要长期去积累和研究去学习。 第二，算那些算不清的账。眼前最简单也最现实的是我们捐献灾区多少钱合适，社会的情绪，公众的期待跟捐多少钱有很大的关系。更复杂的账还有，比如说我们要找一个合作伙伴，可能有五个人站在你门口都可以给你钱，有土钱、洋钱，有笨钱、聪明钱，你找谁？土钱的特点是决策快、变化大、干预多；洋钱决策慢、按规则来、干预不多，但是该管你的地方，又决不妥协。所以作为一个企业、一个领导人，这种能力就是你怎么在算不清的账里找到确定。 第三，做别人不做的事。例如履行企业公民的责任，去救灾、去环保，做各种各样的事情。这些事情是经理人不太愿意做的事情，因为又占精力又要出钱，董事长就要做他们不做的事情。","tags":[{"name":"读者","slug":"读者","permalink":"http://yutaiwei.github.io/tags/读者/"},{"name":"冯仑","slug":"冯仑","permalink":"http://yutaiwei.github.io/tags/冯仑/"}]},{"title":"Node基础开发框架","date":"2016-09-04T06:15:26.000Z","path":"2016/09/04/Node基础开发框架/","text":"前言测试新功能，开发新项目，按照本人的懒惰程度推算，八成会在原有项目的基础上开发。既然如此，抽出来一个node基础框架，似乎是一个很好的想法。本框架保留了毕设的主体代码，删除了一些无关代码，并且会继续增减代码，逐渐完善。 nodebasea node framework designed for myselfversion: v1.0.0url: https://github.com/voidking/nodebase.git 作者相关author: haojin(voidking)e-mail: voidking@qq.comsite: http://www.voidking.com 开发环境说明1、安装5.6.0以上Node2、安装mongodb，不要配置密码3、安装sass4、全局安装bower5、全局安装supervisor6、全局安装node-inspector7、全局安装puer8、运行前执行命令12npm installbower install node实时调试命令12node-inspector --web-port=8888node --debug app.js 运行命令node app.js，访问http://localhost","tags":[{"name":"node","slug":"node","permalink":"http://yutaiwei.github.io/tags/node/"}]},{"title":"地铁站里的实验","date":"2016-08-17T02:17:06.000Z","path":"2016/08/17/地铁站里的实验/","text":"作者：周云龙美国媒体二00七年的一个社会实验：一位男子在地铁站用小提琴演奏了巴赫的六首作品。他前面的地上，放一顶口子朝上的帽子。没有人知道，这位卖艺者是世界上最伟大的音乐家之一约夏．贝尔。他演奏的是一首世上最复杂的作品，用的是一把价值三百五十万美元的小提琴……在约夏．贝尔演奏的四十五分钟里，大约二千人经过，只有六个人停下来听了一会儿，大约二十人给了钱就匆匆离开，他总共收到三十二美元。而两天前，约夏．贝尔在波士顿一家剧院演出，所有门票售罄，聆听他演奏同样的乐曲，平均得花二百美元…… 这个实验，给人什么启示？电视圈的朋友甲点评说，环境影响人的评判能力t，环境决定一切！乙补充说，平台太重要啦！丙举例说，不是江苏卫视这样的平台，会做出《非诚勿扰》那样炫目的舞台吗？孟非一个歪瓜裂枣型的主持人能出得来吗？他还可能有那么大的影响力吗？ 约夏．贝尔在地铁里的演奏，据说是《华盛顿邮报》主办的关于感知、品味和人的优先选择的社会实验的一部分。实验结束后，《华盛顿邮报》提出了几个问题：一、在一个普通的环境下，在一个不适当的时间内，我们能够感知到美吗？二、如果能够感知到的话，我们会停下来欣赏吗？三、我们会在意想不到的情况下认可天才吗 地铁站的这个实验，内涵很丰富，操作蛮简单，它不过是利用了人们的审美惯性：地铁站里演唱的，都是为生活所逼卖艺的流浪汉。事实上，为生活所逼卖艺的人群中也可能有音乐天才。但是，要让以工薪阶层为主的“地铁一族”在行色匆匆之中能做出准确的判断，那是中彩的概率。说实话，高雅的音乐，本来就属于环境优雅的剧院，本来就属于自愿购票出入剧院的文人雅士。 美国地铁实验者最后得出的结论是：当世界上最好的音乐家，用世上最美的乐器来演奏世上最优秀的音乐时，如果我们连停留一会儿倾听都做不到的话，那么，在我们匆匆而过的人生中，我们又错过了多少其他东西呢？ 其实，与我们的错过相比，那些美好的人物、东西被错过，哪个更值得可惜呢？实验，可能只是虚拟的情境，但是，现实的生活中，就是现在，还很可能有?未被发现的音乐天才，正混迹于地铁站，任许多人走过、路过，也错过。 其实，一万人错过也无妨，但是，那双可以引导他走出地铁站走向大剧院的慧眼，不能错过。一个正常的健康的社会，也不该让他一直被错过。 身边的电视同行，常常有人拿“光头”孟非说事，我承认，平台确实很重要、环境也很重要。但是，要知道，孟非做过印刷厂工人，做过体育新闻的摄像记者，在这些并不引人关注的岗位上，就像有些昏暗、嘈杂的地铁站里，那么，谁最早发现了他的主持潜质？“发现”，有时倒还不难，又是谁最早大胆起用了没有主持经歷的他？他在民生新闻栏目做得如鱼得水之后，又是谁把他适时引入娱乐、综艺类节目的主持？主持转型一开始并不成功，可能还有好多非议吧，之后又是谁坚持继续给他试错的机会？ 或许，平台的“平”，核心价值可能就在于决策管理者的“水平”。所以，我在关注美国地铁站那个实验之后，最大的感触是，假定我路过那个地铁站了，假定我被音乐吸引了，停留了──我没有“错过”，而且我因为眼前的音乐人才而惊喜，因为他暂时的处境而纠结，那么，我又能有什么资格、有什么途径举荐他？接下来的问题更关键，在一个个更看重学歷、资歷、关系、背景的规则和潜规则设计里，又有谁愿意去重用他？谁能给他一个最适合的舞台？说到底，生活中的每一个个体，如何才能做有追求、有尊严的自主的人？ “我”错过又何妨？——只是错过了一道风景；“他”被错过情何堪！——或许错过的是一生。","tags":[{"name":"读者","slug":"读者","permalink":"http://yutaiwei.github.io/tags/读者/"},{"name":"周云龙","slug":"周云龙","permalink":"http://yutaiwei.github.io/tags/周云龙/"}]},{"title":"node中exports和module.exports的区别和联系","date":"2016-08-09T08:43:25.000Z","path":"2016/08/09/node中exports和module.exports的区别和联系/","text":"前言 exports只是module.exports的辅助方法。你的模块最终返回module.exports给调用者，而不是exports。exports所做的事情是收集属性，如果module.exports当前没有任何属性的话，exports会把这些属性赋予module.exports。如果module.exports已经存在一些属性的话，那么exports中所用的东西都会被忽略。最初时，exports是module.exports的一个引用。(exports=global.exports)=(self.exports=module.exports) exports正常导出1234// caculate.jsexports.add = function (a, b) &#123; return a+b;&#125; 1234567// main.jsvar caculate = require('./caculate');exports.runAdd = function(req, res)&#123; var num = caculate.add(5,4); console.log(num);&#125; 在main模块中，可以正常调用caculate模块中的add函数。因为exports是module.exports的一个引用，所以exports.add=function(){}这个操作，把add函数加到了module.exports指向的对象（函数也是对象）中。而main模块中获取到的，就是caculate的module.exports指向的对象，自然也获取到了add函数。 exports错误导出1234// caculate.jsexports = function (a, b) &#123; return a+b;&#125; 12345678// main.jsvar caculate = require('./caculate');exports.runAdd = function(req, res)&#123; console.log(caculate); //var num = caculate(5, 4); //console.log(num);&#125; 如上的导出方法是错误的，我们可以看到打印出的caculate是一个空对象{}。因为exports原本是module.exports的一个引用，后来指向了一个函数。而module.exports的指向的对象，初始值就是空对象{}，自始至终都没有这个空对象添加属性或函数。所以，当main模块中获取到caculate的module.exports指向的对象时，依然是一个空对象{}。 module.exports导出123456789101112131415// caculate.jsexports.add = function (a, b) &#123; return a+b;&#125;var caculate = &#123; delete: function(a, b)&#123; return a-b; &#125;, multiple: function(a, b)&#123; return a*b; &#125;&#125;;module.exports = caculate; 12345678// main.jsvar caculate = require('./caculate');exports.runDelete = function(req, res)&#123; //var num = caculate.add(5, 4); var num = caculate.delete(5, 4); console.log(num);&#125; 如上导出方法，在caculate的module.exports指向的对象中，不会包含add函数。虽然exports.add=function(){}向module.exports指向的空对象{}中添加了一个add函数，但是紧接着，module.exports指向的对象改变了！变成了caculate对象。 seajs中module.exports和returnseajs中的exports和module.exports的关系，和Node中相同。 在进行插件CMD模块化时，发现module.exports和return基本相同。下面写个小例子：1234567// plugin.jsdefine(function(require, exports, module)&#123; module.exports = function(jQuery)&#123; // require('another-plugin')(jQuery); // 依赖jQuery的插件代码 &#125;&#125;) 1234567// plugin.jsdefine(function(require, exports, module)&#123; return function(jQuery)&#123; // require('another-plugin')(jQuery); // 依赖jQuery的插件代码 &#125;&#125;) 123seajs.use(['jquery','plugin'],function($,plugin)&#123; plugin($);//初始化&#125;); 书签Modules Node.js v6.3.0 Manual &amp; Documentationhttps://nodejs.org/api/modules.html#modules_the_module_object module.exports 还是 exports？http://zihua.li/2012/03/use-module-exports-or-exports-in-node/ nodejs中export与module.export的区别 SeaJS 中的 exports 和模块加载http://www.tuicool.com/articles/Y3qmAj","tags":[{"name":"node","slug":"node","permalink":"http://yutaiwei.github.io/tags/node/"},{"name":"exports","slug":"exports","permalink":"http://yutaiwei.github.io/tags/exports/"}]},{"title":"AngularJS按需加载js","date":"2016-08-02T15:57:39.000Z","path":"2016/08/02/AngularJS按需加载js/","text":"前言Angular是一个单页面应用，随着系统的迭代，首屏代码会越来越大，所以对《AngularJS入门》中的代码进行改造，实现AngularJS可以按需加载js和css。 实现这个需求，有三个方案：1、利用requirejs。requirejs并不是按照angular规范开发的第三方插件，后期估计会有很多坑，放弃。 2、利用ui-router和ocLazyLoad。 每次“页面跳转”都要额外请求js并加载，浪费带宽增加页面加载时间，基本抛弃了预加载。 每一个路由都需要配置resolve属性，太low。 模块化程度太低，不利于以后代码移植和维护。 3、自己写需要的组件。最好的方案，然而技术要求太高，放弃。 综上，第三种方案暂时无法实现，放弃；第一种方案坑太多，放弃；第二种方案也不好，但是相对容易，而且是针对angular的插件，就它了。1234bower install angular#1.5.8bower install angular-ui-routerbower install oclazyloadbower install bootstrap 核心代码123456789101112131415161718192021222324252627282930313233&lt;!--dynamic/index.html--&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"zh\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;link rel=\"stylesheet\" href=\"bower_components/bootstrap/dist/css/bootstrap.min.css\"&gt; &lt;style&gt; body&#123; font-family: \"Microsoft Yahei\"; &#125; .navigator&#123; width: 500px;margin: 0 auto &#125; .navigator li&#123; color: #000;font-size: 14px; &#125; &lt;/style&gt; &lt;title&gt;按需加载js&lt;/title&gt;&lt;/head&gt;&lt;body ng-app=\"myApp\"&gt; &lt;ul class=\"navigator nav nav-pills\"&gt; &lt;li role=\"presentation\" class=\"active\"&gt;&lt;a href=\"#home\" ng-click=\"isActive($event)\"&gt;主页&lt;/a&gt;&lt;/li&gt; &lt;li role=\"presentation\" class=\"active\"&gt;&lt;a href=\"#page2\"&gt;Page2&lt;/a&gt;&lt;/li&gt; &lt;li role=\"presentation\" class=\"active\"&gt;&lt;a href=\"#page3\" ng-click=\"isActive($event)\"&gt;Page3&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div ui-view style=\"width: 500px;margin: 50px auto 0\"&gt;&lt;/div&gt;&lt;script src=\"bower_components/angular/angular.min.js\"&gt;&lt;/script&gt;&lt;script src=\"bower_components/angular-ui-router/release/angular-ui-router.min.js\"&gt;&lt;/script&gt;&lt;script src=\"bower_components/oclazyload/dist/ocLazyLoad.min.js\"&gt;&lt;/script&gt;&lt;script src=\"public/js/index.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/* *dynamic/public/js/index.js*/var myApp=angular.module(\"myApp\",[\"ui.router\",\"oc.lazyLoad\"]);myApp.config(function ($stateProvider,$urlRouterProvider) &#123; $urlRouterProvider.when(\"\",\"/home\"); $stateProvider.state('home',&#123; url:\"/home\", templateUrl: 'views/homepage.html', controller: 'homeController', resolve:&#123; loadMyCtrl:['$ocLazyLoad',function ($ocLazyLoad) &#123; return $ocLazyLoad.load(&#123; name:\"homeApp\", files:[\"public/js/homepage.js\"] &#125;) &#125;] &#125; &#125;); $stateProvider.state('page2',&#123; url:\"/page2\", templateUrl:'views/page2.html', resolve:&#123; loadMyCtrl:function ($ocLazyLoad) &#123; return $ocLazyLoad.load(&#123; name:'page2App', files:[\"public/js/page2.js\"] &#125;) &#125; &#125; &#125;) $stateProvider.state('page3',&#123; url:\"/page3\", templateUrl:'views/page3.html', resolve:&#123; loadMyCtrl:function ($ocLazyLoad) &#123; return $ocLazyLoad.load(&#123; name:'page3App', files:[\"public/js/page3.js\",\"public/js/page3-ext.js\"] &#125;) &#125; &#125; &#125;) &#125;); 12345&lt;!--dynamic/views/homepage.html--&gt;&lt;div id=\"home\" ng-controller=\"homeController\"&gt; &lt;h1&gt;首页&lt;/h1&gt; &#123;&#123;content&#125;&#125;&lt;/div&gt; 123456/* *dynamic/public/js/homepage.js*/angular.module('myApp').controller('homeController', function ($scope) &#123; $scope.content = '这是主页的内容';&#125;); 完整代码github自取：https://github.com/voidking/angulardemo/tree/master/dynamic 书签RequireJS官方文档http://requirejs.org/docs/start.html Dynamically Loading Controllers and Views with AngularJShttp://weblogs.asp.net/dwahlin/dynamically-loading-controllers-and-views-with-angularjs-and-requirejs angular应用如何实现按需加载http://www.alloyteam.com/2015/10/angular-application-how-to-load-on-demand/ 尝试通过AngularJS模块按需加载搭建大型应用（上）http://web.jobbole.com/86915/ 尝试通过AngularJS模块按需加载搭建大型应用（下）http://web.jobbole.com/87025/ angularjs ocLazyLoad分步加载js文件,angularjs ocLazyLoad按需加载jshttp://m.w2bc.com/article/158713 按需加载 AngularJS 的 Controllerhttp://beginor.github.io/2014/12/20/angularjs-controller-load-on-demand.html","tags":[{"name":"前端","slug":"前端","permalink":"http://yutaiwei.github.io/tags/前端/"},{"name":"angularjs","slug":"angularjs","permalink":"http://yutaiwei.github.io/tags/angularjs/"}]},{"title":"AngularJS 中的服务Provider","date":"2016-07-25T14:01:59.000Z","path":"2016/07/25/ngRoute 和 ui.router 的使用方法和区别/","text":"ngRoute 和 ui.router 的使用方法和区别在单页面应用中要把各个分散的视图给组织起来是通过路由机制来实现的。本文主要对 AngularJS 原生的 ngRoute路由模块和第三方路由模块 ui.router 的用法进行简单介绍，并做一个对比。 ngRoute使用方法1) 引入angular-route lib 无论是ngRoute还是ui.router，作为框架额外的附加功能，都必须以 模块依赖 的形式被引入。 1&lt;script src=\"lib/angular-route.js\"&gt;&lt;/script&gt; 2) 配置路由 123456789var app = angular.module('ngRouteApp', ['ngRoute']);app.config(function($routeProvider)&#123; $routeProvider .when('/Main', &#123; templateUrl: \"main.html\", controller: 'MainCtrl' &#125;) .otherwise(&#123; redirectTo: '/tabs' &#125;); 服务与指令ngRoute路由模块名 $routeProvider服务提供者，用来定义一个路由表，即地址栏与视图模板的映射，对应于ui.router 中的 urlRouterProvider和 stateProvider $route服务，完成路由匹配，并且提供路由相关的属性访问及事件，如访问当前路由对应的 Controller，对应于下面的$urlRouter和$state$routeParams 服务，保存了地址栏中的参数，对应于下面的$stateParams ng-view指令，用来在主视图中指定加载子视图的区域，对应于下面的 ui-view ui.router使用方法1) 引入 angular-ui-router lib 1&lt;script src=\"lib/angular-ui-router.min.js\"&gt;&lt;/script&gt; 2) 配置路由 12345678910var app = angular.module(\"uiRouteApp\", [\"ui.router\"]);app.config(function($urlRouterProvider, $stateProvider) &#123; $urlRouterProvider.otherwise(\"/index\"); $stateProvider .state(\"Main\", &#123; url: \"/main\", templateUrl: \"main.html\", controller: 'MainCtrl' &#125;) 服务与指令ui.router路由模块名 $urlRouterProvider 服务提供者，用来配置路由重定向$stateProvider服务提供者，用来配置路由$urlRouter 服务$state 服务，用来显示当前路由状态信息，以及一些路由方法（如：跳转）$stateParams服务，用来存储路由匹配时的参数 ui-view 指令，路由模板渲染，对应的 dom 相关联ui-sref指令，链接到特定状态 路由的创建基本配置调用$stateProvider.state(...)方法，并可配置以下参数 123456$stateProvider .state(\"Main\", &#123; url: \"/main\", templateUrl: 'main.html', controller: 'MainCtrl', &#125;) parent 有两种方式可以指定父子状态关系。 一种是，使用点标记法，像本文最后嵌套视图部分举得栗子那样： 1.state(\"tabs.tab1\", &#123;&#125;) 另一种是，使用 parent属性 123.state(\"tab1\", &#123; parent: 'tabs' // 也可是一个状态对象， parent: tabs&#125;) abstract 使用 abstract可以为所有的子状态提供一个基URL，这样做的好处就是可以在抽象出来的这个状态所对应的html 页面中来定义静态资源。抽象模板不能被激活。 12345678910$stateProvider .state('contacts', &#123; abstract: true, url: '/contacts', templateUrl: 'contacts.html', &#125;) .state('contacts.list', &#123; url: '/list', templateUrl: 'contacts.list.html' &#125;) resolve resolve在state配置参数中，是一个对象(key-value)，每一个 value都是一个可以依赖注入的函数，并且返回的是一个promise(当然也可以是值)。 123456resolve: &#123; 'myResolve': ['contacts', function(contacts)&#123; return contacts.all(); &#125;] &#125; 这样做的目的： 简化了 controller的操作，将数据的获取放在 resolve中进行，这在多个视图多个controller需要相同数据时，有一定的作用。 只有当reslove中的promise 全部resolved(即数据获取成功)后，才会触发$stateChangeSuccess切换路由，进而实例化controller，然后更新模板。 路由控制url动态部分被称为参数，有以下几种方式设置 1） 使用花括号的方式可以设置一个正则表达式规则的参数： 12//只会匹配 pageId 为1到8位的数字url: \"/pages/&#123;pageId:[0-9]&#123;1,8&#125;&#125;\" 可以通过?来指定参数作为查询参数 12//比如匹配 href=\"/page?type='new'\"url: \"/page?type\" 如果需要不止一个查询参数，用&amp;分隔： 12//比如匹配 ui-sref=\"page(&#123;type:'all', title:'test ui-router'&#125;)\"url: \"/page?type&amp;title\" 路由的查找匹配 angular 在刚开始的 $digest时，$rootScope 会触发$locationChangeSuccess事件（angular在每次浏览器hashchange 的时候也会触发 $locationChangeSuccess事件） ui.router监听了$locationChangeSuccess事件，于是开始通过遍历一系列 rules，进行路由查找匹配列表项 当匹配到路由后，就通过$state.transitionTo(state,...)，跳转激活对应的 state 最后，完成数据请求和模板的渲染 在视图中，建议使用 ui-sref=&quot;xxxState&quot;而不是 href=&quot;#/abc&quot;，这样做能减少一遍 rules循环的遍历，提升性能。 两者区别ngRoute模块是 Angular 自带的路由模块，而ui.router模块 是基于ngRoute模块 开发的第三方模块。 ui.router是基于state(状态)的， ngRoute 是基于 url的，ui.router模块 具有更强大的功能，主要体现在视图的嵌套方面。 嵌套视图页面某个动态变化区块中，嵌套着另一个可以动态变化的区块。 前面的栗子就是一个很好的业务场景。 在首页中包含一个动态区块： 1234&lt;body ng-app=\"ngRouteApp\"&gt; &lt;h3&gt;AngularJS UI-Router Tabs&lt;/h3&gt; &lt;div ng-view&gt;&lt;/div&gt;&lt;/body&gt; 在标签页中又包含动态区块：123456&lt;div&gt; &lt;span&gt;&lt;a href=\"#/tab1\"&gt;Page-1&lt;/a&gt;&lt;/span&gt; &lt;span&gt;&lt;a href=\"#/tab2\"&gt;Page-2&lt;/a&gt;&lt;/span&gt; &lt;span&gt;&lt;a href=\"#/tab3\"&gt;Page-3&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;&lt;div ng-view&gt;&lt;/div&gt; 一运行，报了一个这样的错误： RangeError: Maximum call stack size exceeded 发现浏览器崩溃了，因为 ng-view会陷入死循环，无限递归下去。 使用 ui.router 能很容易解决这个问题，因为它定义的路由有明确的父子关系，并通过ui-view 指令将子路由模版插入到父路由模板的 &lt;div ui-view&gt;&lt;/div&gt;中去，从而实现视图嵌套。看代码： 123456789$stateProvider .state(\"tabs\", &#123; url: \"/tabs\", templateUrl: \"pageTab.html\" &#125;) .state(\"tabs.tab1\", &#123; url: \"/tab1\", templateUrl: \"tab1.html\" &#125;) 其他区别ui-router（左） ： ngRoute（右） 应用程序内的一个区域 ： 应用程序中的 url 可以嵌套的层次结构 ： 只是平面层次结构 名称可以自定义 ： 名称只能是 url 通过名称或 url 导航 ： 只能通过 url 导航 可以存在多个视图（ui-view） ： 只能单一视图（ng-view） 可以填充任何视图 ： 只能填充一个视图 通过状态填充某一部件 ： 通过指令将填充某一部件参考： AngularJS ui-router (嵌套路由) angular的uiRouter服务学习","tags":[{"name":"前端","slug":"前端","permalink":"http://yutaiwei.github.io/tags/前端/"},{"name":"Angular","slug":"Angular","permalink":"http://yutaiwei.github.io/tags/Angular/"}]},{"title":"JavaScript书签","date":"2016-07-15T13:16:19.000Z","path":"2016/07/15/JavaScript书签/","text":"回调函数（callback）是什么？http://www.zhihu.com/question/19801131 读取JAVASCRIPT第一公民-函数http://www.cnblogs.com/YOUCAN/archive/2012/11/05/2754968.html 《JAVASCRIPT语言精髓与编程实践》，周爱民http://www.chnxp.com.cn/soft/2013-12/22670.html 无废话JavaScripthttp://blog.csdn.net/aimingoo/article/details/3022379 深入理解javascript原型和闭包http://www.cnblogs.com/wangfupeng1988/p/3977987.html JS的事件监听机制http://www.cnblogs.com/aji88/archive/2012/07/20/2600492.html js事件监听器用法实例详解http://www.jb51.net/article/67051.htm HTML 最佳实践http://www.imooc.com/article/3666 Node.JS编码规范指南教程：教你优雅地写JavaScript代码 前端JavaScript规范http://www.imooc.com/article/1402 为JavaScript程序员准备的10本免费书籍http://www.imooc.com/article/1767","tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yutaiwei.github.io/tags/Javascript/"},{"name":"书签","slug":"书签","permalink":"http://yutaiwei.github.io/tags/书签/"}]},{"title":"Node.js学习笔记（二）","date":"2016-07-12T11:30:27.000Z","path":"2016/07/12/Node.js学习笔记（二）/","text":"整理自：慕课网 伪造模板数据跑通前后端交互流程本篇博客用到的代码，小伙伴们直接复制粘贴就可以了，你们可知道小编一行行敲得多么辛苦T_T，复制粘贴前给个赞啊！ 工程结构1234567891011121314helloworld/ -bower_components/ -node_modules/ -views/ -includes/ -head.jade -header.jade -pages/ -index.jade -detail.jade -admin.jade -list.jade -layout.jade -app.js 操作步骤我们在上次helloworld工程的基础上接着做！1、在views文件夹下新建文件夹includes和pages2、在views文件夹下，删除index.jade，新建layout.jade，输入内容：123456789doctypehtml head meta(charset=\"utf-8\") title #&#123;title&#125; include ./includes/head body include ./includes/header block content 3、在includes文件夹下，新建文件head.jade和header.jade，分别输入内容：123link(href=\"/bootstrap/dist/css/bootstrap.min.css\",rel=\"stylesheet\")script(src=\"/jquery/dist/jquery.min.js\")script(src=\"/bootstrap/dist/js/bootstrap.min.js\") 12345.container .row .page-header h1 #&#123;title&#125; small 天印电影 4、在pages文件夹下，新建文件index.jade、detail.jade、admin.jade和list.jade，分别输入内容：1234567891011121314extends ../layoutblock content .container .row each item in movies .col-md-2 .thumbnail a(href=\"/movie/#&#123;item._id&#125;\") img(src=\"#&#123;item.poster&#125;\",alt=\"#&#123;item.title&#125;\") .caption h3 #&#123;item.title&#125; p: a.btn.btn-primary(href=\"/movie/#&#123;item._id&#125;\",role=\"button\") 观看预告片 123456789101112131415161718192021extends ../layoutblock content .container .row .col-md-7 embed(src=\"#&#123;movie.flash&#125;\",allowFullScreen=\"true\",quality=\"high\",width=\"720\",height=\"500\",align=\"middle\",type=\"application/x-shock\") .col-md-5 dl.dl-horizontal dt 电影名字 dd= movie.title dt 导演 dd= movie.doctor dt 国家 dd= movie.country dt 语言 dd= movie.language dt 上映年份 dd= movie.year dt 简介 dd= movie.summary 1234567891011121314151617181920212223242526272829303132333435363738394041424344extends ../layoutblock content .container .row form.form-horizontal(method=\"post\",action=\"/admin/movie/new\") .form-group label.col-sm-3.control-label(for=\"inputTitle\") 电影名字 .col-sm-10 input#inputTitle.form-control(type=\"text\",name=\"movie[title]\",value=\"#&#123;movie.title&#125;\") .form-group label.col-sm-3.control-label(for=\"inputDoctor\") 导演 .col-sm-10 input#inputTitle.form-control(type=\"text\",name=\"movie[doctor]\",value=\"#&#123;movie.doctor&#125;\") .form-group label.col-sm-3.control-label(for=\"inputCountry\") 国家 .col-sm-10 input#inputTitle.form-control(type=\"text\",name=\"movie[country]\",value=\"#&#123;movie.country&#125;\") .form-group label.col-sm-3.control-label(for=\"inputLanguage\") 语言 .col-sm-10 input#inputTitle.form-control(type=\"text\",name=\"movie[language]\",value=\"#&#123;movie.language&#125;\") .form-group label.col-sm-3.control-label(for=\"inputYear\") 上映年份 .col-sm-10 input#inputTitle.form-control(type=\"text\",name=\"movie[year]\",value=\"#&#123;movie.year&#125;\") .form-group label.col-sm-3.control-label(for=\"inputSummary\") 简介 .col-sm-10 input#inputTitle.form-control(type=\"text\",name=\"movie[summary]\",value=\"#&#123;movie.summary&#125;\") .form-group label.col-sm-3.control-label(for=\"inputPoster\") 海报地址 .col-sm-10 input#inputTitle.form-control(type=\"text\",name=\"movie[poster]\",value=\"#&#123;movie.poster&#125;\") .form-group label.col-sm-3.control-label(for=\"inputFlash\") 片源地址 .col-sm-10 input#inputTitle.form-control(type=\"text\",name=\"movie[flash]\",value=\"#&#123;movie.flash&#125;\") .form-group .col-sm-offset-2.col-sum-10 button.btn.btn-default(type=\"submit\") 录入 12345678910111213141516171819202122232425262728extends ../layoutblock content .container .row table.table.table-hover.table-bordered thead tr th 电影名称 th 导演 th 国家 th 上映年份 //- th 录入时间 th 查看 th 修改 th 删除 tbody each item in movies tr(class=\"item-id-#&#123;item._id&#125;\") td #&#123;item.title&#125; td #&#123;item.doctor&#125; td #&#123;item.country&#125; td #&#123;item.year&#125; //- td #&#123;moment(item.meta.createdAt).format('MM/DD/YYYY')&#125; td: a(target=\"_blank\",href=\"../movie/#&#123;item._id&#125;\") 查看 td: a(target=\"_blank\",href=\"../admin/update/#&#123;item._id&#125;\") 修改 td button.btn.btn-danger.del(type=\"button\",data-id=\"#&#123;item._id&#125;\") 删除 5、修改helloworld文件夹下app.js，主要是加入模拟数据，内容如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192var express = require('express');var path = require('path');var port = process.env.PORT || 3000 ;var app = express();app.set('views','./views/pages');app.set('view engine','jade');app.use(express.bodyParser());app.use(express.static(path.join(__dirname, 'bower_components')));app.listen(port);console.log('helloworld started on port ' + port);app.get('/', function(req, res)&#123; res.render('index',&#123; title:'首页', movies: [ &#123; title: '机械战警', _id: 1, poster: 'http://ihelloworld.qiniudn.com/%40%2Fimgs%2FiNJIT.jpg', &#125;, &#123; title: '机械战警', _id: 2, poster: 'http://ihelloworld.qiniudn.com/%40%2Fimgs%2FiNJIT.jpg', &#125; ] &#125;)&#125;)app.get('/movie/:id', function(req, res)&#123; res.render('detail',&#123; title:'详情页', movie: &#123; doctor: '未知', country: '美国', title: '机械战警', year: '2014', poster: 'http://ihelloworld.qiniudn.com/%40%2Fimgs%2FiNJIT.jpg', language: '英语', flash: 'http://player.youku.com/player.php/sid/XNjM3Njc3MTY4/v.swf', summary: '无', &#125; &#125;)&#125;)app.get('/admin/movie', function(req, res)&#123; res.render('admin',&#123; title:'后台录入页', movie: &#123; doctor: '', country: '', title: '', year: '', poster: '', language: '', flash: '', summary: '', &#125; &#125;)&#125;)app.get('/admin/list', function(req, res)&#123; res.render('list',&#123; title:'列表页', movies: [ &#123; _id: 1, doctor: '未知', country: '美国', title: '机械战警', year: '2014', poster: 'http://ihelloworld.qiniudn.com/%40%2Fimgs%2FiNJIT.jpg', language: '英语', flash: 'http://player.youku.com/player.php/sid/XNjM3Njc3MTY4/v.swf', summary: '无', &#125;, &#123; _id: 2, doctor: '未知', country: '美国', title: '机械战警', year: '2014', poster: 'http://ihelloworld.qiniudn.com/%40%2Fimgs%2FiNJIT.jpg', language: '英语', flash: 'http://player.youku.com/player.php/sid/XNjM3Njc3MTY4/v.swf', summary: '无', &#125; ] &#125;)&#125;) 报错处理至此，已经敲完了Scott大神给的代码，马上就能看到效果了，好激动！哎呦我靠！报错，我改！又报错，我再改！还报错……诶？坏了，改不出来了！记录错误如下：百度“nodejs使用app.use(express.bodyParser());出错”，得到如下结论：1、node.js和windows的兼容性不如POSIX操作系统，因此npm提供给windows的第三方模块较少。2、bodyParser以前是集成在express中的，现在需要单独安装。无论哪个结论，解决办法都是安装body-parser：1npm install body-parser 然后在代码中如下使用： var bodyParser = require(‘body-parser’);app.use(bodyParser.urlencoded({ extended: false }))app.use(bodyParser.json()); 即把app.js的内容修改为如下内容：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394var express = require('express');var path = require('path');var port = process.env.PORT || 3000 ;var app = express();var bodyParser = require('body-parser');app.set('views','./views/pages');app.set('view engine','jade');app.use(bodyParser.urlencoded(&#123; extended: false &#125;))app.use(bodyParser.json());app.use(express.static(path.join(__dirname, 'bower_components')));app.listen(port);console.log('helloworld started on port ' + port);app.get('/', function(req, res)&#123; res.render('index',&#123; title:'首页', movies: [ &#123; title: '机械战警', _id: 1, poster: 'http://ihelloworld.qiniudn.com/%40%2Fimgs%2FiNJIT.jpg', &#125;, &#123; title: '机械战警', _id: 2, poster: 'http://ihelloworld.qiniudn.com/%40%2Fimgs%2FiNJIT.jpg', &#125; ] &#125;)&#125;)app.get('/movie/:id', function(req, res)&#123; res.render('detail',&#123; title:'详情页', movie: &#123; doctor: '未知', country: '美国', title: '机械战警', year: '2014', poster: 'http://ihelloworld.qiniudn.com/%40%2Fimgs%2FiNJIT.jpg', language: '英语', flash: 'http://player.youku.com/player.php/sid/XNjM3Njc3MTY4/v.swf', summary: '无', &#125; &#125;)&#125;)app.get('/admin/movie', function(req, res)&#123; res.render('admin',&#123; title:'后台录入页', movie: &#123; doctor: '', country: '', title: '', year: '', poster: '', language: '', flash: '', summary: '', &#125; &#125;)&#125;)app.get('/admin/list', function(req, res)&#123; res.render('list',&#123; title:'列表页', movies: [ &#123; _id: 1, doctor: '未知', country: '美国', title: '机械战警', year: '2014', poster: 'http://ihelloworld.qiniudn.com/%40%2Fimgs%2FiNJIT.jpg', language: '英语', flash: 'http://player.youku.com/player.php/sid/XNjM3Njc3MTY4/v.swf', summary: '无', &#125;, &#123; _id: 2, doctor: '未知', country: '美国', title: '机械战警', year: '2014', poster: 'http://ihelloworld.qiniudn.com/%40%2Fimgs%2FiNJIT.jpg', language: '英语', flash: 'http://player.youku.com/player.php/sid/XNjM3Njc3MTY4/v.swf', summary: '无', &#125; ] &#125;)&#125;) 效果图吼吼，终于搞定了！有图有真相！ 结束操作过程中的其他小错误，在此不作记录，有任何问题欢迎留言！","tags":[{"name":"node.js","slug":"node-js","permalink":"http://yutaiwei.github.io/tags/node-js/"}]},{"title":"人因梦想而伟大","date":"2016-07-05T13:10:07.000Z","path":"2016/07/05/人因梦想而伟大/","text":"作者：雷军 2014年11月21日晚，雷军在北大团中央主办的“活力中国说——一刻大型公益演讲”启动仪式上发表了演讲。北大国家发展研究院BiMBA对该活动提供了学术支持。部分MBA、EMBA校友有幸与小米科技创始人雷军先生展开了一场短暂而精彩的交流。以下为演讲实录。 每一个屌丝都渴望像马云一样逆袭 昨天我在乌镇参加了全球互联网峰会，在这个会议上有马云，也有苹果公司的高级副总裁。主持人抛出了一个问题，说：“雷军，你说你有一个目标，要用五到十年的时间，做成智能手机市场份额的全球第一”。我忙着点头，我的确说过。但是他没有问我，他去问苹果公司的高管，说：你怎么看？这个苹果公司的高管也很厉害，他说：“Easy to Say, Hard to Do”（说起来简单，做起来难）。在那一刻，我觉得很尴尬，主持人说：“雷军，你怎么想？” 我冷静了一下，我说：“马云在阿里巴巴上市的那一刻，说过一句话，‘梦想还是要有的，万一实现了呢’？”我的演说水平远远没办法跟马云相比，马云的号召力和演说水平，我是望尘莫及。除了我湖北普通话之外，我觉得我一个做技术和作为理工科的人来说，跟他的口才比不了，因为马云也是毕业于非常非常有名的名校，不亚于北京大学，叫杭州师范大学，专门培养老师的，真的比我能说，尤其是我听了马云在上市的时候还讲过说：像他这样的都能成功的话，80%的中国人都可以成功，这个听得我们每个人都热血沸腾。他说“我高考几次落榜，好不容易上了杭州师范大学还找不到工作”。当然马云今天有资格讲这个话，讲得也特别震撼，每个人，尤其每一个屌丝都渴望像马云一样逆袭。 创业时，“十来个人，七八条枪，要去做手机，有谁相信我们能赢呢？” 讲完马云这句名言以后，我又补了一段话。我说四年多前小米刚刚创业，在中关村，十来个人，七八条枪，要去做手机，有谁相信我们能赢呢？手机这个行业是刀山火海，前面有三星，有苹果，后面有联想，有华为。我们看到摩托罗拉不行了，诺基亚也不行了，黑莓也不行了，连HTC也不行了，最近索尼也不行了。这个市场竞争极为激烈，一个正常人讲到智能手机，就觉得这个市场竞争很激烈。 三年杀到全国第一，总该有点“全球第一”的梦想 三年前我们的产品刚刚发布。仅仅用了三年时间，谁又想过这十来个人的小公司，用了不到三年时间，有苹果、有三星、有华为、有联想，在这个市场里面杀到了全中国第一，全球第三。当我们今天有这样的业绩，有这样的起跑线，我觉得我们总应该有一点点梦想，用五到十年时间杀到全球第一吧。对吗？原来我们至少排在一百名开外。 功成名就后，人生四十再出发 所以梦想还是要有的，那四年前我梦想的动力来源于哪里呢？其实办小米对我来说是一个很难很难的事情，为什么呢？是因为我在办小米之前有幸参与了金山软件的创办，今天我依然是金山软件的董事长和大股东，而且我还有幸办过一个电子商务公司，叫卓越网，后来卖给了亚马逊，应该来说我的人生也足够了。所以在金山IPO之后我退休了，还干了三四年的投资，而且做天使投资，业绩还不错，绝对能排上中国天使投资界的第一排，肯定没问题。 那你说做投资总不能天天这么操心吧，是什么样的动力使我下定决心去干这么累的一件事情呢？这件事真的很累。我在那个阶段，在我做天使投资、从金山退休的那个阶段，我有一天晚上从梦中醒来，我问了自己一个问题：我40岁了，在别人眼里功成名就，已经退休了，还干着人人都很羡慕的投资，我还有没有勇气去追寻我小时候的梦想？ 我觉得岁数越大，谈梦想越难。大家现在都是最有梦想的时候，你们到了40岁的时候还有梦想吗？面对残酷的现实，还有几个能笑对今天，笑对明天呢？我当时问我自己，我还有没有勇气去试一把，这么试下去风险很高，有可能身败名裂，有可能倾家荡产，而且更重要的是我在别人眼里已经是一个成功者，我需要冒这么大的风险去做这么艰难的一件事情吗？其实我真的犹豫了半年时间。最后我觉得这种梦想激励我自己一定要去赌一把，我说只有这样做，我的人生才是圆满的，至少当我老了的时候，我还可以很自豪地说：“我曾经有过梦想，我曾经去试过，哪怕输了”。所以我最后下定了决心办了小米。 当“雷布斯”遇见乔布斯，《硅谷之火》点燃梦想 办小米刚开始我认为我100%会输，我想的全部是我怎么死，我真的很庆幸，我们居然只用了三年，完成了一个连我自己都没法相信的结果。那么我的梦想是什么？我为什么会这样的梦想？ 是因为我跟大家同样岁数的时候，在我18岁的那一年，曾经青春年少，无意之中在图书馆看了一本书，改变了我一生。那是我大学一年级第一学期，我上的是武汉大学，我在我们武大的图书馆看了一本书，这本书叫《硅谷之火》，那是1987年。这本书讲述的是七十年代末、八十年代初，那些硅谷的英雄创业的故事，其中主要的篇章就是讲乔布斯的故事。乔布斯在七十年代末、八十年代初就代表着美国创业。 我记得九十年代的时候，比尔·盖茨很成功的时候，比尔·盖茨讲“我不过是乔布斯第二”，乔布斯在八十年代就已经如日中天。当时看了这本书，激动的我自己心情久久难以平静。我清晰的记得看了这本书以后，我在武汉大学的那个操场上，沿着那个400米的跑道走了一圈又一圈，走了好几个通宵，我怎么能塑造与众不同的人生？ 我想的更多的是说在我们中国这个土壤上，我们能不能像乔布斯一样办一家世界一流的公司？我觉得只有这样，你才无愧于你的人生，才会使你自己觉得人生是有价值、有意义、有追求的。当然，在二十六七年前的中国，条件比今天差很多，要做点事情远没有今天容易。 当我有这样的梦想以后，我认为说起来容易，做起来难——放到口头上是没有用的，怎么能够落实到实际学习和工作中？我当时给我的第一个计划，在二十六七年前，就是两年修完大学所有的课程。我真的是武汉大学在八十年代不多的两个双学位，而且我绝大部分的成绩应该都是优秀，几乎所有的课。我记得我的成绩在我们同学里面排到全年级第六，我们全年级一百多人。 所以怎么能够落实到第一个梦想？就是我能够在一个赛道上把学习学完，因为我认为你还是要有基本功的沉淀，有了第一个基本功的沉淀，我们又给出了第二个目标。大家说你有没有本事在一级学报上发篇论文？我就用两年的时间在一级学报上发篇论文，我说我一定要完成第二个目标。为了琢磨这个我在图书馆里面读了很多一级学报，到底发什么文章呢，他们到底在做什么。 所以，有梦想是件简单的事情，关键是有了梦想以后，你能不能把这个东西付诸实践，你怎么去实践，你怎么给自己设定一个又一个可行的目标？当然，有了这样的目标还是不够的，因为要成功不是一件简单的事情，他需要你长时间的坚韧不拔，百折不挠。就像我自己，到了我40岁退休了以后，我还有没有勇气去试一把？ 所以非常感谢我们组委会给了我这个机会，今天我可以很自豪的跟大家分享，我在40岁的时候没有忘记我18岁的梦想，我去试了。虽然我知道今天的小米说成功为时过早，说谈击败苹果为时过早，但是“梦想总是要有的吧，万一实现了呢”？ 人因梦想而伟大 我比大家大概大两轮，大20多岁，我也跟很多年轻人经常交流梦想。我自己特别特别喜欢一句话，叫做“人因梦想而伟大”。在下午我们讨论的时候，还有人说这是美国哪个总统讲的，是，我说是我抄来的，我觉得我们在这里的每个人，只要你有了梦想，你就变得与众不同。周星驰也讲过一句名言，叫“人没有梦想，和咸鱼有什么差别”。所以你关键要有梦想，有了梦想是你迈向成功的第一步，有了第一步以后，你一定要为自己的梦想去准备各种坚实的基础。 成功需要勤奋和把握机遇 那么谈到梦想的实现，我最近还有一句话挺出名的，也是我抄来的。叫“台风来的时候，猪都会飞”，听说过吗？就是说你要成功了，要找台风口，当台风飞过来的时候，猪都可以飞，是猪你都可以飞。 当然了，我其实想表达两层的意思，尤其是给在座的同学们，我觉得第一个：没有坚实的基本功，没有勤奋是成功不了的：第二个，有了勤奋，有了坚实的基础也不一定能成功。 还需要什么呢？还需要台风口。还需要把握大的发展机遇，把这个机遇把握好，抓住这个机会，你才有机会成功。那么小米把握的是什么机会呢？为什么这个台风这么厉害呢？ 其实小米精准的踏到了智能手机换机的时间，诺基亚不行了，苹果刚刚起来，小米应运而生，用了一套全新的模式，在短短三年时间里面成了中国第一。其实整个成长速度远超想象，小米三年做下来，今年大概有多大规模呢？今年大概销售6500万只手机，营业额大概会在700亿人民币到800亿人民币，这是一个三四年的创业公司。这个应该已经创造了全球的奇迹，这背后是什么呢？这背后是坚实的基本功和非常好的对时机的把握。 给北大学生的三条锦囊妙计 所以我自己工作了20多年，我对各位同学们的建议就是： 第一条，要有梦想。第二条，要设定Step by Step努力的目标，要制定阶段性的目标，不要着急。第三条，要重视机遇的重要性。我觉得很聪明的一些同学都觉得聪明加勤奋天下无敌，其实仅有聪明和勤奋是远远不够的，怎么把握时代的机遇，怎么在大方向上正确，我觉得这一点也非常关键。 所以今天只有短短的一刻钟，感谢两位老师给我省了这么多时间，我就简单的讲到这里，谢谢大家。 来源：北大国家发展研究院BiMBA","tags":[{"name":"读者","slug":"读者","permalink":"http://yutaiwei.github.io/tags/读者/"},{"name":"雷军","slug":"雷军","permalink":"http://yutaiwei.github.io/tags/雷军/"},{"name":"演讲","slug":"演讲","permalink":"http://yutaiwei.github.io/tags/演讲/"}]},{"title":"Node.js学习笔记（一）","date":"2016-07-05T12:30:31.000Z","path":"2016/07/05/Node.js学习笔记（一）/","text":"整理自：慕课网 helloworld工程的搭建技术及工具 node.js + mongodb(工具mongoose) + express + jade + moment.js + npm + jquery + bootstrap + grunt 我靠，那么多！淡定，暂时，咱们这个工程只要 node.js + express + jade 。 准备工作下载安装node.js。 工程结构123456helloworld/ -node_modules/ -bower_components/ -views/ -index.jade -app.js 上两张图，直观感受下： 具体操作新建helloworld文件夹在F盘下新建个文件夹叫做“ helloworld ”，然后打开命令提示符，cd命令进入F盘下的helloworld文件夹。 执行以下命令：12345npm install expressnpm install jadenpm install mongodbnpm install bower -gbower install bootstrap 查看文件夹看看helloworld文件夹，诶？结构和你给的不一样啊！那就对了，咱接着搞！ 新建文件在helloworld文件夹下，新建文件app.js，输入内容如下：12345678910111213var express = require('express');var port = process.env.PORT || 3000 ;var app = express();app.set('views','./views');app.set('view engine','jade');app.listen(port);console.log('helloworld started on port ' + port);app.get('/', function(req, res)&#123; res.render('index',&#123;title:'helloworld'&#125;);&#125;); 至于这段代码的意思，请自行观看视频哈！在views文件夹下，新建文件index.jade（这个文件就相当于html文件），输入内容如下：1234567doctypehtml head meta(charset=\"utf-8\") title #&#123;title&#125; body h1 #&#123;title&#125; 至此，大功告成！ 查看效果在helloworld文件夹下执行命令：1node app.js 在浏览器中打开：http://localhost:3000有没有看到“helloworld”这个出现在了浏览器上？没看到？请留言！PS：你也可以新建admin.jade，也输入和index.jade相同的代码。然后在app.js添加如下代码：123app.get('/admin/', function(req, res)&#123; res.render('admin',&#123;title:'admin'&#125;);&#125;); 访问地址：http://localhost:3000/admin/这时你会看到“admin”出现在了浏览器上！ 结束好了，今天的笔记就写到这里！有任何问题欢迎留言。","tags":[{"name":"node.js","slug":"node-js","permalink":"http://yutaiwei.github.io/tags/node-js/"}]},{"title":"人生三乐","date":"2016-06-15T13:07:04.000Z","path":"2016/06/15/人生三乐/","text":"作者：李银河 恋爱、读书、写作是人生三乐。恋爱时，人沉浸在激情之中，快乐感觉无以复加；读书时，人徜徉在智慧之中，心旷神怡；写作时，人寻寻觅觅，仿佛在寻宝的过程中，一旦有所收获，心花怒放，心情愉悦无与伦比。恋爱的机会可遇不可求。世界上好人很多，可不一定是你能对他产生激情的。人的情感、性情、经历、想法五花八门，不一定能够正好与你相遇，相知，相爱。所以一旦对某人产生激情之爱，务必珍惜，精心呵护，浸淫其中，最好能够保持终身。这当然是很不容易的事情，有太多偶然因素。但是万一有此幸运，快乐真是无与伦比。读书倒是可以完全随心所欲，只要有欲望，有时间，就可以在书林书海中尽情徜徉，沉入其中，乐不思蜀。虽然绝大多数的书都不值一读，但是真正的好书也足够人享用的了，尤其像我这样读书速度比较慢的（诵读速度），一本好书别人可以享用一天，我可以细细品尝三天。此生不必担忧把好书读尽，就像走进海盗的藏宝洞，满眼珍宝，享用不尽，快乐真是无与伦比。 写作则像探险，你不知道自己会写出什么，仿佛陷入一个迷宫，或者一个漆黑的洞穴，深一脚浅一脚，有时看到前面有一丝亮光，以为找到出路，一路发足狂奔，结果并没有走出去，心情不免沮丧。但是有时山重水尽疑无路，柳暗花明又一村，心中豁然开朗。看着自己的思绪像涓涓的流水，从内心的泉眼中汨汨涌出，晶莹剔透，绵绵不绝，那愉悦的感觉也是无与伦比。 无论生命还有多长时间，惟愿沉浸在恋爱、读书和写作之中。","tags":[{"name":"读者","slug":"读者","permalink":"http://yutaiwei.github.io/tags/读者/"},{"name":"李银河","slug":"李银河","permalink":"http://yutaiwei.github.io/tags/李银河/"}]},{"title":"关于程序员的经典语录","date":"2016-06-11T10:41:14.000Z","path":"2016/06/11/关于程序员的经典语录/","text":"原文来自：http://geek.csdn.net/news/detail/11487 关于程序员的经典语录A：借我1000块。B：拿去，1024，我给你凑了个整儿。 Programming is like sex: one mistake and you’re providing support for a lifetime. –Michael Sinz编程就像做爱，你得为一个错误提供一辈子的支持。 程序员对测试人员说：＂在我机器上没问题啊！＂ ＂我测试了一下，确实在我机器上没问题啊＂ 少壮不努力，老大写程序。 世界上只有两句真理： 人一定会死。 程序一定有 Bug. 如果你想动手开发什么全新技术，你不需要几百万美元的资金，你只需要在冰箱里面放满比萨和可乐，再有一台便宜的计算机，和为之献身的决心。——卡马克 做网站就像zuoai，首先你要懂得“How To Make Love”，简称HTML；如果觉得你对HTML已经精通了，你应该学学3P（ASP，PHP，JSP) 。。。 嫁人就嫁程序员，钱多话少死得早。","tags":[{"name":"语录","slug":"语录","permalink":"http://yutaiwei.github.io/tags/语录/"},{"name":"程序员","slug":"程序员","permalink":"http://yutaiwei.github.io/tags/程序员/"}]},{"title":"input绑定回车事件","date":"2016-06-10T02:26:43.000Z","path":"2016/06/10/input绑定回车事件/","text":"html部分：1&lt;input id=\"search-key\" type=\"text\" placeholder=\"请输入关键字\"&gt; JavaScript部分：1234567$('#search-key').keypress(function(event) &#123; var key = event.which; console.log(key); if(key == 13)&#123; //do something &#125;&#125;);","tags":[{"name":"前端","slug":"前端","permalink":"http://yutaiwei.github.io/tags/前端/"},{"name":"jquery","slug":"jquery","permalink":"http://yutaiwei.github.io/tags/jquery/"}]},{"title":"你要学习","date":"2016-06-09T01:50:15.000Z","path":"2016/06/09/你要学习/","text":"本文原作者不详，yutaiwei整理。 你要是天天一大早六点起床，吃顿好饭，奔去教室背两篇新三，八点坐直在教室的前排，使劲不分心地听完两节还是四节课，课间练字背单词看报纸，放学奔去食堂抢份好饭，吃完回宿舍，洗洗衣服拖拖地消化下…再听VOA，一倍速听完听1.5，1.5听完听2倍，听困了上床歇中觉，下午继续坐直在前排听完四节课，放学去食堂抢个馒头奔回寝室啃完，收拾好书包就去教室上自习，拼到十点半赶在关门前回宿舍，洗漱完了继续听VOA听新三，听累了看书，看累了上床睡觉。周六带一天干粮去泡死在图书馆，周日半天上街采购，半天整内务看闲书，晚上继续滚教室自习，想考北大清华耶鲁牛津的，周日就别放假，你还有个鬼空去迷茫，去忧伤啊！ 你要是想到以后吃不起肉，旅不起游，看不起最新大片，连买份三块钱的南方周末都要犹豫挣扎下，你还敢迷茫敢忧伤啊！你当你是少年维特啊，维特的烦恼之所以迷人，那是人家名字前还有少年两个字。你要是混到中年，住不起房，开不起车，泡不起妞，天天对着现实哼哼唧唧，鬼会去聆听你那”凄美感伤”的烦恼。你说说你都这么把年纪了，还玩什么淡淡的忧伤，深深的迷茫啊，再不拼命，毕业就要去要饭了，就算天上掉个馅饼，你还要比别人先发现张嘴去接着提前准备呢。你迷茫个鬼忧伤个死啊，看人家谈恋爱你羡慕什么，还怕以后找不到老婆吗，看人家拿offer满世界跑你眼红什么，没看到人家怎么呕心沥血苦尽甘来么。还不滚去啃书拼命去，上个P网，偷个P闲！ 寂寞。一个人早起晚睡不难，但在一群晚起早睡的人中早起晚睡不简单。没人陪你占座，没人陪你背书，没人陪你写作。学习就是孤独的。没人经常短信你，没人经常鼓励你，没人一直关注你。不管是打雷下雨下雹子还是刀子，都要早起前行去学习，你的伙伴会贪睡不去，但不可以是你。你的同桌室友饭友学友各种友都可以中途打断他们的计划，你不可以！你要学习。你一个人背着书包跑来跑去，你以为很傻很土很幼稚吗？别人笑，是羡慕，你笑，是自信。 欲望。想睡懒觉，想看电影，想吃大餐。但是他们都是花时间的事，占用学习时间的事。可以放假，可以休息。 可要是每天多睡2小时，一年就多睡掉30.4天，一个月没了。每天看两集电视，又是一个月没了。食堂，寝室，教室，你就只能去这三个地方。厕所你都要算好时间再去。 享乐。他去看演唱会了，他去唱K了，他们去开房了。都和我无关，因为我要学习。他们打游戏，他们蜜月旅游，都和我无关，因为我要学习。 你好意思一把年纪了还吃爸妈的么。你有touch nano shuffle iPhone macbook，是你挣的么?你穿Burberry喷Dior拎Prada，你儿子用什么?你爸给你买房买车，你付得起物管，付得起年检么？你穿什么，用什么，开什么，住什么，什么都不算。你读什么，看什么，想什么，做什么，什么都重要。 教室前排的帅哥在你来之前就在那GRE，你走了，他还在GRE。他GRE他GRE他GRE，你连六级的分都刷不高。 你智商不高，情商不高，各种商不高；你背景不够，资本不够，各种不够；你还不学习？ 你高中傻乎乎的把自己家的全套钥匙送给女朋友，你以为很浪漫很抒情很温柔很韩剧？你不学习，你连一个钥匙串都买不起。 你追求加内特詹姆斯科比麦蒂邓肯霍华德……你不学习，连一张季前赛门票都买不起。 你想去荷兰，想去普林斯顿，想去各种地方。你不学习，你就继续想吧。 别人花言巧语追女朋友，别人周末上街大包小包，别人假期飞来飞去。都不关我事，我要学习。 别人逃课，兼职，游戏，都不关我的事，我要学习。 你说我没智商，没背景，没资本。没关系，我要学习。 你说我固执，老套，OUT。没关系，我要学习。 所以，学习就是一件要耐的住寂寞放的下欲望舍的得享乐的事。你好意思那么懒那么不守时那么吃那么玩那么啰哩叭嗦不看书么！你好意思穿着各种签名在校园里面游荡，你好意思整天淘宝京东？ 你要学习，你要学习，你要学习！","tags":[{"name":"学习","slug":"学习","permalink":"http://yutaiwei.github.io/tags/学习/"},{"name":"励志","slug":"励志","permalink":"http://yutaiwei.github.io/tags/励志/"}]},{"title":"AngularJS 表单验证","date":"2016-06-02T14:01:59.000Z","path":"2016/06/02/AngularJS 表单验证/","text":"AngularJS 表单验证在使用 AngularJS 进行开发的时候，表单填写是一个很常见的需求，而表单验证又是比较让人头疼的部分，本文对此做一个总结。 在 Angular 的视图中使用的 form 已经不是 HTML 中的普通 form 了，而是一个被 Angular 封装过的指令。它可以完成普通 form 无法实现的功能，比如 form 嵌套，而且自带强大的验证功能。Angular 在对表单进行校验的时候会使用 ngModelController上的属性，如果不设置ng-model，则 Angular 无法知道form.$invalid 这个值是否为真。后面在自定义验证有对它的介绍。 本文在对表单的验证时使用了ng-messages，在文章最后也有对它的介绍。 input元素的type属性值： checkbox 创建一个复选框 email 创建一个接受邮件地址作为值的文本输入框 number 创建一个接收数值类型作为值的文本输入框 radio 创建一个单选框 text 创建一个接收任何值的标准文本输入框 url 创建一个接收URL作为值的文本输入框 监控表单的有效性 $pristine 如果用户没有与元素/表单产生交互，则返回true $dirty 如果用户与元素/表单产生过交互，则返回true $valid 当元素/表单内容的校验结果为有效时则返回true $invalid 当元素/表单内容的校验结果为无效时则返回true $error 提供校验错误的详情信息 原生表单验证在 form 层面，可以使用 ng-disabled来控制提交按钮的状态，在 form 表单项全部验证通过前不可点击，下面介绍一下通用的表单项验证选项。 input 验证选项AngularJS 的 input 标签 自带的验证选项有以下这些。 1234567891011&lt;input ng-model=\"\" [name=\"\"] [required=\"\"] [ng-required=\"\"] [ng-minlength=\"\"] [ng-maxlength=\"\"] [ng-pattern=\"\"] [ng-change=\"\"]&gt;...&lt;/input&gt; a. 必填 1&lt;input type=\"text\" name=\"myName\" ng-model=\"username\" required /&gt; 使用ng-required可以根据后面表达式的值设置是否 required。 在不满足required时form.myName.$error 为 {required: true} 。b. 长度 1&lt;input type=\"text\" name=\"myName\" ng-model=\"username\" ng-minlength=\"2\" ng-maxlength=\"10\" /&gt; 在不满足 ng-minlength/ng-maxlength时 form.myName.$error为 {minlength: true, maxlength: true}。 直接使用minlength/maxlength也有相同效果，而且 maxlength 可以设置最多输入 x 个字符，超过之后无法再输入。 c. 模式匹配 1&lt;input type=\"text\" name=\"myDesc\" ng-model=\"desc\" ng-pattern=\"/^[a-zA-Z]&#123;1,20&#125;$/\" /&gt; 在不满足 ng-pattern时 form.myName.$error为 {pattern: true}。 d. 其他 AngularJS 对特定格式也进行了校验。比如将 type设置为 url，email等，在没有特殊验证要求的情况下，可以直接使用这些自带的校验，或者通过自定义指令修改 Angular 内建验证器。不同 type 有不同的验证选项。 CSS ClassesAngular 会根据表单状态自动给表单和表单项添加以下几组样式： ng-valid 验证通过，与之相对的是ng-invalid-ng-valid-[key]通过自定义验证器添加的验证通过的值，与之相对的是ng-invalid-[key] ng-pristine未交互状态，与之相对的是 ng-dirty ng-touched未访问状态，与之相对的是ng-untouched ng-pending 满足 $asyncValidators的情况 这些在 ngModelController 的属性中都有对应值。 根据这些 class，可以为不同状态设置不同的样式，比如这样： 1234567input.ng-valid.ng-dirty &#123; border-color: #78FA89;&#125;input.ng-invalid.ng-dirty &#123; border-color: #FA787E;&#125; 自定义验证在 AngularJS 指令入门 一文中，提到过通过 require 属性和 controller 参数，可以实现指令之间的交互。那么，在自定义指令中使用 require: &#39;ngModel&#39;就可以使用 ngModel 指令的 controller 属性的实例了。 ngModelControllerngModel 提供了数据绑定、验证、CSS更新、数据格式化和编译等操作。下面简单介绍一下 ngModelController 常用的属性和方法。 核心属性a. $viewValue视图里的值 b. $modelValue数据模型里值 在 input事件触发的时候，$viewValue会同步到 $modelValue。默认情况下，这个是一旦 input中的内容有改变就触发。AngularJS 1.3 引入了 ng-model-options，可以让这个同步延迟到 blur 或者延迟一定的时间之后。 12&lt;input type=\"text\" name=\"username\" ng-model=\"username\" ng-model-options=\"&#123;updateOn:'blur'&#125;\"&gt;&lt;input type=\"text\" name=\"username\" ng-model=\"username\" ng-model-options=\"&#123; debounce: 500 &#125;\"&gt; 在$viewValue的值同步到 $modelValue时，会经过 $parsers、$validators 和 $asyncValidators三个核心管道（后两个是 AngularJS 1.3 以后新加的）进行处理，通过后才更新到 $modelValue上（如果验证器管道没通过，不会更新）。 核心管道a. $parsers改变视图值的格式，并更新的到模型（$viewValue -&gt; $modelValue），与之相对的是 $formatters，刚好反过来。 b. $validators用来添加同步验证器 c. $asyncValidators用来添加异步验证器 常用属性a. $error没有通过的验证器名称及对应的错误信息 b. $valid表单项是否都通过验证，都通过时为 true，与之相对的是$invalid c. $touched 表单项是否被访问过，如果获得过焦点，在失去时该值为 true，与之相对的是 $untouched d.$dirty 表示用户是否和表单项交互过（比如输入一些东西），只要有任何改变，该值为 true，与之相对的是 $pristine 常用方法a. $render定义视图具体的渲染方式 b. $setViewValue设置视图值（需要手动触发一个 $digest），使用场景是在自定义指令中监听自定义事件（比如使用具有回调的 jQuery 插件） ngMessagesng-messages是 AngularJS 1.3 提供的一个用来增强模版显示的模块，主要用在处理复杂的错误信息。 在以前的版本中，如果想处理错误信息的显示，可能需要定义一堆code再结合复杂的ng-if语句来实现。而且在输入同时满足多条错误规则的情况下，无法控制错误信息显示的优先级。这些，使用 ng-messages可以完美解决。 准备工作引入 angular-messages.js添加依赖：angular.module(&#39;app&#39;, [&#39;ngMessages&#39;]) 使用方法有两种使用方法，一是将ng-messages 当作属性指令使用：1234567&lt;form name=\"myForm\"&gt; &lt;input type=\"text\" ng-model=\"field\" name=\"myField\" required minlength=\"5\" /&gt; &lt;div ng-messages=\"myForm.myField.$error\"&gt; &lt;div ng-message=\"required\"&gt;必填&lt;/div&gt; &lt;div ng-message=\"minlength\"&gt;长度不够&lt;/div&gt; &lt;/div&gt;&lt;/form&gt; 这样会按照各个错误信息书写的先后顺序进行单一显示，如果想同时显示所有的错误信息，加个ng-messages-multiple： 1&lt;div ng-messages=\"myForm.myField.$error\" ng-messages-multiple&gt;&lt;/div&gt; 另一种是将 ng-messages 当作元素指令使用：1234&lt;ng-messages for=\"myForm.myField.$error\"&gt; &lt;ng-message when=\"required\"&gt;必填&lt;/ng-message&gt; &lt;ng-message when=\"minlength\"&gt;长度不够&lt;/ng-message&gt;&lt;/ng-messages&gt; 如果很多表单项的错误提示信息都一样，也可以把错误信息放在模版里，使用ng-messages-include指令来引用： 12&lt;div ng-messages=\"myForm.username.$error\" ng-messages-include=\"validateTemplate/error.html\"&gt;&lt;/div&gt; 错误模版文件： 12&lt;div ng-message=\"required\"&gt;必填&lt;/div&gt;&lt;div ng-message=\"minlength\"&gt;长度不够&lt;/div&gt;","tags":[{"name":"前端","slug":"前端","permalink":"http://yutaiwei.github.io/tags/前端/"},{"name":"Angular","slug":"Angular","permalink":"http://yutaiwei.github.io/tags/Angular/"}]},{"title":"AngularJS 中的服务Provider","date":"2016-05-25T14:01:59.000Z","path":"2016/05/25/AngularJS 中的服务Provider/","text":"AngularJS 中的服务Provider在一个分层良好的 Angular 应用中，Controller 这一层应该很薄。也就是说，应用里大部分的业务逻辑和持久化数据都应该放在 Service 里。 为此，理解 AngularJS 中的几个 Provider 之间的区别很有必要。Provider 创建的新服务都可以用来注入。包括： provider factory service constant value 另外，内建的服务$controller和$filter 也可以被注入，同时也可以使用这些服务来获得新的过滤器和控制器。 下面介绍一下各自的用法和 provider、factory、value 三者之间的区别。 provider用于产生一个可配置的 Service，由两部分组成。第一部分的变量和函数是可以在app.config函数中访问的，可以在它们被其他地方访问到之前来修改它们。定义方式如下： 1234app.provider('myProvider', function()&#123; var a = ''; var func = function()&#123;&#125;;&#125;) 在 app.config函数对 a进行修改： 123app.config(function(myProviderProvider)&#123; myProvider.a = 'hello world';&#125;) 这也是在有如此简单的 factory 的情况下还使用 provider 的原因。 第二部分的变量和函数是通过$get()函数返回的，可以在任何传入了该 provider 的控制器中进行访问的。 12345678app.provider('myProvider', function()&#123; this.$get = function()&#123; return &#123; foo: function()&#123;&#125;, a: a &#125; &#125;&#125;) factoryfactory 返回一个对象。只需要创建一个对象，为它添加属性，然后返回这个对象。在控制器中注入该 factory，即可使用它的所有属性。 123456app.factory('myFactory', function()&#123; var fac = &#123;&#125;; fac.a = 'hello world'; fac.foo = function()&#123;&#125;; return fac;&#125;) 看得出来，factory 的第二个参数就是 provider 中$get要对应的函数实现。 serviceservice 类似于一个构造器， 通过new关键字实例化对象，将一些属性和方法直接添加到 this上，在创建 service 对象时，this会被作为返回值返回。 123456app.service('myService', function()&#123; var a = ''; this.setA = function()&#123;&#125;; this.getA = function()&#123;&#125;; this.foo = function()&#123;&#125;;&#125;) 注入myService 的控制器可以访问到绑定在myService 中 this上的 setA(),getA() 和 foo()三个方法。 constantconstant 用于定义常量，一旦定义就不能被改变。可以被注入到任何地方，但是不能被装饰器(decorator)装饰。 app.constant(‘APP_KEY’, ‘a1s2d3f4’) value与 constant 一样，可以用来定义值。但与 constant 的区别是：可以被修改，可以被 decorator 装饰，不能被注入到 config 中。 app.value(‘version’, ‘1.0’) value 通常用来为应用设置初始值。 decorator比较特殊，它不是 provider 。它是用来装饰其他 provider 的，不过 constant 除外，因为从源码可以看出，constant 不是通过 provider()方法创建的。 下面是一个用 decorator 装饰 value 的栗子。 1234app.value('version', '1.0');app.decorator('version', function ($delegate) &#123; return $delegate + '.1';&#125;) 那如果要使用前面的myService service，但是其中缺少一个你想要的 greet 函数。可以修改 service 吗？答案是不行！但是可以装饰它： 12345app.decorator('myService', function($delegate)&#123; $delegate.greet = function()&#123; return \"Hello, I am a new function of 'myService'\"; &#125;&#125;) $delegate代表实际上的 service 实例。 装饰一个 service 的能力是非常实用的，尤其是当我们想要使用第三方的 service 时，此时不需要将代码复制到我们的项目中，而只需要进行一些修改即可。 什么时候使用 provider 而不用 factory ？provider 是 factory 的加强版。当需要一个可配置的 factory 的时候，使用 provider。 简单介绍一下 AngularJS 运行应用的过程，分两个阶段，config 阶段和 run 阶段。config 阶段是设置任何的 provider 的阶段。也是设置任何的指令，控制器，过滤器以及其它东西的阶段。在 run 阶段，AngularJS 会编译你的 DOM 并启动应用。 factory 和 service 的区别是什么？factory 是普通 function，而 service 是一个构造器(constructor)，这样 Angular 在调用 service 时会用 new 关键字，而调用 factory 时只是调用普通的 function，所以 factory 可以返回任何东西，而 service 可以不返回。 参考 AngularJS 之 Factory vs Service vs Provider 理解AngularJS中的Service类型 AngularJS中的Provider们：Service和Factory等的区别","tags":[{"name":"前端","slug":"前端","permalink":"http://yutaiwei.github.io/tags/前端/"},{"name":"Angular","slug":"Angular","permalink":"http://yutaiwei.github.io/tags/Angular/"}]},{"title":"总结ES6常用的新特性","date":"2016-04-15T15:11:23.000Z","path":"2016/04/15/总结ES6常用的新特性/","text":"ES6是即将到来的新版本JavaScript语言的标准，他给我们带来了更”甜”的语法糖（一种语法，使得语言更容易理解和更具有可读性，也让我们编写代码更加简单快捷），如箭头函数（=&gt;）、class等等。用一句话来说就是： ES6给我们提供了许多的新语法和代码特性来提高javascript的体验 不过遗憾的是，现在还没有浏览器能够很好的支持es6语法，点这里查看浏览器支持情况，所以我们在开发中还需要用babel进行转换为CommonJS这种模块化标准的语法。 因为下面我会讲到一些es6新特性的例子，如果想要运行试试效果的话，可以点这里去测试es6的代码。 es6常用特性列举然后我下面简单的介绍一些很常用的语法特性，如果想完整的了解ES6，我推荐大家点这里 定义函数我们先来看一个基本的新特性，在javascript中，定义函数需要关键字function，但是在es6中，还有更先进的写法，我们来看： es6写法： 123456var human = &#123; breathe(name) &#123; //不需要function也能定义breathe函数。 console.log(name + ' is breathing...'); &#125;&#125;;human.breathe('jarson'); //输出 ‘jarson is breathing...’ 转成js代码： 123456var human = &#123; breathe: function(name) &#123; console.log(name + 'is breathing...'); &#125;&#125;;human.breathe('jarson'); 很神奇对不对？这样一对比，就可以看出es6的写法让人简单易懂。别着急，下面还有更神奇的。 创建类我们知道，javascript不像java是面向对象编程的语言，而只可以说是基于对象编程的语言。所以在js中，我们通常都是用function和prototype来模拟类这个概念。 但是现在有了es6，我们可以像java那样’明目张胆’的创建一个类了： 12345678910class Human &#123; constructor(name) &#123; this.name = name; &#125; breathe() &#123; console.log(this.name + \" is breathing\"); &#125;&#125;var man = new Human(\"jarson\");man.breathe(); //jarson is breathing 上面代码转为js格式： 12345678function Human(name) &#123; this.name = name; this.breathe = function() &#123; console.log(this.name + ' is breathing'); &#125;&#125;var man = new Human('jarson');man.breathe(); //jarson is breathing 所以我们看到，我们可以像java那样语义化的去创建一个类。另外，js中的继承父类，需要用prototype来实现。那么在es6中，又有什么新的方法来实现类的继承呢？继续看： 假如我们要创建一个Man类继承上面的Human类，es6代码： 123456789101112class Man extends Human &#123; constructor(name, sex) &#123; super(name); this.sex = sex; &#125; info()&#123; console.log(this.name + 'is ' + this.sex); &#125;&#125;var xx = new Man('jarson', 'boy');xx.breathe(); //jarson is breathingxx.info(); //arsonis boy 代码很简单，不作赘述，可以使用文章里提到的在线工具去试试效果就能明白了。需要注意的是：super()是父类的构造函数。 模块在ES6标准中，javascript原生支持module了。将不同功能的代码分别写在不同文件中，各模块只需导出(export)公共接口部分，然后在需要使用的地方通过模块的导入(import)就可以了。下面继续看例子： 内联导出ES6模块里的对象可在创建它们的声明中直接导出，一个模块中可无数次使用export。 先看模块文件app.js： 1234567891011121314export class Human&#123; constructor(name) &#123; this.name = name; &#125; breathe() &#123; console.log(this.name + \" is breathing\"); &#125;&#125; export function run()&#123; console.log('i am runing');&#125;function eat() &#123; console.log('i am eating');&#125; 例子中的模块导出了两个对象：Human类和run函数， eat函数没有导出，则仍为此模块私有，不能被其他文件使用。 导出一组对象另外，其实如果需要导出的对象很多的时候，我们可以在最后统一导出一组对象。 更改app.js文件： 123456789101112131415class Human&#123; constructor(name) &#123; this.name = name; &#125; breathe() &#123; console.log(this.name + \" is breathing\"); &#125;&#125; function run()&#123; console.log('i am runing');&#125;function eat() &#123; console.log('i am eating');&#125;export &#123;Human, run&#125;; 这样的写法功能和上面一样，而且也很明显，在最后可以清晰的看到导出了哪些对象。 Default导出导出时使用关键字default，可将对象标注为default对象导出。default关键字在每一个模块中只能使用一次。它既可以用于内联导出，也可以用于一组对象导出声明中。 查看导出default对象的语法： 12345... //创建类、函数等等export default &#123; //把Human类和run函数标注为default对象导出。 Human, run &#125;; 无对象导入如果模块包含一些逻辑要执行，且不会导出任何对象，此类对象也可以被导入到另一模块中，导入之后只执行逻辑。如： 1import './module1.js'; 导入默认对象使用Default导出方式导出对象，该对象在import声明中将直接被分配给某个引用，如下例中的”app”。 1import app from './module1.js'; 上面例子中，默认./module1.js文件只导出了一个对象；若导出了一组对象，则应该在导入声明中一一列出这些对象，如： 1import &#123;Human, run&#125; from './app.js' let与const在我看来，在es6新特性中，在定义变量的时候统统使用let来代替var就好了，const则很直观，用来定义常量，即无法被更改值的变量。 123for (let i=0;i&lt;2;i++) &#123; console.log(i); //输出: 0,1&#125; 箭头函数ES6中新增的箭头操作符=&gt;简化了函数的书写。操作符左边为输入的参数，而右边则是进行的操作以及返回的值，这样的写法可以为我们减少大量的代码，看下面的实例： 1234let arr = [6, 8, 10, 20, 15, 9];arr.forEach((item, i) =&gt; console.log(item, i));let newArr = arr.filter((item) =&gt; (item&lt;10));console.log(newArr); //[6, 8, 9]; 上面的(item, i)就是参数，后面的console.log(item, i)就是回到函数要执行的操作逻辑。 上面代码转为js格式： 12345678var arr = [6, 8, 10, 20, 15, 9];arr.forEach(function(item, i) &#123; return console.log(item, i);&#125;);var newArr = arr.filter(function(item) &#123; return (item &lt; 10);&#125;);console.log(newArr); 字符串模版ES6中允许使用反引号 ` 来创建字符串，此种方法创建的字符串里面可以包含由美元符号加花括号包裹的变量${vraible}。看一下实例就会明白了： 1234//产生一个随机数let num = Math.random();//将这个数字输出到consoleconsole.log(`your num is $&#123;num&#125;`); 解构若一个函数要返回多个值，常规的做法是返回一个对象，将每个值做为这个对象的属性返回。在ES6中，利用解构这一特性，可以直接返回一个数组，然后数组中的值会自动被解析到对应接收该值的变量中。我们来看例子： 12345function getVal() &#123; return [1, 2];&#125;var [x,y] = getVal(); //函数返回值的解构console.log('x:'+x+', y:'+y); //输出：x:1, y:2 默认参数现在可以在定义函数的时候指定参数的默认值了，而不用像以前那样通过逻辑或操作符来达到目的了。 123456789101112function sayHello(name)&#123; var name=name||'tom'; //传统的指定默认参数的方式 console.log('Hello '+name);&#125;//运用ES6的默认参数function sayHello2(name='tom')&#123; //如果没有传这个参数，才会有默认值， console.log(`Hello $&#123;name&#125;`);&#125;sayHello();//输出：Hello tomsayHello('jarson');//输出：Hello jarsonsayHello2();//输出：Hello tomsayHello2('jarson');//输出：Hello jarson 注意： sayHello2(name=&#39;tom&#39;)这里的等号，意思是没有传这个参数，则设置默认值，而不是给参数赋值的意思。 ProxyProxy可以监听对象身上发生了什么事情，并在这些事情发生后执行一些相应的操作。一下子让我们对一个对象有了很强的追踪能力，同时在数据绑定方面也很有用处。 12345678910111213//定义被监听的目标对象let engineer = &#123; name: 'Joe Sixpack', salary: 50 &#125;;//定义处理程序let interceptor = &#123; set(receiver, property, value) &#123; console.log(property, 'is changed to', value); receiver[property] = value; &#125;&#125;;//创建代理以进行侦听engineer = new Proxy(engineer, interceptor);//做一些改动来触发代理engineer.salary = 70;//控制台输出：salary is changed to 70 对于处理程序，是在被监听的对象身上发生了相应事件之后，处理程序里面的方法就会被调用。 结语总的来说，虽然支持es6的情况到目前还不是很乐观，但es6的新语法特性让前端和后端的差异越来越小了，这是一个新时代的开始，我们必须要了解这些新的前沿知识，才能跟上时代的步伐。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yutaiwei.github.io/tags/javascript/"},{"name":"es6","slug":"es6","permalink":"http://yutaiwei.github.io/tags/es6/"}]},{"title":"仿淘宝图片放大器","date":"2016-04-04T12:55:17.000Z","path":"2016/04/04/仿淘宝图片放大器/","text":"原理两个盒子，盒子1放小图片，盒子2放对应的大图片。盒子1里的图片正常显示，盒子2里的图片隐藏。在盒子1的图片标签中，加入大图的数据链接。当鼠标在盒子1上移动时，通过鼠标在盒子1的位置计算出盒子2中应该显示的大图的部分。 以下代码中，利用到了jquery.jqzoom.js插件。 代码12345&lt;div id=\"preview\" class=\"spec-preview\"&gt; &lt;span class=\"jqzoom\"&gt; &lt;img jqimg=\"images/b1.jpg\" src=\"images/s1.jpg\" /&gt; &lt;/span&gt; &lt;/div&gt; 123$(function()&#123; $(\".jqzoom\").jqueryzoom(&#123;xzoom:380,yzoom:380&#125;);&#125;); 参考文档jquery.jqzoom.js图片放大镜http://www.cnblogs.com/sydeveloper/p/3796330.html ImageZoom 图片放大效果http://www.cnblogs.com/cloudgamer/archive/2010/04/01/ImageZoom.html jQuery-实现图片的放大镜显示效果 jquery插件 放大镜http://www.jq-school.com/Article.aspx?kid=41 jQzoom简介http://www.oschina.net/p/jqzoom?fromerr=tUayHgqO","tags":[{"name":"前端","slug":"前端","permalink":"http://yutaiwei.github.io/tags/前端/"},{"name":"插件","slug":"插件","permalink":"http://yutaiwei.github.io/tags/插件/"},{"name":"jQuery","slug":"jQuery","permalink":"http://yutaiwei.github.io/tags/jQuery/"}]},{"title":"总结js常用函数和常用技巧（持续更新）","date":"2016-03-06T15:16:27.000Z","path":"2016/03/06/总结js常用函数和常用技巧/","text":"学习和工作的过程中总结的干货，包括常用函数、常用js技巧、常用正则表达式、git笔记等。为刚接触前端的童鞋们提供一个简单的查询的途径，也以此来缅怀我的前端学习之路。PS：此文档，我会持续更新。 Ajax请求jquery ajax函数我自己封装了一个ajax的函数，代码如下：12345678910111213141516171819var Ajax = function(url, type success, error) &#123; $.ajax(&#123; url: url, type: type, dataType: 'json', timeout: 10000, success: function(d) &#123; var data = d.data; success &amp;&amp; success(data); &#125;, error: function(e) &#123; error &amp;&amp; error(e); &#125; &#125;);&#125;;// 使用方法：Ajax('/data.json', 'get', function(data) &#123; console.log(data);&#125;); jsonp方式有时候我们为了跨域，要使用jsonp的方法，我也封装了一个函数： 1234567891011121314151617181920212223242526272829303132function jsonp(config) &#123; var options = config || &#123;&#125;; // 需要配置url, success, time, fail四个属性 var callbackName = ('jsonp_' + Math.random()).replace(\".\", \"\"); var oHead = document.getElementsByTagName('head')[0]; var oScript = document.createElement('script'); oHead.appendChild(oScript); window[callbackName] = function(json) &#123; //创建jsonp回调函数 oHead.removeChild(oScript); clearTimeout(oScript.timer); window[callbackName] = null; options.success &amp;&amp; options.success(json); //先删除script标签，实际上执行的是success函数 &#125;; oScript.src = options.url + '?' + callbackName; //发送请求 if (options.time) &#123; //设置超时处理 oScript.timer = setTimeout(function () &#123; window[callbackName] = null; oHead.removeChild(oScript); options.fail &amp;&amp; options.fail(&#123; message: \"超时\" &#125;); &#125;, options.time); &#125;&#125;;// 使用方法：jsonp(&#123; url: '/b.com/b.json', success: function(d)&#123; //数据处理 &#125;, time: 5000, fail: function()&#123; //错误处理 &#125; &#125;); 常用正则验证表达式手机号验证1234var validate = function(num) &#123; var exp = /^1[3-9]\\d&#123;9&#125;$/; return exp.test(num);&#125;; 身份证号验证1var exp = /^[1-9]&#123;1&#125;[0-9]&#123;14&#125;$|^[1-9]&#123;1&#125;[0-9]&#123;16&#125;([0-9]|[xX])$/; ip验证1var exp = /^(\\d&#123;1,2&#125;|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d&#123;1,2&#125;|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d&#123;1,2&#125;|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d&#123;1,2&#125;|1\\d\\d|2[0-4]\\d|25[0-5])$/; 常用js函数返回顶部1234567891011$(window).scroll(function() &#123; var a = $(window).scrollTop(); if(a &gt; 100) &#123; $('.go-top').fadeIn(); &#125;else &#123; $('.go-top').fadeOut(); &#125;&#125;);$(\".go-top\").click(function()&#123; $(\"html,body\").animate(&#123;scrollTop:\"0px\"&#125;,'600');&#125;); 阻止冒泡12345678function stopBubble(e)&#123; e = e || window.event; if(e.stopPropagation)&#123; e.stopPropagation(); //W3C阻止冒泡方法 &#125;else &#123; e.cancelBubble = true; //IE阻止冒泡方法 &#125; &#125; 全部替换replaceAll1234var replaceAll = function(bigStr, str1, str2) &#123; //把bigStr中的所有str1替换为str2 var reg = new RegExp(str1, 'gm'); return bigStr.replace(reg, str2);&#125; 获取浏览器url中的参数值123var getURLParam = function(name) &#123; return decodeURIComponent((new RegExp('[?|&amp;]' + name + '=' + '([^&amp;;]+?)(&amp;|#|;|$)', \"ig\").exec(location.search) || [, \"\"])[1].replace(/\\+/g, '%20')) || null;&#125;; 深度拷贝对象12345678910111213function cloneObj(obj) &#123; var o = obj.constructor == Object ? new obj.constructor() : new obj.constructor(obj.valueOf()); for(var key in obj)&#123; if(o[key] != obj[key] )&#123; if(typeof(obj[key]) == 'object' )&#123; o[key] = mods.cloneObj(obj[key]); &#125;else&#123; o[key] = obj[key]; &#125; &#125; &#125; return o;&#125; 数组去重12345678910var unique = function(arr) &#123; var result = [], json = &#123;&#125;; for (var i = 0, len = arr.length; i &lt; len; i++)&#123; if (!json[arr[i]]) &#123; json[arr[i]] = 1; result.push(arr[i]); //返回没被删除的元素 &#125; &#125; return result;&#125;; 判断数组元素是否重复12345678var isRepeat = function(arr) &#123; //arr是否有重复元素 var hash = &#123;&#125;; for (var i in arr) &#123; if (hash[arr[i]]) return true; hash[arr[i]] = true; &#125; return false;&#125;; 生成随机数123function randombetween(min, max)&#123; return min + (Math.random() * (max-min +1));&#125; 操作cookie12345678910111213141516own.setCookie = function(cname, cvalue, exdays)&#123; var d = new Date(); d.setTime(d.getTime() + (exdays*24*60*60*1000)); var expires = 'expires='+d.toUTCString(); document.cookie = cname + '=' + cvalue + '; ' + expires;&#125;;own.getCookie = function(cname) &#123; var name = cname + '='; var ca = document.cookie.split(';'); for(var i=0; i&lt; ca.length; i++) &#123; var c = ca[i]; while (c.charAt(0) == ' ') c = c.substring(1); if (c.indexOf(name) != -1) return c.substring(name.length, c.length); &#125; return '';&#125;; 知识技巧总结数据类型underfined、null、0、false、NaN、空字符串。他们的逻辑非结果均为true。 闭包格式好处：避免命名冲突（全局变量污染）。 123(function(a, b) &#123; console.log(a+b); //30&#125;)(10, 20); 截取和清空数组123var arr = [12, 222, 44, 88];arr.length = 2; //截取，arr = [12, 222]; arr.length = 0; //清空，arr will be equal to []. 获取数组的最大最小值123var numbers = [5, 45822, 120, -215];var maxInNumbers = Math.max.apply(Math, numbers); //45822var minInNumbers = Math.min.apply(Math, numbers); //-215 浮点数计算问题10.1 + 0.2 == 0.3 //false 为什么呢？因为0.1+0.2等于0.30000000000000004。JavaScript的数字都遵循IEEE 754标准构建，在内部都是64位浮点小数表示。可以通过使用toFixed()来解决这个问题。 数组排序sort函数123456var arr = [1, 5, 6, 3]; //数字数组arr.sort(function(a, b) &#123; return a - b; //从小到大排 return b - a; //从大到小排 return Math.random() - 0.5; //数组洗牌&#125;); 1234567891011121314151617var arr = [&#123; //对象数组 num: 1, text: 'num1'&#125;, &#123; num: 5, text: 'num2'&#125;, &#123; num: 6, text: 'num3'&#125;, &#123; num: 3, text: 'num4'&#125;]; arr.sort(function(a, b) &#123; return a.num - b.num; //从小到大排 return b.num - a.num; //从大到小排&#125;); 对象和字符串的转换123var obj = &#123;a: 'aaa', b: 'bbb'&#125;;var objStr = JSON.stringify(obj); // \"&#123;\"a\":\"aaa\",\"b\":\"bbb\"&#125;\"var newObj = JSON.parse(objStr); // &#123;a: \"aaa\", b: \"bbb\"&#125; git笔记git使用之前的配置123451.git config --global user.email xxx@163.com2.git config --global user.name xxx3.ssh-keygen -t rsa -C xxx@163.com(邮箱地址) // 生成ssh4.找到.ssh文件夹打开，使用cat id_rsa.pub //打开公钥ssh串5.登陆github，settings － SSH keys － add ssh keys （把上面的内容全部添加进去即可） 说明：然后这个邮箱（xxxxx@gmail.com）对应的账号在github上就有权限对仓库进行操作了。可以尽情的进行下面的git命令了。 git常用命令1234567891011121314151617181、git config user.name / user.email //查看当前git的用户名称、邮箱2、git clone https://github.com/jarson7426/javascript.git project //clone仓库到本地。3、修改本地代码，提交到分支: git add file / git commit -m “新增文件”4、把本地库推送到远程库: git push origin master5、查看提交日志：git log -56、返回某一个版本：git reset --hard 1237、分支：git branch / git checkout name / git checkout -b dev8、合并name分支到当前分支：git merge name / git pull origin9、删除本地分支：git branch -D name10、删除远程分支： git push origin :daily/x.x.x11、git checkout -b mydev origin/daily/1.0.0 //把远程daily分支映射到本地mydev分支进行开发12、合并远程分支到当前分支 git pull origin daily/1.1.113、发布到线上： git tag publish/0.1.5 git push origin publish/0.1.5:publish/0.1.514、线上代码覆盖到本地： git checkout --theirs build/scripts/ddos git checkout --theirs src/app/ddos 结语希望本文总结的内容能给各位看官带来焕然一新的感觉。另外，如果你们有什么值得推荐的js技巧，欢迎在评论中补充，我可以收纳在本文中。 PS：此文档会持续新增内容。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yutaiwei.github.io/tags/javascript/"},{"name":"干货总结","slug":"干货总结","permalink":"http://yutaiwei.github.io/tags/干货总结/"}]},{"title":"jQuery书签","date":"2015-11-15T07:54:38.000Z","path":"2015/11/15/jQuery书签/","text":"从零开始学习jQuery (一) 开天辟地入门篇http://kb.cnblogs.com/page/46450/ jQuery APIhttp://jquery.cuishifeng.cn/ jQuery API资源专属下载页http://www.cuishifeng.cn/down.html jQuery基础课程http://www.imooc.com/learn/11 CodePlayerhttp://www.365mini.com/ html中offsetTop、clientTop、scrollTop、offsetTop各属性介绍http://blog.csdn.net/fswan/article/details/17238933 值得 Web 开发人员学习的20个 jQuery 实例教程http://www.cnblogs.com/lhb25/p/20-must-have-jquery-tutorials.html jQuery Mobilehttp://jquerymobile.com/ HTML5+JS手机web开发之jQuery Mobile初涉 10个优秀的jQuery Mobile主题http://caibaojian.com/10-best-free-jquery-mobile-theme.html","tags":[{"name":"书签","slug":"书签","permalink":"http://yutaiwei.github.io/tags/书签/"},{"name":"jquery","slug":"jquery","permalink":"http://yutaiwei.github.io/tags/jquery/"}]},{"title":"AngularJS入门篇","date":"2015-11-02T11:53:09.000Z","path":"2015/11/02/AngularJS入门篇/","text":"前言AngularJS是一个JavaScript框架，它通过指令扩展了HTML，且通过表达式绑定数据到 HTML。顺便一提，什么是框架？比如struts2、spring、hibernate、thinkphp、wordpress等等。那么，什么是组件？比如jdbc、jquery、swiper、layer、arttemplate等等。 一般来说，那些可复用的、用于简化开发工作的代码集合，大的叫框架，小的叫组件。有人说jquery是框架？当然可以，大小并没有明确边界。不要太纠结于概念，如无必要，勿增实体。 本文，主要学习归纳一下Angular的各种特性，包括双向数据绑定、定义应用和控制器、优化模板渲染延迟、自定义指令、作用域、HTTP请求获取数据、自定义服务、依赖注入、路由控制等。最后，会给出一个综合实例。 双向数据绑定单向数据绑定的原理：模板+数据=&gt;视图。目前大多数前端框架都是单向数据绑定，比如jQueryUI、BackBone、Flex。 双向数据绑定原理：模板+数据=&gt;视图，模板+视图=&gt;数据。 Angular采用的，就是双向数据绑定。 123456789101112131415&lt;!--helloworld.html--&gt;&lt;!DOCTYPE html&gt;&lt;html ng-app&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;双向数据绑定&lt;/title&gt; &lt;script src=\"http://code.angularjs.org/angular-1.0.1.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; Hello &#123;&#123;'World'&#125;&#125;!&lt;br/&gt; Your name: &lt;input type=\"text\" ng-model=\"yourname\" placeholder=\"World\"&gt; &lt;hr&gt; Hello &#123;&#123;yourname || 'World'&#125;&#125;!&lt;/body&gt;&lt;/html&gt; 定义应用和控制器angular对象，是Angular的根对象。类似于express框架中的express对象，类似于seajs框架的seajs对象，类似于浏览器的window对象。如果说angular对象是Angular中的班主任，那么应用（或者叫模块，app）就是Angular中的班长！而班主任不常出没，管事的就是班长。控制器（controller），就是普通同学小明，负责控制Angular应用程序中的数据。 123456789101112131415161718192021222324252627282930313233343536&lt;!--app.html--&gt;&lt;!DOCTYPE html&gt;&lt;html ng-app=\"myApp\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;定义应用和控制器&lt;/title&gt; &lt;style&gt; [ng\\:cloak], [ng-cloak], [data-ng-cloak], [x-ng-cloak], .ng-cloak, .x-ng-cloak &#123; display: none !important; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div ng-controller=\"myCtrl\"&gt; 名: &lt;input type=\"text\" ng-model=\"firstName\"&gt;&lt;br&gt; 姓: &lt;input type=\"text\" ng-model=\"lastName\"&gt;&lt;br&gt; &lt;br&gt; 姓名: &lt;span&gt;&#123;&#123;firstName + \" \" + lastName&#125;&#125;&lt;/span&gt;&lt;br&gt; 姓名2: &lt;span class=\"ng-cloak\"&gt;&#123;&#123;fullName()&#125;&#125;&lt;/span&gt;&lt;br&gt; 姓名3: &lt;span ng-bind=\"fullName()\"&gt;&lt;/span&gt; &lt;/div&gt; &lt;script src=\"http://code.angularjs.org/angular-1.0.1.min.js\"&gt;&lt;/script&gt; &lt;script&gt; var app = angular.module('myApp', []); app.controller('myCtrl', function($scope) &#123; $scope.firstName= \"John\"; $scope.lastName= \"Doe\"; $scope.fullName = function() &#123; return $scope.firstName + \" \" + $scope.lastName; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 优化模板渲染延迟在定义应用和控制器的例子中，我们看到，页面上先出现了表达式，之后才出现我们期望的结果。解决这个问题，常用的有两个办法。一个是使用ng-bind，另一个是添加ng-cloak样式。 自定义指令12345678910111213141516171819202122232425262728&lt;!--directive.html--&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;自定义指令&lt;/title&gt; &lt;script src=\"http://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js\"&gt;&lt;/script&gt; &lt;/head&gt;&lt;body ng-app=\"myApp\"&gt; &lt;runoob-directive&gt;&lt;/runoob-directive&gt; &lt;div runoob-directive&gt;&lt;/div&gt; &lt;div class=\"runoob-directive\"&gt;&lt;/div&gt; &lt;!-- 指令: runoob-directive --&gt; &lt;script&gt; var app = angular.module(\"myApp\", []); app.directive(\"runoobDirective\", function() &#123; return &#123; //restrict : \"A\", //restrict : \"C\", //restrict : \"M\", //replace : true, template : \"&lt;h1&gt;自定义指令!&lt;/h1&gt;\" &#125;; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 作用域12345678910111213141516171819202122232425262728&lt;!--scope.html--&gt;&lt;!DOCTYPE html&gt;&lt;html ng-app=\"myApp\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;作用域&lt;/title&gt; &lt;script src=\"http://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div ng-controller=\"myCtrl\"&gt; &lt;h1&gt;姓氏为 &#123;&#123;lastname&#125;&#125; 家族成员:&lt;/h1&gt; &lt;ul&gt; &lt;li ng-repeat=\"x in names\"&gt;&#123;&#123;x&#125;&#125; &#123;&#123;lastname&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; var app = angular.module('myApp', []); app.controller('myCtrl', function($scope, $rootScope) &#123; $scope.names = [\"Emil\", \"Tobias\", \"Linus\"]; $rootScope.lastname = \"Refsnes\"; &#125;); &lt;/script&gt; &lt;p&gt;注意 $rootScope 在循环对象内外都可以访问。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 上面的例子中，$scope的作用域为myCtrl这个ng-controller的范围，$rootScope的作用域为myApp这个ng-app的范围。 HTTP请求获取数据获取本地数据123456789101112131415161718192021222324&lt;!--http.html--&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;HTTP请求&lt;/title&gt; &lt;script src=\"http://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body ng-app=\"myApp\" &gt; &lt;div ng-controller=\"myCtrl\"&gt; &lt;h1&gt;欢迎你！&#123;&#123;username&#125;&#125;&lt;/h1&gt; &lt;/div&gt; &lt;p&gt; $http 服务向服务器请求信息，返回的值放入变量 \"username\" 中。&lt;/p&gt;&lt;script&gt; var app = angular.module('myApp', []); app.controller('myCtrl', function($scope, $http) &#123; $http.get(\"http.json\").then(function (response) &#123; $scope.username = response.data.username; &#125;); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; http.json中的内容为：123&#123; \"username\":\"voidking\" &#125; 需要注意的是，本例需要在服务器中访问。因为Angular的HTTP请求封装了XMLHttpRequest，而XMLHttpRequest的使用需要服务器环境。 获取服务器数据123456789101112131415161718192021222324252627282930313233343536373839&lt;!--http2.html--&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;HTTP请求服务器数据&lt;/title&gt; &lt;script src=\"http://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body ng-app=\"myApp\" &gt; &lt;div ng-controller=\"myCtrl\"&gt; &lt;h1&gt;欢迎你！&#123;&#123;username&#125;&#125;&lt;/h1&gt; &lt;/div&gt; &lt;p&gt; $http 服务向服务器请求信息，返回的值放入变量 \"username\" 中。&lt;/p&gt;&lt;script&gt; var app = angular.module('myApp', []); app.controller('myCtrl', function($scope, $http, $httpParamSerializer) &#123; $http(&#123; method:'POST', url:'/angulardemo/http.php', headers:&#123; 'Content-Type':'application/x-www-form-urlencoded' &#125;, dataType: 'json', data: $httpParamSerializer(&#123;username:'voidking'&#125;) &#125;).then(function successCallback(response) &#123; console.log(response.data); $scope.username = response.data.username; &#125;, function errorCallback(response) &#123; console.log(response.data); &#125;);; &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 新建http.php，内容如下：123456789&lt;?php $username = $_POST['username']; $result = array( 'code' =&gt; '0', 'ext' =&gt; 'success', 'username' =&gt; $username ); echo json_encode($result);?&gt; 自定义服务123456789101112131415161718192021222324252627282930313233343536373839&lt;!--service.html--&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;自定义Service&lt;/title&gt; &lt;script src=\"http://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body ng-app=\"myApp\" &gt; &lt;div ng-controller=\"myCtrl\"&gt; &lt;p&gt;自定义服务，用于转换16进制数：&lt;/p&gt; &lt;p&gt;255 的16进制是:&lt;/p&gt; &lt;h1&gt;&#123;&#123;hex&#125;&#125;&lt;/h1&gt; &lt;hr&gt; &lt;p&gt;在获取数组 [255, 251, 200] 值时使用过滤器:&lt;/p&gt; &lt;ul&gt; &lt;li ng-repeat=\"x in counts\"&gt;&#123;&#123;x | myFormat&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;script&gt; var app = angular.module('myApp', []); app.service('hexafy', function() &#123; this.myFunc = function (x) &#123; return x.toString(16); &#125; &#125;); app.controller('myCtrl', function($scope, hexafy) &#123; $scope.hex = hexafy.myFunc(255); $scope.counts = [255, 251, 200]; &#125;); app.filter('myFormat',['hexafy', function(hexafy) &#123; return function(x) &#123; return hexafy.myFunc(x); &#125;; &#125;]);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 当创建了自定义服务，并连接到应用上后，我们可以在控制器，指令，过滤器或其他服务中使用它。 依赖注入AngularJS 提供很好的依赖注入机制。什么是依赖注入？wiki 上的解释是：依赖注入（Dependency Injection，简称DI）是一种软件设计模式，在这种模式下，一个或更多的依赖（或服务）被注入（或者通过引用传递）到一个独立的对象（或客户端）中，然后成为了该客户端状态的一部分。该模式分离了客户端依赖本身行为的创建，这使得程序设计变得松耦合，并遵循了依赖反转和单一职责原则。与服务定位器模式形成直接对比的是，它允许客户端了解客户端如何使用该系统找到依赖。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293&lt;!--di.html--&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;AngularJS依赖注入&lt;/title&gt;&lt;/head&gt; &lt;body ng-app=\"mainApp\" &gt; &lt;h2&gt;AngularJS 简单应用&lt;/h2&gt; &lt;div ng-controller=\"CalcController\"&gt; &lt;p&gt;配置：&#123;&#123;constant&#125;&#125;&lt;/p&gt; &lt;p&gt;输入一个数字: &lt;input type = \"number\" ng-model = \"number\" /&gt;&lt;/p&gt; &lt;button ng-click = \"square()\"&gt;X&lt;sup&gt;2&lt;/sup&gt;&lt;/button&gt; &lt;p&gt;结果: &#123;&#123;result&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;hr&gt; &lt;div ng-controller=\"CalcController2\"&gt; &lt;p&gt;再输入一个数字: &lt;input type = \"number\" ng-model = \"number\" /&gt;&lt;/p&gt; &lt;button ng-click = \"square()\"&gt;X&lt;sup&gt;2&lt;/sup&gt;&lt;/button&gt; &lt;p&gt;结果: &#123;&#123;result&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script src=\"http://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js\"&gt;&lt;/script&gt;&lt;script&gt; var mainApp = angular.module(\"mainApp\", []); mainApp.config(function($provide) &#123; // 创建一个名叫MathService的provider $provide.provider('MathService', function() &#123; this.$get = function() &#123; var factory = &#123;&#125;; factory.multiply = function(a, b) &#123; return a * b; &#125; return factory; &#125;; &#125;); &#125;); // 创建一个名叫defaultInput的value mainApp.value(\"defaultInput\", 5); // 创建一个名叫constant的constant value mainApp.constant(\"constant\", \"constant value\"); // 将MathService、defaultInput、constant注入到控制器 mainApp.controller('CalcController', function($scope, MathService, defaultInput, constant) &#123; $scope.number = defaultInput; $scope.constant = constant; $scope.result = MathService.multiply($scope.number,$scope.number); $scope.square = function() &#123; $scope.result = MathService.multiply($scope.number,$scope.number); &#125; &#125;); /*--------以下是CalcController2的内容--------*/ // 创建一个名叫MathService2的factory mainApp.factory('MathService2', function() &#123; var factory = &#123;&#125;; factory.multiply = function(a, b) &#123; return a * b; &#125; return factory; &#125;); // 创建一个名叫CalcService2的service，并且注入MathService2 mainApp.service('CalcService2', function(MathService2)&#123; this.square = function(a) &#123; return MathService2.multiply(a,a); &#125; &#125;); // 将CalcService2注入到控制器 mainApp.controller('CalcController2',function($scope,CalcService2)&#123; $scope.number = 6; $scope.result = CalcService2.square($scope.number); $scope.square = function() &#123; $scope.result = CalcService2.square($scope.number,$scope.number); &#125; &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; provider()函数是用来创建provider对象的标准方法。 实际上，value()、constant()、factory()、service()全都是用来创建一个provider对象的方法，它们提供了一种方式来定义一个provider，而无需输入所有的复杂的代码。 路由控制AngularJS 路由允许我们通过不同的 URL 访问不同的内容。通过 AngularJS 可以实现多视图的单页Web应用（single page web application，SPA）。通常我们的URL形式为http://runoob.com/first/page ，但在单页Web应用中AngularJS 通过 # + 标记 实现，例如：123http://runoob.com/#/firsthttp://runoob.com/#/secondhttp://runoob.com/#/third 当我们点击以上的任意一个链接时，向服务端请的地址都是一样的 (http://runoob.com/)。 因为 # 号之后的内容在向服务端请求时会被浏览器忽略掉。 所以我们就需要在客户端实现 # 号后面内容的功能实现。 AngularJS 路由 就通过 # + 标记 帮助我们区分不同的逻辑页面并将不同的页面绑定到对应的控制器上。 AngularJS 模块的 config 函数用于配置路由规则。通过使用 configAPI，我们请求把$routeProvider注入到我们的配置函数并且使用$routeProvider.whenAPI来定义我们的路由规则。$routeProvider 为我们提供了 when(path,object) &amp; otherwise(object) 函数按顺序定义所有路由，函数包含两个参数:第一个参数是 URL 或者 URL 正则规则。第二个参数是路由配置对象。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!--router.html--&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"zh\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;路由控制&lt;/title&gt;&lt;/head&gt;&lt;body ng-app=\"ngRouteExample\" class=\"ng-scope\"&gt; &lt;div&gt; &lt;div id=\"navigation\"&gt; &lt;a href=\"#/home\"&gt;Home&lt;/a&gt; &lt;a href=\"#/about\"&gt;About&lt;/a&gt; &lt;/div&gt; &lt;div ng-view=\"\"&gt; &lt;/div&gt;&lt;script type=\"text/ng-template\" id=\"embedded.home.html\"&gt; &lt;h1&gt; Home &lt;/h1&gt;&lt;/script&gt;&lt;script src=\"http://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js\"&gt;&lt;/script&gt;&lt;script src=\"http://apps.bdimg.com/libs/angular-route/1.3.13/angular-route.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; angular.module('ngRouteExample', ['ngRoute']) .controller('HomeController', function ($scope, $route) &#123; $scope.$route = $route;&#125;) .controller('AboutController', function ($scope, $route) &#123; $scope.$route = $route;&#125;) .config(function ($routeProvider) &#123; $routeProvider. when('/home', &#123; templateUrl: 'embedded.home.html', controller: 'HomeController' &#125;). when('/about', &#123; templateUrl: 'about.html', controller: 'AboutController' &#125;). otherwise(&#123; redirectTo: '/home' &#125;); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 12&lt;!--about.html--&gt;&lt;h1&gt; About &lt;/h1&gt; 综合123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!--complex.html--&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"zh\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;综合实例&lt;/title&gt;&lt;/head&gt;&lt;body ng-app=\"ngRouteExample\" class=\"ng-scope\"&gt; &lt;div&gt; &lt;div id=\"navigation\"&gt; &lt;a href=\"#/page1\"&gt;Page1&lt;/a&gt; &lt;a href=\"#/page2\"&gt;Page2&lt;/a&gt; &lt;/div&gt; &lt;div ng-view=\"\"&gt; &lt;/div&gt;&lt;script src=\"http://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js\"&gt;&lt;/script&gt;&lt;script src=\"http://apps.bdimg.com/libs/angular-route/1.3.13/angular-route.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; var myApp = angular.module('ngRouteExample', ['ngRoute']); myApp.controller('Page1Controller', function ($scope, $route) &#123; $scope.$route = $route; $scope.content = '这是page1的内容'; &#125;); myApp.controller('Page2Controller', function ($scope, $route) &#123; $scope.$route = $route; $scope.content = '这是page2的内容'; &#125;) myApp.config(function ($routeProvider) &#123; $routeProvider. when('/page1', &#123; templateUrl: 'complex-page1.html', controller: 'Page1Controller' &#125;). when('/page2', &#123; templateUrl: 'complex-page2.html', controller: 'Page2Controller' &#125;). otherwise(&#123; redirectTo: '/page1' &#125;); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 12345&lt;!--complex-page1.html--&gt;&lt;div id=\"page1\" ng-controller=\"Page1Controller\"&gt; &lt;h1&gt;Page1&lt;/h1&gt; &lt;p&gt;&#123;&#123;content&#125;&#125;&lt;/p&gt;&lt;/div&gt; 12345&lt;!--complex-page2.html--&gt;&lt;div id=\"page2\" ng-controller=\"Page2Controller\"&gt; &lt;h1&gt;Page2&lt;/h1&gt; &lt;p&gt;&#123;&#123;content&#125;&#125;&lt;/p&gt;&lt;/div&gt; 后记至于输入验证、事件、动画、API等，本文不再讨论，用到时自行查阅文档。本文完整源码地址：https://github.com/voidking/angulardemo 记录一个hexo的坑：如果文中出现了双括号，而且双括号没有被代码块包含，那么解析会报错，无法生成页面。 查找到的解决办法：123&#123;% raw %&#125;内容&#123;% endraw %&#125; 经测试，无效，就用汉字代替好了。 书签AngularJS实战http://www.imooc.com/learn/156 AngularJS 教程 | 菜鸟教程http://www.runoob.com/angularjs/angularjs-tutorial.html AngularJS中文网http://www.apjs.net/ AngularJS中文社区http://angularjs.cn/ 图灵社区: 合集 : AngularJS入门教程http://www.ituring.com.cn/minibook/303 AngularJS: API: API Referencehttps://docs.angularjs.org/api ngCloakhttps://docs.angularjs.org/api/ng/directive/ngCloak AngularJS : Why ng-bind is better than 双括号 in angular?http://stackoverflow.com/questions/16125872/angularjs-why-ng-bind-is-better-than-in-angular Metronic3.3网页模板在线演示http://metronic.kp7.cn/ 框架到底是个什么东西？https://www.zhihu.com/question/32069908 理解AngularJS中的依赖注入http://sentsin.com/web/663.html Hexo的一个小BUG(Template render error)http://www.jianshu.com/p/738ebe02029b","tags":[{"name":"angular","slug":"angular","permalink":"http://yutaiwei.github.io/tags/angular/"},{"name":"前端","slug":"前端","permalink":"http://yutaiwei.github.io/tags/前端/"},{"name":"hexo","slug":"hexo","permalink":"http://yutaiwei.github.io/tags/hexo/"}]},{"title":"ES6对数组的扩展","date":"2015-10-23T11:57:30.000Z","path":"2015/10/23/ES6对数组的扩展/","text":"ECMAScript6对数组进行了扩展，为数组Array构造函数添加了from()、of()等静态方法，也为数组实例添加了find()、findIndex()等方法。下面一起来看一下这些方法的用法。 Array.from()Array.from()将类数组(array-like)对象与可遍历的对象转化为数组并返回。例如将dom节点集合转化为数组，以前我们可能都会这样写： 1234var divs = document.querySelectAll(\"div\");[].slice.call(divs).forEach(function (node) &#123; console.log(node);&#125;) 现在我们可以这样写： 1234var divs = document.querySelectAll(\"div\");Array.from(divs).forEach(function (node) &#123; console.log(node);&#125;) 上面两种写法基本上是相同的。 Array.from()也可以将ES6中新增的Set、Map等结构转化为数组： 12// 将Set结构转化为数组Array.from(new Set([1, 2, 3, 4])); // [1, 2, 3, 4] 12//将Map结构转化为数组Array.from(new Map([\"name\", \"zlw\"])); // [\"name\", \"zlw\"] 字符串既是类数组又是可遍历的，所以Array.from()也可将字符串转化为数组： 1Array.from(\"zlw\"); // [\"z\", \"l\", \"w\"] Array.from()还有两个可选参数，完整语法如下： 1Array.from(obj, mapFn, thisArg) mapFn其实就是数组的map方法，对数组的每个元素处理。thisArg是执行环境的上下文。Array.from(obj, mapFn, thisArg)等同于Array.from(obj).map(mapFn, thisArg)。 Array.of()Array.of()将其参数转化为数组。如： 1Array.of(1, 2, 3); // [1, 2, 3] 我们知道用Array构造函数也可以实现同样功能： 1Array(1, 2, 3) // [1, 2, 3] 他们的不同之处在于： 123Array.of(3); // [3]Array(3) // [undefined, undefined, undefined] 当传入一个参数时，Array.of()会返回只有一个元素的数组，而Array()会返回长度为传入参数而元素都为undefined的数组。 Array.prototype.fill()fill()方法用一个值填充数组给定开始和结束位置之间的的所有值，语法如下： 1fill(value, start, end) 参数start、end是填充区间，包含start位置，但不包含end位置。如果省略，则start默认值为0，end默认值为数组长度。如果两个可选参数中有一个是负数，则用数组长度加上该数来确定相应的位置。例： 123[1, 2, 3].fill(4) // [4, 4, 4][1, 2, 3].fill(4, 1, 2) // [1, 4, 3][1, 2, 3].fill(4, -3, -2) // [4, 2, 3] Array.prototype.find()与Array.prototype.findIndex()find()方法返回数组中符合条件的第一个元素，如果没有则返回undefind。语法如下： 1array.find(callback, context); 参数包括一个回调函数和一个可选参数(执行环境上下文）。回调函数会遍历数组的所有元素，直到找到符合条件的元素，然后find()方法返回该元素。例： 1234567[1, 2, 3, 4].find(function(el, index, arr) &#123; return el &gt; 2;&#125;) // 3[1, 2, 3, 4].find(function(el, index, arr) &#123; return el &gt; 4;&#125;) // undefined findIndex()方法与find()方法用法类似，返回的是第一个符合条件的元素的索引，如果没有则返回-1。例： 1234567[1, 2, 3, 4].findIndex(function(el, index, arr) &#123; return el &gt; 2;&#125;) // 2[1, 2, 3, 4].findIndex(function(el, index, arr) &#123; return el &gt; 4;&#125;) // -1 Array.prototype.entries()、Array.prototype.keys与Array.prototype.values()entries()、keys与values都返回一个数组迭代器对象。例： 1234567891011121314var entries = [1, 2, 3].entries();console.log(entries.next().value); // [0, 1]console.log(entries.next().value); // [1, 2]console.log(entries.next().value); // [2, 3]var keys = [1, 2, 3].keys();console.log(keys.next().value); // 0console.log(keys.next().value); // 1console.log(keys.next().value); // 2var valuess = [1, 2, 3].values();console.log(values.next().value); // 1console.log(values.next().value); // 2console.log(values.next().value); // 3 迭代器的next()方法返回的是一个包含value属性与done属性的对象，而value属性是当前遍历位置的值，done属性是一个布尔值，表示遍历是否结束。 我们也可以用for...of来遍历迭代器： 123456789101112131415for (let i of entries) &#123; console.log(i)&#125; // [0, 1]、[1, 2]、[2, 3]for (let [index, value] of entries) &#123; console.log(index, value)&#125; // 0 1、1 2、2 3for (let key of keys) &#123; console.log(key)&#125; // 0, 1, 2for (let value of values) &#123; console.log(value)&#125; // 1, 2, 3 Array.prototype.copyWithin()copyWithin()方法语法如下： 1arr.copyWithin(target, start, end = this.length) 最后一个参数为可选参数，省略则为数组长度。该方法在数组内复制从start(包含start)位置到end(不包含end)位置的一组元素覆盖到以target为开始位置的地方。例： 123[1, 2, 3, 4].copyWithin(0, 1) // [2, 3, 4, 4][1, 2, 3, 4].copyWithin(0, 1, 2) // [2, 2, 3, 4] 如果start、end参数是负数，则用数组长度加上该参数来确定相应的位置： 1[1, 2, 3, 4].copyWithin(0, -2, -1) // [3, 2, 3, 4] 需要注意copyWithin()改变的是数组本身，并返回改变后的数组，而不是返回原数组的副本。 数组推导(array comprehensions)数组推导就是利用for...of循环基于现有的数组生成新数组。例： 1[for (i of [1, 2, 3]) i * i] // [1, 4, 9] 数组推导允许使用if语句： 12345// 单个if语句[for (i of [1, 2, 3]) if (i &lt; 3) i] // [1, 2]//多重if语句[for (i of [1, 2, 3]) if (i &lt; 3) if (i &gt; 1) i] // [2] 需要注意的是for...of总是写在最前面。 数组推导也允许使用多重for..of循环： 1[for (i of [1, 2, 3]) for (j of [4, 5, 6]) i * j] // [4, 5, 6, 8, 10, 12, 12, 15, 18] 数组推导中还可以包含数组推导： 1[for (i of [1, 2, 3]) [for (j of [4, 5, 6]) i * j]] // [[4, 5, 6], [8, 10, 12], [12, 15, 18]] 各大浏览器对ES6的支持可以查看kangax.github.io/es5-compat-table/es6/。","tags":[{"name":"ES6","slug":"ES6","permalink":"http://yutaiwei.github.io/tags/ES6/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yutaiwei.github.io/tags/JavaScript/"}]},{"title":"前端开发常用插件","date":"2015-10-16T13:43:53.000Z","path":"2015/10/16/前端开发常用插件/","text":"前言最近在阅读公司官网的前端代码，使用了很多插件。挨个百度，简单记录下，看看他们都是干什么的。 jQuery UIjQuery UI API中文文档http://www.css88.com/jquery-ui-api/ SwiperSwiper是纯javascript打造的滑动特效插件，面向手机、平板电脑等移动终端。 Swiper能实现触屏焦点图、触屏Tab切换、触屏多图切换等常用效果。Swiper开源、免费、稳定、使用简单、功能强大，是架构移动终端网站的重要选择！ Swiper中文网http://www.swiper.com.cn/ 官网http://www.idangero.us/swiper/ BlockUIjQuery BlockUI Pluginhttp://malsup.com/jquery/block/ blockui githubhttps://github.com/malsup/blockui/ jQuery遮罩插件jQuery.blockUI.js简介http://bookshadow.com/weblog/2014/09/26/jquery-blockui-js-introduction/ email-autocompleteemail-autocompletehttps://github.com/10w042/email-autocomplete jQuery-AutocompletejQuery-Autocompletehttps://github.com/devbridge/jQuery-Autocomplete chosenchosenhttps://github.com/harvesthq/chosen Chosen (v1.4.2)http://harvesthq.github.io/chosen/ ajaxfileuploadjQuery插件之ajaxFileUploadhttp://www.cnblogs.com/kissdodog/archive/2012/12/15/2819025.html html2canvashtml2canvashttp://www.bootcdn.cn/html2canvas/ 百度地图百度地图APIhttp://lbsyun.baidu.com/ momentJavaScript 日期处理类库 Moment.js中文网http://momentjs.cn/ paginationjQuery Pagination pluginhttp://esimakin.github.io/twbs-pagination/ placeholderjquery-placeholderhttps://github.com/mathiasbynens/jquery-placeholder romeromehttp://spmjs.io/package/rome validationvalidation官方文档http://jqueryvalidation.org/documentation zeptoZepto is a minimalist JavaScript library for modern browsers with a largely jQuery-compatible API. zepto中文网http://www.zeptojs.cn/ tooltipsterA powerful, flexible jQuery plugin enabling you to easily create semantic, modern tooltips enhanced with the power of CSS. 官网http://iamceege.github.io/tooltipster/ lazyloadLazy Load Plugin for jQueryhttp://www.appelsiini.net/projects/lazyload lazyload项目地址：https://github.com/tuupola/jquery_lazyload MasonryMasonry官网http://masonry.desandro.com/ mosonry项目地址：https://github.com/desandro/masonry imageLoadedimagesLoaded官网http://imagesloaded.desandro.com/ imagesloaded项目地址：https://github.com/desandro/imagesloaded touch.jsTouch.js官网http://touch.code.baidu.com/ iscrolliScroll官网http://cubiq.org/iscroll-5 iScroll文档http://iscrolljs.com/ iScroll项目地址https://github.com/cubiq/iscroll 【iScroll源码学习00】模拟iScrollhttp://www.cnblogs.com/yexiaochai/p/3489676.html 后记优点：开发成本低、时间短；稳定性、兼容性良好。缺点：不懂原理，遇到问题不好解决。 提供给开发者的 20 款最棒的 jQuery Bootstrap 插件http://www.oschina.net/translate/20-best-jquery-bootstrap-plugins-for-developers","tags":[{"name":"前端","slug":"前端","permalink":"http://yutaiwei.github.io/tags/前端/"},{"name":"插件","slug":"插件","permalink":"http://yutaiwei.github.io/tags/插件/"}]},{"title":"JavaScript正则用法","date":"2015-09-15T04:37:03.000Z","path":"2015/09/15/JavaScript正则表达式/","text":"前言正则表达式（Regular Expression）主要是用来描述一个句法规则的模式。其实说的通俗一点，就是利用字符和元字符的组合，对一些符合既定句法的模式进行模糊匹配。它的主要功能是文本查询和字符串操作。本文讨论一下JavaScript中的正则表达式用法。 定义正则表达式1、定义正则表达式有两种形式，一种是普通方式，一种是构造函数方式。2、普通方式：var reg=/表达式/附加参数表达式：一个字符串，代表了某种规则，其中可以使用某些特殊字符，来代表特殊的规则，后面会详细说明。附加参数：用来扩展表达式的含义，目前主要有三个参数：g：代表可以进行全局匹配。i：代表不区分大小写匹配。m：代表可以进行多行匹配。上面三个参数，可以任意组合，代表复合含义，当然也可以不加参数。例子：12var reg=/a*b/;var reg=/abc+f/g; 3、构造函数方式：var reg=new RegExp(“表达式”,”附加参数”);其中“表达式”与“附加参数”的含义与上面那种定义方式中的含义相同。例子：12var reg=new RegExp(\"a*b\");var reg=new RegExp(\"abc+f\",\"g\"); 4、普通方式与构造函数方式的区别普通方式中的表达式必须是一个常量字符串，而构造函数中的表达式可以是常量字符串，也可以是一个js变量，例如根据用户的输入来作为表达式参数等等：1var reg=new RegExp(document.forms[0].exprfiled.value,\"g\"); 表达式模式1、表达式模式，是指表达式的表达方式与样式， 即 var reg=/表达式/附加参数 中的“表达式”怎样去描述？2、从规范上讲，表达式模式分为简单模式和复合模式。3、简单模式：是指通过普通字符的组合来表达的模式，例如1var reg=/abc0d/; 可见简单模式只能表示具体的匹配。4、复合模式：是指含有通配符来表达的模式，例如：1var reg=/a+b?\\w/; 其中的+、?和\\w都属于通配符，代表着特殊的含义。因此复合模式可以表达更为抽象化的逻辑。复合模式中各个通配符的含义及其使用请阅读下文给出的参考文档。 表达式操作1、表达式操作，在这里是指和表达式相关的方法，我们将介绍六个方法。2、表达式对象（RegExp）方法： （1）exec(str)，返回str中与表达式相匹配的第一个字符串，而且以数组的形式表现，当然如果表达式中含有捕捉用的小括号，则返回的数组中也可能含有()中的匹配字符串，例如：12var regx=/\\d+/;var rs=regx.exec(\"3432ddf53\"); 返回的rs值为：{3432}12var regx2=new RegExp(\"ab(\\d+)c\");var rs2=regx2.exec(\"ab234c44\"); 返回的rs2值为：{ab234c,234}另外，如果有多个合适的匹配，则第一次执行exec返回一个第一个匹配，此时继续执行exec，则依次返回第二个第三个匹配。例如：123var regx=/user\\d/g;var rs=regx.exec(\"ddduser1dsfuser2dd\");var rs1=regx.exec(\"ddduser1dsfuser2dd\"); 则rs的值为{user1}，rs1的值为{user2}，当然注意regx中的g参数是必须的，否则无论exec执行多少次，都返回第一个匹配。后面还有相关内容涉及到对此想象的解释。 （2）test(str)，判断字符串str是否匹配表达式，返回一个布尔值。例如：12var regx=/user\\d+/g;var flag=regx.test(\"user12dd\"); flag的值为true。 3、String对象方法 （1）match(expr)，返回与expr相匹配的一个字符串数组，如果没有加参数g，则返回第一个匹配，加入参数g则返回所有的匹配例子：123var regx=/user\\d/g;var str=\"user13userddduser345\";var rs=str.match(regx); rs的值为：{user1,user3} （2）search(expr)，返回字符串中与expr相匹配的第一个匹配的index值。例子：123var regx=/user\\d/g;var str=\"user13userddduser345\";var rs=str.search(regx); rs的值为：0 （3）replace(expr,str)，将字符串中匹配expr的部分替换为str。另外在replace方法中，str中可以含有一种变量符号$，格式为$n，代表匹配中被记住的第n的匹配字符串（注意小括号可以记忆匹配）。例子：123var regx=/user\\d/g;var str=\"user13userddduser345\";var rs=str.replace(regx,\"00\"); rs的值为：003userddd0045例子2：123var regx=/u(se)r\\d/g;var str=\"user13userddduser345\";var rs=str.replace(regx,\"$1\"); rs的值为：se3userdddse45对于replace(expr,str)方法还要特别注意一点，如果expr是一个表达式对象则会进行全局替换（此时表达式必须附加参数g，否则也只是替换第一个匹配），如果expr是一个字符串对象，则只会替换第一个匹配的部分，例如：123var regx=\"user\"var str=\"user13userddduser345\";var rs=str.replace(regx,\"00\"); rs的值为： 0013userddduser345 （4）split(expr)，将字符串以匹配expr的部分做分割，返回一个数组，而且表达式是否附加参数g都没有关系，结果是一样的。例子：123var regx=/user\\d/g;var str=\"user13userddduser345\";var rs=str.split(regx); rs的值为：{3userddd,45} 表达式相关属性1、表达式相关属性，是指和表达式相关的属性，如下面的形式：12var regx=/myexpr/;var rs=regx.exec(str); 其中，和表达式自身regx相关的属性有两个，和表达式匹配结果rs相关的属性有三个，下面将逐一介绍。2、和表达式自身相关的两个属性： （1）lastIndex，返回开始下一个匹配的位置，注意必须是全局匹配（表达式中带有g参数）时，lastIndex才会有不断返回下一个匹配值，否则该值为总是返回第一个下一个匹配位置，例如：1234567var regx=/user\\d/;var rs=regx.exec(\"sdsfuser1dfsfuser2\");var lastIndex1=regx.lastIndex;rs=regx.exec(\"sdsfuser1dfsfuser2\");var lastIndex2=regx.lastIndex;rs=regx.exec(\"sdsfuser1dfsfuser2\");var lastIndex3=regx.lastIndex; 上面lastIndex1为9，第二个lastIndex2也为9，第三个也是9；如果regx=/user/d/g，则第一个为9，第二个为18，第三个为0。 （2）source，返回表达式字符串自身。例如：123var regx=/user\\d/;var rs=regx.exec(\"sdsfuser1dfsfuser2\");var source=regx.source; source的值为user\\d3、和匹配结果相关的三个属性： （1）index，返回当前匹配的位置。例如：1234567var regx=/user\\d/;var rs=regx.exec(\"sdsfuser1dfsfuser2\");var index1=rs.index;rs=regx.exec(\"sdsfuser1dfsfuser2\");var index2=rs.index; rs=regx.exec(\"sdsfuser1dfsfuser2\");var index3=rs.index; index1为4，index2为4，index3为4，如果表达式加入参数g，则index1为4，index2为13，index3会报错（index为空或不是对象）。 （2）input，用于匹配的字符串。例如：123var regx=/user\\d/;var rs=regx.exec(\"sdsfuser1dfsfuser2\");var input=rs.input; input的值为sdsfuser1dfsfuser2。 （3）[0]，返回匹配结果中的第一个匹配值，对于match而言可能返回一个多值的数字，则除了[0]外，还可以取[1]、[2]等等。例如：12345var regx=/user\\d/;var rs=regx.exec(\"sdsfuser1dfsfuser2\");var value1=rs[0];rs=regx.exec(\"sdsfuser1dfsfuser2\");var value2=rs[0]; value1的值为user1,value2的值为user2 实际应用1、实际应用一描述：有一表单，其中有一个“用户名”input域要求：汉字，而且不能少于2个汉字，不能多于4个汉字。实现：12345678910111213141516&lt;script&gt;function checkForm(obj)&#123; var username=obj.username.value; var regx=/^[\\u4e00-\\u9fa5]&#123;2,4&#125;$/g; if(!regx.test(username))&#123; alert(\"Invalid username!\"); return false; &#125; return true;&#125;&lt;/script&gt;&lt;form name=\"myForm\" onSubmit=\"return checkForm(this)\"&gt; &lt;input type=\"text\" name=\"username\"/&gt; &lt;input type=\"submit\" vlaue=\"submit\"/&gt;&lt;/form&gt; 2、实际应用二描述：给定一个含有html标记的字符串，要求将其中的html标记去掉。实现：1234567891011&lt;script&gt;function toPlainText(htmlStr)&#123; var regx=/&lt;[^&gt;]*&gt;|&lt;\\/[^&gt;]*&gt;/gm; var str=htmlStr.replace(regx,\"\"); return str;&#125;&lt;/script&gt;&lt;form name=\"myForm\"&gt; &lt;textarea id=\"htmlInput\"&gt;&lt;/textarea&gt; &lt;input type=\"button\" value=\"submit\" onclick=\"toPlainText(document.getElementById('htmlInput').value\"/&gt;&lt;/form&gt; 参考文档js正则表达式语法http://blog.csdn.net/zaifendou/article/details/5746988 正则表达式30分钟入门教程http://demo.voidking.com/reprint/正则表达式/正则表达式30分钟入门教程.htm 常用的正则表达式http://demo.voidking.com/reprint/正则表达式/常用的正则表达式.htm 正则表达式速查表http://demo.voidking.com/reprint/正则表达式/正则表达式速查表.htm 正则表达式测试器http://demo.voidking.com/reprint/正则表达式/正则表达式测试器.htm 正则表达式在线测试器详情请见：http://demo.voidking.com/reprint/regexpal/ deerchao大侠正则表达式原文地址http://www.jb51.net/tools/zhengze.html","tags":[{"name":"前端","slug":"前端","permalink":"http://yutaiwei.github.io/tags/前端/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yutaiwei.github.io/tags/JavaScript/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://yutaiwei.github.io/tags/正则表达式/"}]},{"title":"Cookie、localStorage和sessionStorage","date":"2015-08-03T03:18:09.000Z","path":"2015/08/03/Cookie、localStorage和sessionStorage/","text":"前言在《使用accessToken记录登录状态》一文中，已经讨论了Cookie的增删查改。本文详细探讨一下Cookie、localStorage和sessionStorage的概念差别，以及localStorage的用法。 CookieCookie的特点是小，只有4k，常用来存储辨别用户信息的数据，比如accessToken。而且，Cookie有数量限制，每个特定的域名下，最多生成50个Cookie（IE7+）。最大的优势是几乎所有的浏览器都支持。 localStoragelocalStorage 是 HTML5 标准中新加入的技术，拥有5M的存储空间，主流浏览器都支持。 存储123456789101112if(window.localStorage)&#123; var x = window.localStorage.userInfo? JSON.parse(window.localStorage.userInfo):&#123;&#125;; if((x.unionid == undefined) || (x.unionid == \"undefined\"))&#123; var temp = &#123; unionid: $('#unionid').val(), openid: $('#openid').val(), nickname: $('#nickname').val(), headimgurl:$ ('#headimgurl').val() &#125;; window.localStorage.userInfo = JSON.stringify(temp); &#125;&#125; 读取123var temp = (window.localStorage &amp;&amp; window.localStorage.userInfo)?JSON.parse(window.localStorage.userInfo):&#123;&#125;var unionid = temp.unionid;console.log(unionid); sessionStoragesessionStorage和localStorage非常相似，最主要的差别，是生命周期。localStorage除非被清除，否则永久保存；sessionStorage关闭页面或浏览器后被清除。 异同 特性 Cookie localStorage sessionStorage 数据的生命期 可设置失效时间，默认是关闭浏览器后失效 除非被清除，否则永久保存 仅在当前会话下有效，关闭页面或浏览器后被清除 存放数据大小 4K左右 一般为5MB 一般为5MB 与服务器端通信 每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题 仅在客户端（即浏览器）中保存，不参与和服务器的通信 仅在客户端（即浏览器）中保存，不参与和服务器的通信 易用性 需要程序员自己封装，源生的Cookie接口不友好 源生接口可以接受，亦可再次封装来对Object和Array有更好的支持 源生接口可以接受，亦可再次封装来对Object和Array有更好的支持 书签详说 Cookie, LocalStorage 与 SessionStoragehttps://segmentfault.com/a/1190000002723469 HTML5 localStorage本地存储实际应用举例 谈谈本地存储利弊Cookie、localStorage、sessionStoragehttp://www.tuicool.com/articles/fM32ier","tags":[{"name":"前端","slug":"前端","permalink":"http://yutaiwei.github.io/tags/前端/"},{"name":"html","slug":"html","permalink":"http://yutaiwei.github.io/tags/html/"}]},{"title":"flex布局详解","date":"2015-07-26T14:01:10.000Z","path":"2015/07/26/flex布局详解/","text":"flex布局flex可以指定对齐方式，可以解决所有盒子的对齐方式。并利用上页面中的剩余空间。 首先要给最外层的元素设置 12display:flex//或者display:inlineflex 设定主轴的方向 主轴默认是从左往右的方向 交叉轴默认是从上往下的，与主轴垂直。1flex-direction:row|row-reverse// 超出容器是否换行 1234flex-wrap: wrap;//超出后换行flex-wrap: wrap-reverse;//超出后换行 从下往上 复合属性 12flex-flow: column wrap;//超出后换行并且竖直方向排列 确定主轴的对齐方式 12justify-content: flex-end;//flex-start flex-space-ground flex-space-between 交叉轴对齐方式 1234align-items: flex-end;//在交叉轴方向从底部对齐align-items: baseline;//在交叉轴方向从文字基线对齐 设置子容器在父容器中的对齐方式 会覆盖 align-items的值1align-self: center; 处理交叉轴的空白空间 12align-content: flex-start;//对多行起作用，超出的部分会自动留白，并且向头部靠拢，单行使用 align-items 安排容器的排列顺序 - order 12order: -1;//默认值是0，值越小越在前面，可以为负值 基本步骤为： 设置布局方式 设定主轴方向 子元素超过父容器是否换行 确定子元素在主轴或者交叉轴的对齐方式 order安排子元素的排列顺序 核心属性 flex-grow 扩展比例：当盒子中有剩余空间时起作用 默认值0 flex-shrink 收缩比例：当有溢出内容时起作用 默认值是1 flex-basis 基准值：当扩展容器或者收缩容器 时以此值为基准 默认值为auto//基准值为auto时计算中会默认取宽度 溢出比例计算方式为父元素的总宽度 x 基准值的和 y 扩展比例的总和 k ，如果3个盒子每个扩展比例为a、b、c则每个盒子的宽度为(x-y)*a/k+每个盒子自己的基准值 收缩比例的计算方式为：每个子元素算上收缩比例的基准值/所有子元素算上收缩比例的基准值 = 收缩的内容/溢出的内容 ==注意如果有内容，不能收缩到小于自身内容的宽度==","tags":[{"name":"前端","slug":"前端","permalink":"http://yutaiwei.github.io/tags/前端/"},{"name":"css","slug":"css","permalink":"http://yutaiwei.github.io/tags/css/"}]},{"title":"css雪碧图","date":"2015-07-26T04:58:00.000Z","path":"2015/07/26/css雪碧图/","text":"前言CSS雪碧 即CSS Sprite，也有人叫它CSS精灵，是一种CSS图像合并技术，该方法是将小图标合并到一张图片上，然后利用css的背景定位来显示需要显示的图片部分。优点：减少加载网页图片时对服务器的请求次数，提高页面的加载速度，减少鼠标滑过的一些bug。 制作雪碧图的制作，可以使用PS，也可以使用专门的雪碧图制作工具。制作时，最好制作成一列或者一行，定位时会方便一些。下面这个工具挺好用，分享给大家：https://yunpan.cn/cMKygj2hnrBBe 访问密码 f516 css雪碧图简单制作工具（源码）https://github.com/iwangx/sprite 如果要制作svg雪碧图，推荐使用AI。 定位位置雪碧图定位的关键，在于background-position。诀窍在于“调试”，在页面控制背景图上下左右移动，很快就定位好了。 以上面的雪碧图为例，假设我们要显示微博的图标，那么scss代码如下： 123456.icon-weibo&#123; width: 20px; height: 20px; background: url(../../img/test/index/icon.png) no-repeat; background-position: 0px -60px;&#125; 大小假设我们的要显示的图标比雪碧图大，或者比雪碧图小，该怎么办？background-size。 1234567.icon-weibo&#123; width: 40px; height: 40px; background: url(../../img/test/index/icon.png) no-repeat; background-position: -2px -116px; background-size: 118%;&#125; 移动端很多时候，我们并不使用px作为单位，而是rem或者百分比，这时候，该怎么控制雪碧图的位置和大小？利用svg图片。 1&lt;span class=\"i i_menu_0\"&gt;&lt;/span&gt; 123456789101112.i &#123; width: 0.8rem; height: 0.8rem; background: url(../images/ico_global.svg) no-repeat; display: inline-block; background-size: 1100%;&#125;.i_menu_0 &#123; background-position: 0% 0%; &#125;.i_menu_1 &#123; background-position: 10% 0%; &#125;.i_menu_2 &#123; background-position: 20% 0%; &#125;.i_menu_3 &#123; background-position: 30% 0%; &#125;.i_menu_4 &#123; background-position: 40% 0%; &#125;.i_menu_5 &#123; background-position: 50% 0%; &#125; 后记至于PS和AI的使用，在慕课网和网易云课堂上有很多优秀教程，不要错过。 书签CSS雪碧图的实现方法（即背景定位）http://www.suixin8.com/59.html CSS3技术-雪碧图自适应缩放http://www.imooc.com/wiki/detail/id/183 利用动态viewport+rem制作一张自适应的svg雪碧图iconhttp://www.open-open.com/lib/view/open1452229325136.html SVG的用法http://www.webhek.com/svg/","tags":[{"name":"前端","slug":"前端","permalink":"http://yutaiwei.github.io/tags/前端/"},{"name":"css","slug":"css","permalink":"http://yutaiwei.github.io/tags/css/"}]},{"title":"纯CSS实现一个微信logo，需要几个标签？","date":"2015-07-26T03:13:24.000Z","path":"2015/07/26/纯css实现一个微信logo，需要几个标签？/","text":"纯CSS实现一个微信logo并不难，难的是怎样用最少的html标签实现。我一直在想怎样用一个标签就能实现，最后还是没想出来，就只好用两个标签了。 首先需要两个标签元素： 123&lt;div class=\"bg\"&gt; &lt;div class=\"inner\"&gt;&lt;/div&gt;&lt;/div&gt; 先画个背景： 1234567.bg &#123; width: 300px; height: 300px; background-color: #08c406; border-radius: 10px; position: relative;&#125; 再画个大的椭圆： 123456789.inner &#123; width: 180px; height: 150px; border-radius: 50%; background-color: #fff; position: absolute; top: 60px; left: 35px;&#125; 小的椭圆利用.inner的::before伪元素实现： 1234567891011&amp;::before &#123; content: \"\"; width: 140px; height: 120px; border-radius: 50%; background-color: #fff; position: absolute; top: 60px; left: 90px; border: 2px solid #08c406;&#125; 下图时现在的结果： 里面的四个圆怎么画呢？可以利用CSS3的box-shadow属性实现，一般重复性的东西都会用这个属性，因为它可以制造出无数个一模一样的东西出来。 利用.bg的::before伪元素实现这些圆： 123456789101112&amp;::before &#123; content: \"\"; position: absolute; width: 16px; height: 16px; border-radius: 50%; background-color: #08c406; top: 150px; left: 155px; z-index: 2; box-shadow: 70px 0 #08c406, -70px -50px 0 2px #08c406, 0 -50px 0 2px #08c406;&#125; ::before本身会实现一个圆(一个小圆),然后利用box-shadow属性实现其它的三个圆。 来看看现在的效果： 现在就剩下两个角了，想想还有哪些东西没用上？还有两个伪元素，分别是.bg的::after和.inner的::after，刚好可以实现两个角。 这两个角其实就是平常的小三角，然后再旋转个45度，CSS实现小三角太常见了： 123456789101112131415161718192021.bg::after &#123; content: \"\"; border-width: 30px 12px; border-style: solid; border-color: #fff transparent transparent transparent; position: absolute; top: 182px; left: 50px; transform: rotate(45deg);&#125;.inner::after &#123; content: \"\"; border-width: 30px 10px; border-style: solid; border-color: #fff transparent transparent transparent; position: absolute; top: 155px; left: 200px; transform: rotate(-45deg);&#125; 最终效果： 全部css代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960@mixin pos($left, $top) &#123; position: absolute; left: $left; top: $top;&#125;.bg &#123; width: 300px; height: 300px; background-color: #08c406; border-radius: 10px; position: relative; &amp;::before &#123; @include pos(155px, 150px); content: \"\"; width: 16px; height: 16px; border-radius: 50%; background-color: #08c406; z-index: 2; box-shadow: 70px 0 #08c406, -70px -50px 0 2px #08c406, 0 -50px 0 2px #08c406; &#125; &amp;::after &#123; @include pos(50px, 182px); content: \"\"; border-width: 30px 12px; border-style: solid; border-color: #fff transparent transparent transparent; transform: rotate(45deg); &#125; .inner &#123; width: 180px; height: 150px; border-radius: 50%; background-color: #fff; @include pos(35px, 60px); &amp;::before &#123; @include pos(90px, 60px); content: \"\"; width: 140px; height: 120px; border-radius: 50%; background-color: #fff; border: 2px solid #08c406; &#125; &amp;::after &#123; @include pos(200px, 155px); content: \"\"; border-width: 30px 10px; border-style: solid; border-color: #fff transparent transparent transparent; transform: rotate(-45deg); &#125; &#125;&#125; 画这个logo最难的地方应该就是实现四个小圆的时候，因为CSS3不太熟的人可能不会想到利用box-shadow去实现。 大家还有其它的方法实现微信logo吗？有没有一个标签就能实现的？欢迎留下你的实现方式。","tags":[{"name":"CSS3","slug":"CSS3","permalink":"http://yutaiwei.github.io/tags/CSS3/"},{"name":"微信Logo","slug":"微信Logo","permalink":"http://yutaiwei.github.io/tags/微信Logo/"}]},{"title":"JavaScript 基础--1","date":"2015-07-25T14:01:59.000Z","path":"2015/07/25/JavaScript 基础/","text":"基本语法数据类型null表示一个空的值，而undefined表示值未定义，然而区分两者的意义不大，大多数情况下都应该用 null，undefined 仅在判断函数参数是否传递的情况下有用。 字符串indexOf() 会搜索指定字符串出现的位置。substring(start, end)返回指定索引区间的子串。substr(start, length) 返回从start下标开始的指定数目的子串。 数组slice()是对应String的substring()版本，它截取Array的部分元素，然后返回一个新的Array。如果不给slice()传递任何参数，它就会从头到尾截取所有元素，利用这一点可以很容易复制一个Array。 push()向Array的末尾添加若干元素，pop()则把Array的最后一个元素删除掉。 如果要往Array的头部添加若干元素，使用unshift()方法，shift()方法则把Array的第一个元素删掉。 splice()方法是修改Array的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素。语法是：-splice（） 将原数组清空，将原数组内容以新数组形式返回。 splice（n） 从索引n开始，删除到最后，将删除部分以新数组返回，原数组改变。 splice（n，m） 从索引n开始，删除m项，将删除部分以新数组返回，原数组改变。 splice（n，m，x） 从索引n开始，删除m个，x替换删除部分，返回删除项，原数组改变。 splice（n，0，x） 从索引n开始，一个都不删除，返回空数组，将x增加到索引n的前面，原数组改变。 join()方法把当前Array的每个元素都用指定的字符串连接起来，然后返回连接后的字符串： 12var arr = ['A', 'B', 'C', 1, 2, 3];arr.join('-'); // 'A-B-C-1-2-3' 对象用in操作符可以检测对象是否拥有某一属性。 1234var obj = &#123; a: 'hello'&#125;;'a' in obj; //true 要判断一个属性是否是对象自身拥有的，而不是继承得到的，可以用hasOwnProperty()方法。 obj.hasOwnProperty(‘a’); // trueobj.hasOwnProperty(‘toString’); // false 循环for ... in 循环，可以把一个对象的所有属性依次循环出来，结合 hasOwnProperty()，还可以过滤掉对象继承的属性。 123456789var o = &#123; a: 'hello', b: 'world'&#125;;for (var key in o) &#123; if (o.hasOwnProperty(key)) &#123; alert(key); // 'hello', 'world' &#125;&#125; Map和SetMap 和 Set都是ES6引入的。 JavaScript的默认对象表示方式{} 可以视为其他语言中的Map或Dictionary的数据结构，即一组键值对，但有个问题，就是键必须是字符串。Map解决了这个问题。 初始化Map时直接赋值： 12var m = new Map([['aa', 11], ['bb', 22], ['cc', 33]]);m.get('bb'); //22 初始化一个空 Map： 1234567var m = new Map();m.set('dd', 44);m.set('ee', 55);m.has('ee'); //truem.get('ee'); //55m.delete('ee');m.get('ee'); //undefined Set是一组key的集合，但不存储value。由于key不能重复，所以，在 Set中，没有重复的key。 123var s = new Set([1, 2, 3]); s; //Set &#123;1, 2, 3&#125;s.add(4); //Set &#123;1, 2, 3, 4&#125; 遍历Map和Set可以用for...of循环： 12345678// 遍历Mapfor(var x of m)&#123; alert(x[0] + '=' + x[1]);&#125;// 遍历Setfor(var x of s)&#123; alert(x);&#125; 函数函数定义和调用函数定义 定义函数的方式有两种 一是函数声明： 123function sayA()&#123; alert('A');&#125; 二是函数表达式： 123var sayB = function()&#123; alert('B');&#125; 前者会在代码执行之前提前加载到作用域中，后者则是在代码执行到那一行的时候才会有定义（js奇葩的变量提升机制会将sayB提前，但它的赋值不会提前）。如果使用函数表达式定义，必须在定义后调用，否则会报function undefined。 JavaScript允许传入任意个参数而不影响调用。 arguments arguments只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数。 变量作用域 全局变量会绑定到window上，为减少冲突，可把自己的代码全部放入唯一的名字空间中。 123// 唯一的全局变量MYAPP:var MYAPP = &#123;&#125;;MYAPP.version = 1.0; JavaScript的变量作用域实际上是函数内部，无法在for循环等语句块中定义具有局部作用域的变量。ES6引入了新的关键字let可以申明一个块级作用域的变量。 123for (let i=0; i&lt;100; i++) &#123; sum += i;&#125; ES6中的新关键字const可以定义常量，并具有块级作用域。 高阶函数可以接收函数作为参数的函数称之为高阶函数。 下面以ES5中 Array 自带的几个高阶函数举例。 map() 对数组的每个元素进行一定操作（映射）后，会返回一个新的数组。 123456function pow(x) &#123; return x * x;&#125;var arr = [1, 2, 3, 4, 5];arr.map(pow); // [1, 4, 9, 16, 25] reduce() 把一个函数作用在这个Array的[x1, x2, x3…]上，这个函数必须接收两个参数，reduce()把结果继续和序列的下一个元素做累积计算，其效果就是： [x1, x2, x3, x4].reduce(f) = f(f(f(x1, x2), x3), x4) filter() 创建一个新的匹配过滤条件的数组。把传入的函数依次作用于每个元素，然后根据返回值是true还是false决定保留还是丢弃该元素。 比如把一个数组中的偶数全部删掉： 1234var arr = [1, 2, 4, 5, 6, 9, 10, 15];arr.filter(function (x) &#123; return x % 2 === 1;&#125;); // [1, 5, 9, 15] sort() Array的sort()方法默认把所有元素先转换为String再排序，但可以自定义一个排序规则，并以函数形式传入sort()中。 1234var arr = [10, 20, 1, 2];arr.sort(function (x, y) &#123; return x &gt; y ? 1 : -1&#125;); // [1, 2, 10, 20] forEach() 为每个元素执行对应的方法。 1234var arr = [10, 20];arr.forEach(function(item,index)&#123; console.log(item); //10 20&#125;); 标准对象几条规则 用 parseInt()或 parseFloat() 来转换任意类型到 number 用 String()来转换任意类型到string，或者直接调用某个对象的toString()方法 typeof操作符可以判断出number、boolean、string、function和 undefined 判断 Array要使用Array.isArray(arr) 判断null请使用 myVar === null Date获取当前系统时间： var now = new Date(); 创建一个指定日期和时间的Date对象： var d = new Date(2015, 5, 19, 20, 15, 30, 123);d; // Fri Jun 19 2015 20:15:30 GMT+0800 (CST) 另一种创建指定日期和时间的方法： 12345var d = Date.parse('2015-06-24T19:49:22.875+08:00');d; // 1435146562875// 将时间戳转换为一个Datevar d = new Date(1435146562875);d; // Wed Jun 24 2015 19:49:22 GMT+0800 (CST) 获取当前时间戳的方法： 1234567var time = new Date();//换取当前系统时间var year = time.getFullYear();//获取年 如：2017var month = time.getMonth() + 1;//获取月份，因为从0开始，所以加1var day = time.getDate();//获取天var hours = time.getHours();//时var minutes = time.getMinutes();//分var seconds = time.getSeconds();//秒 JSON概念在JSON中，一共就这么几种数据类型：number、boolean、string、null、array和object。 JSON规定字符集必须是UTF-8，因此不存在多语言问题。为了统一解析，JSON的字符串规定必须用双引号””，Object的键也必须用双引号””。 把任何JavaScript对象变成JSON，就是把这个对象序列化成一个JSON格式的字符串，这样才能够通过网络传递给其他计算机。 收到一个JSON格式的字符串，只需要把它反序列化成一个JavaScript对象，就可以在JavaScript中直接使用这个对象了。 序列化 JSON.stringify(obj) 可以把obj对象序列化成JSON格式的字符串。 12345var obj = &#123; a: 'hello world', b: 666&#125;;JSON.stringify(obj); //\"&#123;\"a\":\"hello world\",\"b\":666&#125;\" 加上参数可以按缩进输出： 1234567JSON.stringify(obj, null, ' ');/*\"&#123; \"a\": \"hello world\", \"b\": 666&#125;\"*/ 第二个参数用于控制如何筛选对象的键值，比如只输出属性a，可用： JSON.stringify(obj, [‘a’], ‘ ‘); 第二个参数也可以是一个函数，这样对象的每个键值对都会被函数先处理。 如果想要精确控制如何序列化对象，可以给 obj 定义一个toJSON()的方法，直接返回JSON应该序列化的数据。 12345678910var obj = &#123; a: 'hello world', b: 666, toJSON: function()&#123; return &#123; \"a\": this.a &#125; &#125;&#125;;JSON.stringify(obj); //\"&#123;\"a\":\"hello world\"&#125;\" 反序列化 拿到一个JSON格式的字符串，我们直接用JSON.parse()把它变成一个JavaScript对象。 12JSON.parse('&#123;\"a\":\"hello world\",\"b\":666&#125;'); //Object &#123;a: \"hello world\", b: 666&#125; JSON.parse()还可以接收一个函数，用来转换解析出的属性： 123JSON.parse('&#123;\"a\":\"hello world\",\"b\":666&#125;', function(key, value)&#123; ...&#125;); 面向对象编程创建对象JavaScript对每个创建的对象都会设置一个原型，指向它的原型对象。 创建对象有两种方法，一是直接用{...}创建一个对象外，二是用构造函数的方法来创建对象。例如1234567function Student(name) &#123; this.name = name; // 这种方式定义的函数不能被多个对象共享 this.hello = function () &#123; alert('Hello, ' + this.name); &#125;&#125; 可以用关键字new来调用这个函数，并返回一个对象。如果不写new，这就是一个普通函数，返回undefined。 可以编写一个createObj函数，封装new操作，通用的模式如下： 12345678910111213function Student(obj) &#123; this.name = obj.name || '匿名'; // 默认值为'匿名' this.grade = obj.grade || 1; // 默认值为1&#125;// 可以被多个对象共享Student.prototype.hello = function () &#123; alert('Hello, ' + this.name);&#125;;function createStudent(obj) &#123; return new Student(obj || &#123;&#125;)&#125; 原型继承JavaScript的原型继承实现方式： 定义新的构造函数，并在内部用call() 调用希望“继承”的构造函数，并绑定this； 借助中间函数 F 实现原型链继承，最好通过封装的 extends函数完成； 继续在新的构造函数的原型上定义新方法。 以实现PrimaryStudent对Student的继承举例，先编写可以复用的extends函数： 123456function extends(Child, Parent)&#123; var F = function()&#123;&#125;; F.prototype = Parent.prototype; Child.prototype = new F(); Child.prototype.constructor = Child;&#125; 继承的实现： 12345678910111213141516171819function Student(obj)&#123; this.name = obj.name || 'aaa';&#125;Student.prototype.hello = function()&#123; alert('hello' + this.name);&#125;function PrimaryStudent(obj)&#123; Student.call(this, obj); this.grade = obj.grade || 1;&#125;// 实现原型继承链:extends(PrimaryStudent, Student);// 绑定其他方法到PrimaryStudent原型:PrimaryStudent.prototype.getGrade = function()&#123; alert(this.grade);&#125; 浏览器浏览器对象window window对象不但充当全局作用域，而且表示浏览器窗口。 window.innerWidth：内部宽度 window.innerHeight：内部高度 内部宽高是指除去菜单栏、工具栏、边框等占位元素后，用于显示网页的净宽高。兼容性：IE&lt;=8不支持。 navigator navigator对象表示浏览器的信息，最常用的属性包括： navigator.appName：浏览器名称 navigator.appVersion：浏览器版本 navigator.language：浏览器设置的语言 navigator.platform：操作系统类型 navigator.userAgent：浏览器设定的User-Agent字符串 navigator的信息可以很容易地被用户修改，所以JavaScript读取的值不一定是正确的。 screen screen对象表示屏幕的信息，常用的属性有： 列表项screen.width：屏幕宽度 screen.height：屏幕高度 screen.colorDepth：返回颜色位数，如8、16、24 location location对象表示当前页面的URL信息。 location.href：获取一个完整的URL location.assign()：加载一个新页面 location.reload()：重新加载当前页面 url各部分值可以通过如下方式获取： 1234567// http://www.example.com:8080/path/index.html?a=1&amp;b=2#TOPlocation.protocol; // 'http'location.host; // 'www.example.com'location.port; // '8080'location.pathname; // '/path/index.html'location.search; // '?a=1&amp;b=2'location.hash; // 'TOP' document document对象表示当前页面，document对象就是整个DOM数的根节点。 document.title：浏览器窗口标题 document.cookie：获取当前页面的Cookie document.getElementById()：按ID获得一个DOM节点 document.getElementsByTagName():按Tag名称获得一组DOM节点 document.getElementsByClassName():按Class名称获得一组DOM节点 操作dom遍历 方法一是上面document的三个getElement方法。 方法二是使用querySelector()和querySelectorAll()。 更新 document.innerHTML：不但可以修改一个DOM节点的文本内容，还可以直接通过HTML片段修改DOM节点内部的子树。 document.innerText：自动对字符串进行HTML编码，保证无法设置任何HTML标签。 插入 appendChild：使用 parentElement.appendChild(someElement)，把一个子节点添加到父节点的最后一个子节点。 insertBefore：使用parentElement.insertBefore(newElement, referenceElement)，把子节点会插入到referenceElement之前。 删除 首先要获得该节点本身以及它的父节点，然后，调用父节点的removeChild把自己删掉。 AJAX1234567891011121314151617181920212223var request;if (window.XMLHttpRequest) &#123; request = new XMLHttpRequest();&#125; else &#123; request = new ActiveXObject('Microsoft.XMLHTTP'); //兼容低版本IE&#125;// 发送请求:request.open('GET', url);request.send();request.onreadystatechange = function () &#123; // 状态发生变化时，函数被回调 if (request.readyState === 4) &#123; // 成功完成 // 判断响应结果: if (request.status === 200) &#123; // 成功，通过responseText拿到响应的文本: return success(request.responseText); &#125; else &#123; // 失败，根据响应码判断失败原因: return fail(request.status); &#125; &#125; else &#123; // HTTP请求还在继续... &#125;&#125; 跨域的解决： 在同源域名下架设一个代理服务器来转发 JSONP 使用HTML5的CORS document.domain window.name Promise可以用来优化异步操作，使代码更优雅。Promise有各种开源实现，在ES6中被统一规范，由浏览器直接支持。 1234567var p1 = new Promise(test);var p2 = p1.then(function (result) &#123; console.log('成功：' + result);&#125;);var p3 = p2.catch(function (reason) &#123; console.log('失败：' + reason);&#125;); 串联起来可简化为： 12345new Promise(test).then(function (result) &#123; console.log('成功：' + result);&#125;).catch(function (reason) &#123; console.log('失败：' + reason);&#125;); 并行执行异步任务： 12345678910var p1 = new Promise(function (resolve, reject) &#123; setTimeout(resolve, 500, 'P1');&#125;);var p2 = new Promise(function (resolve, reject) &#123; setTimeout(resolve, 600, 'P2');&#125;);// 同时执行p1和p2，并在它们都完成后执行then:Promise.all([p1, p2]).then(function (results) &#123; console.log(results); // 获得一个Array: ['P1', 'P2']&#125;);","tags":[{"name":"前端","slug":"前端","permalink":"http://yutaiwei.github.io/tags/前端/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yutaiwei.github.io/tags/JavaScript/"}]},{"title":"JavaScript 正则表达式","date":"2015-07-25T14:01:59.000Z","path":"2015/07/25/JavaScript 正则表达式/","text":"创建一个正则表达式（/…/）核心JavaScript有两种方式创建一个正则表达式：一种是直接通过/正则表达式/写出来，另一种是通过 new RegExp(&#39;正则表达式&#39;)创建一个RegExp对象。 RegExp对象的test()方法用于测试给定的字符串是否符合条件，返回 true或者false。 举例用正则表达式切分字符串比用固定的字符更灵活。如果用户输入了一组标签，可能用逗号、分号或空格分隔，现在需要用正则表达式来把不规范的输入转化成正确的数组： ‘a,b;; c d’.split(/[\\s\\,\\;]+/); // [‘a’, ‘b’, ‘c’, ‘d’] 元字符（. \\d \\w \\s）核心元字符大致分两种，一种是用来匹配文本的（比如 .），另一只是正则表达式的语法所要求的（比如[和]）. . 字符可以匹配任何单个的字符、字母、数字甚至 . 字符本身。 在匹配特殊字符（比如[、] 、\\ 、+ 、* 、? 等在正则表达式中有特殊含义的字符）本身时，需要用元字符\\转义。 空白字符常用的空白字符主要有换行符（\\n）、回车符（\\r）、制表符（\\t）。 其中\\r\\n匹配一个“回车+换行”组合，是 Windows 的文本行结束标签；Unix 只是用一个换行符来结束一个文本行。 使用 \\r\\n\\r\\n 可以匹配两个连续的行尾标签，即空白行。在Unix/Linux上使用 \\n\\n匹配空白行。 字符类别匹配数字：\\d 表示任何一个数字字符（等价于[0-9]） ; \\D 表示任意一个非数字字符（等价于 [^0-9]）。 匹配字母和数字： \\w 表示任何一个字母数字字符（大小写均可）或下划线字符（等价于 [a-zA-Z0-9_]）; \\W表示任意一个非字母数字字符（大小写均可）或下划线字符（等价于[^a-zA-Z0-9_]）。 匹配空白字符：\\s表示任何一个空白字符（等价于 [\\f\\n\\r\\t\\v]）;\\S表示任何一个非空白字符（等价于 [^\\f\\n\\r\\t\\v]） 举例.a.\\.xls可以匹配文件名含a的以.xls结尾的文件。 字符区间（[] ^）核心[] 用来定义一个字符集合，其含义是必须匹配该集合里的字符之一。 定义一个字符集合的具体做法有两种：一是把所有字符列举出来，二是用元字符以字符区间方式给出。 字符集合可以用^来取非，表示除了该字符集合里的字符，其他字符都可以被匹配。 注意，在字符集合里使用 . 和 +这样的元字符将被解释为普通字符，不需要被转义，[\\w.]和 [\\w\\.]的使用效果一样。 举例[0-9a-zA-Z\\_]可以匹配一个数字、字母或者下划线（单个字符）。 [^0-9] 可以匹配任何不是数字的字符。 ^[\\u4e00-\\u9fa5]可以匹配汉字。 重复匹配（+ * ? {n,m}）核心+匹配至少1个字符；*匹配任意个字符（包括0个）；?匹配0个或1个字符；{n} 匹配 n 个字符；{n,m}匹配 n~m 个字符。 正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。加个?就可以让其变成非贪婪匹配（懒惰型）。 举例[a-zA-Z\\_\\$][0-9a-zA-Z\\_\\$]* 可以匹配由字母或下划线、$开头，后接任意个由一个数字、字母或者下划线、$组成的字符串，也就是JavaScript允许的变量名。 \\d{3,8}表示3-8个数字，比如’1234567’。 对 living in &lt;B&gt;AK&lt;/B&gt; and &lt;B&gt;HI&lt;/B&gt;用 &lt;[Bb].*&lt;/[Bb]匹配，得到 &lt;B&gt;AK&lt;/B&gt; and &lt;B&gt;HI&lt;/B&gt;，而用 *的懒惰版本*? ，即 &lt;[Bb].*?&lt;/[Bb] 匹配，可以得到 &lt;B&gt;AK&lt;/B&gt;和&lt;B&gt;HI&lt;/B&gt;。 位置匹配（\\b ^ $）核心单词边界\\b 用来匹配一个单词的开始或结尾，它匹配的是一个这样的位置：这个位置位于一个能够用来构成单词的字符（\\w）和一个不能用来单词的字符（W）之间。\\b 只匹配一个位置，不匹配任何字符。\\B作用与 \\b 相反，匹配一个前后都不是单词边界的连字符。 字符串边界^匹配行字符串的开头； $匹配行字符串的结尾。 举例对 The cat scattered his food all over the room用\\bcat\\b 匹配，只会得到第二个单词cat。用 \\bcat将会匹配以cat开头的任何单词。 js也可以匹配 &#39;jsp&#39;，但是加上^js$就变成了整行匹配，就只能匹配 &#39;js&#39;了。 子表达式分组匹配（() |）核心除了简单地判断是否匹配之外，正则表达式还有提取子串的强大功能。用()表示的就是要提取的分组（Group）。 子表达式的常见用途是：对重复次数元字符的作用对象做出精确的设定和控制，对|控制符的 OR条件做出准确定义。 如果正则表达式中定义了组，就可以在RegExp对象上用exec()方法提取出子串来。 exec()方法在匹配成功后，会返回一个Array，第一个元素始终是原始字符串本身，后面的字符串表示匹配成功的子串。 exec()方法在匹配失败时返回null。 举例^(\\d{3})-(\\d{3,8})$分别定义了两个组，可以直接从匹配的字符串中提取出区号和本地号码： var reg = /^(\\d{3})-(\\d{3,8})$/;reg.exec(‘010-12345’); // [‘010-12345’, ‘010’, ‘12345’]reg.exec(‘010 12345’); // null (19|20)\\d{2} 匹配一个以19或20开头的4位数字，可以用来匹配年份。 全局匹配（g i m）JavaScript的正则表达式中，g表示全局匹配。 全局匹配可以多次执行exec()方法来搜索一个匹配的字符串。当我们指定g标志后，每次运行 exec()，正则表达式本身会更新 lastIndex属性，表示上次匹配到的最后索引。 全局匹配类似搜索，因此不能使用/^...$/，那样只会最多匹配一次。 正则表达式还可以指定i标志，表示忽略大小写，m 标志，表示执行多行匹配。 举例1234567891011var s = 'JavaScript, VBScript';var re=/[a-zA-Z]+Script/g;// 使用全局匹配:re.exec(s); // ['JavaScript']re.lastIndex; // 10re.exec(s); // ['VBScript']re.lastIndex; // 20re.exec(s); // null，直到结束仍没有匹配到","tags":[{"name":"前端","slug":"前端","permalink":"http://yutaiwei.github.io/tags/前端/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yutaiwei.github.io/tags/JavaScript/"}]},{"title":"CSS实现文本溢出显示省略号","date":"2015-07-25T13:43:53.000Z","path":"2015/07/25/CSS实现文本溢出显示省略号/","text":"单行文本溢出显示省略号1234width: 300px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; 如果字符串长度超过300px，那么超出部分就变成...。 多行文本溢出显示省略号1234display: -webkit-box;-webkit-box-orient: vertical;-webkit-line-clamp: 3;overflow: hidden; 因为使用了WebKit的CSS扩展属性，该方法适用于WebKit浏览器及移动端； -webkit-line-clamp用来限制在一个块元素显示的文本的行数。为了实现该效果，它需要组合其他的WebKit属性。常见结合属性：display: -webkit-box; 必须结合的属性 ，将对象作为弹性伸缩盒子模型显示 。-webkit-box-orient 必须结合的属性 ，设置或检索伸缩盒对象的子元素的排列方式 。 怎样在js中判断文本是否溢出问题描述：一段文字限定行数，使用css把多余文字显示为省略号，请问怎么通过js判断这段文字是否有文字显示为省略号？ 思路一王晨帅哥提供了一个思路：取消css的-webkit-line-clamp属性，看看元素高度是否发生了变化，变化了就是有文字显示为省略号。 好想法，最后小编改进后如下：这段文字在页面上放两份，一份限定行数，正常显示；另一份不限定行数，隐藏起来。然后，对比这两段文字的高度是否相同。具体实现：1234567891011121314151617181920212223242526272829// scss部分.info&#123; font-size: 1.2rem; margin-top: .6rem; display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: 4; overflow: hidden; p&#123; &amp;:not(:first-child)&#123; margin-top: .4rem; &#125;; line-height: 1.8rem; &#125;&#125;.info-hidden&#123; position: fixed; z-index: -10; visibility: hidden; font-size: 1.2rem; margin-top: .6rem; p&#123; &amp;:not(:first-child)&#123; margin-top: .4rem; &#125;; line-height: 1.8rem; &#125;&#125; 123456// js部分var $info = $('.info');var $info_hidden = $('.info-hidden');if($info.height() === $info_hidden.height())&#123; $('.more').hide();&#125; 思路二后来张伟林帅哥提供了一个更好的思路：既然已经知道了限定的行数，那么判断一个高度就可以了。结合line-height，高度用scrollheight，判断scrollheight &gt; line-height*你决定的行数。 小编马上搜索了一个scrollheight，发现，原来scrollHeight可以返回元素的完整高度。那么，比较一下scrollHeight和height不就可以了么？具体实现：1234567// js部分var $info = $('.info');console.log($info.height());console.log($info[0].scrollHeight);if($info.height() &gt;= $info[0].scrollHeight)&#123; $('.more').hide();&#125; 后记利用js也可以实现文本溢出显示省略号，可以参考书签中的dotdotdot，很形象的名字。。。 书签CSS实现单行、多行文本溢出显示省略号（…）http://www.daqianduan.com/6179.html jQuery.dotdotdothttp://www.bootcdn.cn/jQuery.dotdotdot/","tags":[{"name":"前端","slug":"前端","permalink":"http://yutaiwei.github.io/tags/前端/"},{"name":"css","slug":"css","permalink":"http://yutaiwei.github.io/tags/css/"}]},{"title":"瀑布流特效","date":"2015-07-25T12:55:17.000Z","path":"2015/07/25/瀑布流特效/","text":"原理假设页面上有三列图片，当我们下拉时，最短（或最长）的一列图片展示完的时候，就要请求加载新的图片，获取到的新的图片放到最短一列图片的下面。尝试过用原生js或jquery实现瀑布流，源码放在本文最后。下面记录一种使用imageloaded和masonry插件实现的瀑布流，更简便。 imageloaded和masonryejs代码：1234567&lt;div id=\"meitulist\" class=\"meitulist\"&gt; &lt;% data.obj.pictureList.forEach(function(picture)&#123; %&gt; &lt;a href=\"/inspiration/imagedetail/&lt;%= picture.albumId%&gt;\" class=\"item\"&gt; &lt;img src=\"&lt;%= picture.url%&gt;\" /&gt; &lt;/a&gt; &lt;% &#125;)%&gt;&lt;/div&gt; 每次加载图片并插入后，执行resetImage()函数。 1234567891011121314151617181920function resetImage()&#123; var width = document.documentElement.clientWidth; var column = width&gt;320? 3 : 2; var itemWidth = Math.ceil((width-(column+1)*10)/column); $('.meitulist .item').css('width',itemWidth); $('.meitulist .item img').css(&#123; 'width':itemWidth // 'height': itemWidth &#125;) window.imagesLoaded('#meitulist', function() &#123; var msnry = new Masonry('#meitulist',&#123; 'columnWidth': itemWidth, 'itemSelector': '.item', 'isAnimated':true, // 'percentPosition':true, 'gutter': 10 &#125;); &#125;);&#125; js和jquery源码https://github.com/voidking/front-end-demo/tree/master/%E7%80%91%E5%B8%83%E6%B5%81 参考文档瀑布流特效http://www.cnblogs.com/Leo_wl/p/4306295.html Masonry官网http://masonry.desandro.com/ mosonry项目地址：https://github.com/desandro/masonry imagesLoaded官网http://imagesloaded.desandro.com/ imagesloaded项目地址：https://github.com/desandro/imagesloaded","tags":[{"name":"前端","slug":"前端","permalink":"http://yutaiwei.github.io/tags/前端/"},{"name":"插件","slug":"插件","permalink":"http://yutaiwei.github.io/tags/插件/"},{"name":"jQuery","slug":"jQuery","permalink":"http://yutaiwei.github.io/tags/jQuery/"}]},{"title":"js中call、apply、bind的用法","date":"2015-07-25T10:45:27.000Z","path":"2015/07/25/js中call、apply、bind的用法/","text":"今天看博客时，看到了这样的一段js代码： 1var bind = Function.prototype.call.bind(Function.prototype.bind); 我想突然看到这样的一段代码，即使js能力再强的人，可能也需要花点时间去理解。像我这样的菜鸟就更不用说了。其实，原文已经对这端代码做出了解释，但我还是想用我的想法去解释这段代码。 上面那段代码涉及到了call、bind，所以我想先区别一下call、apply、bind的用法。这三个方法的用法非常相似，将函数绑定到上下文中，即用来改变函数中this的指向。举个例子： 123456789101112var zlw = &#123; name: \"zlw\", sayHello: function (age) &#123; console.log(\"hello, i am \", this.name + \" \" + age \" years old\"); &#125;&#125;;var xlj = &#123; name: \"xlj\",&#125;;zlw.sayHello(24);// hello, i am zlw 24 years old 下面看看call、apply方法的用法： 12zlw.sayHello.call(xlj, 24);// hello, i am xlj 24 years oldzlw.sayHello.apply(xlj, [24]);// hello, i am xlj 24 years old 结果都相同。从写法上我们就能看出二者之间的异同。相同之处在于，第一个参数都是要绑定的上下文，后面的参数是要传递给调用该方法的函数的。不同之处在于，call方法传递给调用函数的参数是逐个列出的，而apply则是要写在数组中。 我们再来看看bind方法的用法： 12zlw.sayHello.bind(xlj, 24)(); //hello, i am xlj 24 years oldzlw.sayHello.bind(xlj, [24])(); //hello, i am xlj 24 years old bind方法传递给调用函数的参数可以逐个列出，也可以写在数组中。bind方法与call、apply最大的不同就是前者返回一个绑定上下文的函数，而后两者是直接执行了函数。由于这个原因，上面的代码也可以这样写: 12zlw.sayHello.bind(xlj)(24); //hello, i am xlj 24 years oldzlw.sayHello.bind(xlj)([24]); //hello, i am xlj 24 years old bind方法还可以这样写fn.bind(obj, arg1)(arg2)。 用一句话总结bind的用法：该方法创建一个新函数，称为绑定函数，绑定函数会以创建它时传入bind方法的第一个参数作为this，传入bind方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。 现在回到开始的那段代码： 1var bind = Function.prototype.call.bind(Function.prototype.bind); 我们可以这样理解这段代码： 1var bind = fn.bind(obj) fn相当于Function.prototype.call，obj相当于Function.prototype.bind。而fn.bind(obj)一般可以写成这样obj.fn，为什么呢？因为fn绑定了obj，fn中的this就指向了obj。我们知道，函数中this的指向一般是指向调用该函数的对象。所以那段代码可以写成这样: 1var bind = Function.prototype.bind.call; 大家想一想Function.prototype.call.bind(Function.prototype.bind)返回的是什么？ 1console.log(Function.prototype.call.bind(Function.prototype.bind)) // call() 返回的是call函数，但这个call函数中的上下文的指向是Function.prototype.bind。这个call函数可以这样用 1234567891011var bind = Function.prototype.call.bind(Function.prototype.bind);var zlw = &#123; name: \"zlw\"&#125;;function hello () &#123; console.log(\"hello, I am \", this.name);&#125;bind(hello, zlw)() // hello, I am zlw 大家可能会感到疑惑，为什么是这样写bind(hello, zlw)而不是这样写bind(zlw, hello)？既然Function.prototype.call.bind(Function.prototype.bind)相当于Function.prototype.bind.call，那么先来看下Function.prototype.bind.call怎么用。call的用法大家都知道： 1Function.prototype.bind.call(obj, arg) 其实就相当于obj.bind(arg)。我们需要的是hello函数绑定对象zlw，即hello.bind(zlw)也就是Function.prototype.bind.call(hello, zlw)，所以应该这样写bind(hello, zlw)。 现在又有一个疑问，既然Function.prototype.call.bind(Function.prototype.bind)相当于Function.prototype.bind.call，我们为什么要这么写： 1var bind = Function.prototype.call.bind(Function.prototype.bind); 而不直接这样写呢： 1var bind = Function.prototype.bind.call; 先来看一个例子： 1234567891011var name = \"xlj\";var zlw = &#123; name: \"zlw\" hello: function () &#123; console.log(this.name); &#125;&#125;;zlw.hello(); // zlwvar hello = zlw.hello;hello(); // xlj 有些人可能会意外，hello()的结果应该是zlw才对啊。其实，将zlw.hello赋值给变量hello，再调用hello()，hello函数中的this已经指向了window，与zlw.hello不再是同一个上下文，而全局变量name是window的一个属性，所以结果就是xlj。再看下面的代码： 12var hello = zlw.hello.bind(zlw);hello(); // zlw 结果是zlw，这时hello函数与zlw.hello是同一个上下文。其实上面的疑惑已经解开了，直接这样写： 1var bind = Function.prototype.bind.call; bind函数中的上下文已经与Function.prototype.bind.call中的不一样了，所以使用bind函数会出错。而这样写 1var bind = Function.prototype.call.bind(Function.prototype.bind); bind函数中的上下文与Function.prototype.call.bind(Function.prototype.bind)中是一样的。 关于这个这段代码的解释这到这边了，感觉语言组织能力不是很好，文章写得有些啰嗦了。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yutaiwei.github.io/tags/JavaScript/"}]},{"title":"css阴影效果","date":"2015-07-25T02:50:25.000Z","path":"2015/07/25/css阴影效果/","text":"有阴影的图，看上去高大上些？不管怎样，UI设计了阴影，咱就照做好了。语法：1box-shadow: h-shadow v-shadow blur spread color inset; 解释： 值 描述 h-shadow 必需。水平阴影的位置。允许负值。 v-shadow 必需。垂直阴影的位置。允许负值。 blur 可选。模糊距离。 spread 可选。阴影的尺寸。 color 可选。阴影的颜色。请参阅 CSS 颜色值。 inset 可选。将外部阴影 (outset) 改为内部阴影。 常见用法：123div&#123; box-shadow: 10px 10px 5px #0cc;&#125; 四个值分别是水平阴影位置、垂直阴影位置、模糊距离、颜色。 实际案例：123&lt;a href=\"\" class=\"confirm\"&gt; &lt;span&gt;马上去抢2G流量&lt;/span&gt;&lt;/a&gt; 12345678910111213141516.confirm&#123; display: inline-block; box-shadow: 0 .5rem 1.5rem #0cc; border-radius: 5px; margin-top: 12%; width: 98%; height: 17%; background: url(../../img/flowrate/blue.jpg) no-repeat; background-size: 100% 100%; color: #fff; span&#123; display: inline-block; margin-top: 3%; font-size: 1.5rem; &#125;&#125; 最终效果如下：","tags":[{"name":"前端","slug":"前端","permalink":"http://yutaiwei.github.io/tags/前端/"},{"name":"css","slug":"css","permalink":"http://yutaiwei.github.io/tags/css/"}]},{"title":"JavaScript之函数科里化","date":"2015-07-25T00:00:00.000Z","path":"2015/07/25/JavaScript之函数柯里化/","text":"什么是柯里化(currying)？维基百科中的解释是：柯里化是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。意思就是当函数被调用时，返回的函数还需要设置一些传入的参数。首先来看一个简单的例子，有下面一个函数： function add(num1, num2) { return num1 + num2; } 我们把它改写成下面这样： var fn = function(a) { return function (b) { return a + b; } } 可以这样调用函数：fn(2)(3)。上面使用了匿名函数来实现多参数函数的方法，虽然这并不是柯里化的函数，但可以帮助我们理解柯里化的含义。 ###实现通用柯里化函数###我们可以在内置构造函数Function()的原型上来添加一个柯里化函数，这样所有的函数都可以调用。下面是通用柯里化函数的实现： Function.prototype.currying = function () { var that = this; var args = [].slice.call(arguments); return function () { return that.apply(null, args.concat([].slice.call(arguments))); } } 现在用柯里化函数将上面的add函数柯里化： var curriedAdd = add.currying(2); curriedAdd(3); // 5 也可以一次性传入两个参数： var curriedAdd = add.currying(2， 3); curriedAdd(); // 5 我们知道在原生对象的原型上扩展方法是不太好的，因为可能会导致命名冲突。所以最好不要把currying函数扩展在Function的原型上，下面是改写的currying函数： function currying(fn) { var args = [].slice.call(arguments, 1); return function () { return that.apply(null, args.concat([].slice.call(arguments))); } } 改写之后currying函数的第一个参数是要被柯里化的函数，可以这样调用： var curriedAdd = currying(add, 2); curriedAdd(3); // 5 或 var curriedAdd = currying(add, 2， 3); curriedAdd(); // 5 上面的add函数只是两个数字的相加，如果我们需要n个数字相加，上面的currying函数已经不能满足要求了，下面是修改后的currying函数： function currying(fn) { var argsArr = []; return function () { if (arguments.length === 0) { return fn.apply(null, argsArr); } else { [].push.apply(argsArr, arguments); } } } 多个数字相加： var add = function () { var num = 0; [].forEach.call(arguments, function (item, i) { num += item; }) return num; } var curriedAdd = currying(add); curriedAdd(2); curriedAdd(3); curriedAdd(4); curriedAdd(5); curriedAdd(); 这样做有什么好处呢？假如说我们只想知道这个月花了多少钱，而中间的某一天之前花了多少我们并不想知道，我们只在乎结果，不在乎过程，上面的currying函数很好地解决了这个问题。有的人说这样做可以节省性能，我倒觉得这和性能没多大关系，或者说这样做的目的并不是为了性能，因为每次计算结果和最后一起计算结果是一样的，都是要计算一样的次数。还有一个好处就是可以复用currying函数，比如我们要多个数字相乘或者其他操作，都可以用currying函数，处理数字只需修改fn参数就可以。 说到柯里化就不得不说Function.prototype.bind这个方法了，它也实现了函数的柯里化。我们可以自己来实现一个bind函数： function bind（fn, context） { var args = [].slice.call(arguments, 2); return function () { return fn.apply(context, args.concat([].slice.call(arguments))); } } 假如我们需要改变fn中的this上下文，就可以用bind函数，否则可以用currying函数。","tags":[{"name":"前端","slug":"前端","permalink":"http://yutaiwei.github.io/tags/前端/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yutaiwei.github.io/tags/JavaScript/"}]},{"title":"CSS3的了解","date":"2015-07-21T14:39:19.000Z","path":"2015/07/21/CSS3之初体验/","text":"自CSS3流行以来，虽然以前看过一遍所有的新增属性，但其实在实际项目中用到的少之又少。所以没有形成系统性的认识，以及看到效果立马就能想到解决方案的能力。然后最近正好遇到一个需要绘制大量动画的需求，所以决定趁此机会好好研究一下这个既熟悉又陌生的css3。 在正式开始css3之前，先来介绍一些比较经典的css3实例，让大家好好感受一下css3的魅力，本文会提到以下几个css3的属性： border-radius、::after、attr和content、box-sizing、linear-gradient、radial-gradient、box-shadow border-radius 相信这个属性，写过css的同学都知道，用来产生圆角，比如画一个圆形： 123456div &#123; width:100px; height:100px; background:red; border-radius:100px; //border-radius:100%;&#125; 然后我们来看看它的语法：border-radius: [左上] [右上] [右下] [左下]，于是我们来画一个半圆 123456div &#123; width: 100px; height: 50px; background: red; border-radius: 50px 50px 0 0;&#125; 那如果要画一个椭圆该怎么办呢？你会发现上面的语法貌似做不到了，其实border-radius的值还有一种语法: x半径/y半径： 123456div &#123; width: 100px; height: 50px; background: red; border-radius: 50px/25px;&#125; 如果我要画半个椭圆，又要咋办呢？ 123456div &#123; width: 100px; height: 50px; background: red; border-radius: 100% 0 0 100% /50%;&#125; ::after这里拿个简单的例子来看，我们要画一个放大镜，如下图： 分析一下，这个放大镜可以由两个div组成，一个是黑色的圆环，一个是黑色把手（旋转45度）。所以我们就需要用两个div来实现吗？答案是NO，一个div也是可以的，我们可以借助::after来添加一个元素。同理如果需要三个div，我们还可以使用::before再添加一个元素。下面看一下代码： 12345678910111213141516171819div &#123; width: 50px; height: 50px; border-radius: 50%; border: 5px solid #333; position: relative;&#125;div::after &#123; content: ''; display: block; width: 8px; height: 60px; border-radius: 5px; background: #333; position: absolute; right: -22px; top: 38px; transform: rotate(-45deg);&#125; attr和content比如我们要实现一个悬浮提示的功能。传统方法，使用title属性就能实现，但是现在我们要更美观，可以使用css3提供的attr：能够在css中获取到元素的某个属性值，然后插入到伪元素的content中去。 假如我们的html代码如下： 1&lt;div data-title=\"hello, world\"&gt;hello...&lt;/div&gt; 我们来看看实现这个插件的css代码： 12345678910111213div &#123; position: relative;&#125;div:hover::after &#123; content: attr(data-title); //取到data-title属性的值 display: inline-block; padding: 10px 14px; border: 1px solid #ddd; border-radius: 5px; position: absolute; top: -50px; left: -30px;&#125; 当hover的时候，在元素尾部添加一个内容为data-title属性值的元素，所以就实现了hover显示的效果，如下图所示： box-sizing我们知道，在标准盒子模型中，元素的总宽＝content + padding + border + margin。 css中的盒子模型大家可能都知道，但是这个盒子模型的属性可能没有那么多人知道，box-sizing属性就是用来重定义这个计算方式的，它有三个取值，分别是：content-box（默认）、border-box、padding-box 一般来说，假如我们需要有一个占宽200px、padding10px、border5px的div，经过计算，要这么定义样式。 123456div &#123; width: 170px; //这里的宽度要使用200-10*2-5*2 = 170得到。 height: 50px; padding: 10px; border: 5px solid red;&#125; 然后我们来使用一下box-sizing属性。 1234567div &#123; box-sizing: border-box; width: 200px; //这里的宽度就是元素所占总宽度，不需要计算 height: 50px; padding: 10px; border: 5px solid red;&#125; linear-gradient做活动页面的时候我们经常会遇到这样的需求： 顶部的中间一张大banner图片，然后整个区域的背景色要根据图片背景色渐变。就可以使用这个属性了。 12345div &#123; width: 200px; height: 50px; background: linear-gradient(to right, red, yellow, black, green);&#125; 是不是很有趣？其实，linear-gradient还有更多有趣的功能，你可以根据下面的动图去感受一下： 你以为这就完了？等等，还有更强大的呢！repeating-linear-gradient，来感受一下： linear-gradient还有更加强大的功能，比如它可以给元素添加多个渐变，从而达到更NB的效果。 radial-gradient上面的linear-gradient是线性渐变，这个属性是径向渐变。下面的代码实现了一个chrome的logo。 1234567891011121314151617div.chrome &#123; width: 180px; height: 180px; border-radius: 50%; box-shadow: 0 0 4px #999, 0 0 2px #ddd inset; background: radial-gradient(circle, #4FACF5 0, #2196F3 28%, transparent 28%), radial-gradient(circle, #fff 33%, transparent 33%), linear-gradient(-50deg, #FFEB3B 34%, transparent 34%), linear-gradient(60deg, #4CAF50 33%, transparent 33%), linear-gradient(180deg, #FF756B 0, #F44336 30%, transparent 30%), linear-gradient(-120deg, #FFEB3B 40%, transparent 40%), linear-gradient(-60deg, #FFEB3B 30%, transparent 30%), linear-gradient(0deg, #4CAF50 45%, transparent 45%), linear-gradient(60deg, #4CAF50 30%, transparent 30%), linear-gradient(120deg, #F44336 50%, transparent 50%), linear-gradient(180deg, #F44336 30%, transparent 30%);&#125; 实现原理就是使用了多个渐变色放在div上，友协被遮住，视觉上就产生了想要的效果，是不是很强大！看了下图你就知道其实就是在div上加了很多个渐变。 box-shadow上面的例子大都是对css3新属性的了解和认识，这个实例则是有关于解决方案的例子。 需求：我们要实现下面这个效果图（三个边框：黑色，绿色，红色）： 解法一：假如没有css3知识，我们可以做这样做：用三个div，分别设置边框，然后分别控制宽高和位置来达到这个效果。显然，很复杂，这里就不贴代码了。 解法二：现在我们有css3的知识了，借助box-shadow就可以轻松解决这个问题。先来看看它的语法：box-shadow: [x偏移] [y偏移] [阴影模糊宽度] [阴影宽度] [颜色]，并且还能添加多个阴影，使用逗号隔开。 当然你还可以继续增加，四重边框，五重边框……都不再是问题啦。另外，还能加圆角，阴影会贴紧内层div。 使用这种方法，有一个缺点就是，不支持虚线边框。 解法三： 使用outline（只能支持两重边框） 使用这种方法的缺点就是，只能支持两层的边框，而且还不能根据容器的border-radius自动贴合。 总结通过这段时间对css3的深入了解，发现css3真的很强大，研究起来还是挺有趣的，只有想不到，感觉没有做不到。不过为了实现很酷炫的效果，可能需要编写大量的css代码，这个时候使用什么技术就需要我们自己来衡量了。","tags":[{"name":"CSS3","slug":"CSS3","permalink":"http://yutaiwei.github.io/tags/CSS3/"},{"name":"实例","slug":"实例","permalink":"http://yutaiwei.github.io/tags/实例/"}]},{"title":"绝对定位居中布局","date":"2015-07-12T12:19:51.000Z","path":"2015/07/12/绝对定位居中布局/","text":"前言绝对定位并且居中显示，在开发中经常用到。总结了一下这种布局的三种方法，备忘。 方法一12345678position: absolute;top: 0;left: 0;right: 0;bottom: 0;margin: auto;width: 82%;height: 40%; 方法二1234567position: absolute;left: 50%; top: 50%;margin-top: -20%;margin-left: -41%;width: 82%;height: 40%; 方法三12345position: absolute;left: 50%; top: 50%;transform: translate(-50%, -50%); /* 50%为自身尺寸的一半 */margin: auto; 后记以上三种绝对定位居中布局方法，同样适用于固定定位，即position:fixed;，只不过是相对的容器变成了浏览器。","tags":[{"name":"前端","slug":"前端","permalink":"http://yutaiwei.github.io/tags/前端/"},{"name":"css","slug":"css","permalink":"http://yutaiwei.github.io/tags/css/"}]}]