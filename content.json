[{"title":"JavaScript书签","date":"2016-09-25T13:16:19.000Z","path":"2016/09/25/JavaScript书签/","text":"回调函数（callback）是什么？http://www.zhihu.com/question/19801131 读取JAVASCRIPT第一公民-函数http://www.cnblogs.com/YOUCAN/archive/2012/11/05/2754968.html 《JAVASCRIPT语言精髓与编程实践》，周爱民http://www.chnxp.com.cn/soft/2013-12/22670.html 无废话JavaScripthttp://blog.csdn.net/aimingoo/article/details/3022379 深入理解javascript原型和闭包http://www.cnblogs.com/wangfupeng1988/p/3977987.html JS的事件监听机制http://www.cnblogs.com/aji88/archive/2012/07/20/2600492.html js事件监听器用法实例详解http://www.jb51.net/article/67051.htm HTML 最佳实践http://www.imooc.com/article/3666 Node.JS编码规范指南教程：教你优雅地写JavaScript代码 前端JavaScript规范http://www.imooc.com/article/1402 为JavaScript程序员准备的10本免费书籍http://www.imooc.com/article/1767","tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yutaiwei.github.io/tags/Javascript/"},{"name":"书签","slug":"书签","permalink":"http://yutaiwei.github.io/tags/书签/"}]},{"title":"AngularJS按需加载js","date":"2016-08-02T15:57:39.000Z","path":"2016/08/02/AngularJS按需加载js/","text":"前言Angular是一个单页面应用，随着系统的迭代，首屏代码会越来越大，所以对《AngularJS入门》中的代码进行改造，实现AngularJS可以按需加载js和css。 实现这个需求，有三个方案：1、利用requirejs。requirejs并不是按照angular规范开发的第三方插件，后期估计会有很多坑，放弃。 2、利用ui-router和ocLazyLoad。 每次“页面跳转”都要额外请求js并加载，浪费带宽增加页面加载时间，基本抛弃了预加载。 每一个路由都需要配置resolve属性，太low。 模块化程度太低，不利于以后代码移植和维护。 3、自己写需要的组件。最好的方案，然而技术要求太高，放弃。 综上，第三种方案暂时无法实现，放弃；第一种方案坑太多，放弃；第二种方案也不好，但是相对容易，而且是针对angular的插件，就它了。1234bower install angular#1.5.8bower install angular-ui-routerbower install oclazyloadbower install bootstrap 核心代码123456789101112131415161718192021222324252627282930313233&lt;!--dynamic/index.html--&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"zh\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;link rel=\"stylesheet\" href=\"bower_components/bootstrap/dist/css/bootstrap.min.css\"&gt; &lt;style&gt; body&#123; font-family: \"Microsoft Yahei\"; &#125; .navigator&#123; width: 500px;margin: 0 auto &#125; .navigator li&#123; color: #000;font-size: 14px; &#125; &lt;/style&gt; &lt;title&gt;按需加载js&lt;/title&gt;&lt;/head&gt;&lt;body ng-app=\"myApp\"&gt; &lt;ul class=\"navigator nav nav-pills\"&gt; &lt;li role=\"presentation\" class=\"active\"&gt;&lt;a href=\"#home\" ng-click=\"isActive($event)\"&gt;主页&lt;/a&gt;&lt;/li&gt; &lt;li role=\"presentation\" class=\"active\"&gt;&lt;a href=\"#page2\"&gt;Page2&lt;/a&gt;&lt;/li&gt; &lt;li role=\"presentation\" class=\"active\"&gt;&lt;a href=\"#page3\" ng-click=\"isActive($event)\"&gt;Page3&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div ui-view style=\"width: 500px;margin: 50px auto 0\"&gt;&lt;/div&gt;&lt;script src=\"bower_components/angular/angular.min.js\"&gt;&lt;/script&gt;&lt;script src=\"bower_components/angular-ui-router/release/angular-ui-router.min.js\"&gt;&lt;/script&gt;&lt;script src=\"bower_components/oclazyload/dist/ocLazyLoad.min.js\"&gt;&lt;/script&gt;&lt;script src=\"public/js/index.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/* *dynamic/public/js/index.js*/var myApp=angular.module(\"myApp\",[\"ui.router\",\"oc.lazyLoad\"]);myApp.config(function ($stateProvider,$urlRouterProvider) &#123; $urlRouterProvider.when(\"\",\"/home\"); $stateProvider.state('home',&#123; url:\"/home\", templateUrl: 'views/homepage.html', controller: 'homeController', resolve:&#123; loadMyCtrl:['$ocLazyLoad',function ($ocLazyLoad) &#123; return $ocLazyLoad.load(&#123; name:\"homeApp\", files:[\"public/js/homepage.js\"] &#125;) &#125;] &#125; &#125;); $stateProvider.state('page2',&#123; url:\"/page2\", templateUrl:'views/page2.html', resolve:&#123; loadMyCtrl:function ($ocLazyLoad) &#123; return $ocLazyLoad.load(&#123; name:'page2App', files:[\"public/js/page2.js\"] &#125;) &#125; &#125; &#125;) $stateProvider.state('page3',&#123; url:\"/page3\", templateUrl:'views/page3.html', resolve:&#123; loadMyCtrl:function ($ocLazyLoad) &#123; return $ocLazyLoad.load(&#123; name:'page3App', files:[\"public/js/page3.js\",\"public/js/page3-ext.js\"] &#125;) &#125; &#125; &#125;) &#125;); 12345&lt;!--dynamic/views/homepage.html--&gt;&lt;div id=\"home\" ng-controller=\"homeController\"&gt; &lt;h1&gt;首页&lt;/h1&gt; &#123;&#123;content&#125;&#125;&lt;/div&gt; 123456/* *dynamic/public/js/homepage.js*/angular.module('myApp').controller('homeController', function ($scope) &#123; $scope.content = '这是主页的内容';&#125;); 完整代码github自取：https://github.com/voidking/angulardemo/tree/master/dynamic 书签RequireJS官方文档http://requirejs.org/docs/start.html Dynamically Loading Controllers and Views with AngularJShttp://weblogs.asp.net/dwahlin/dynamically-loading-controllers-and-views-with-angularjs-and-requirejs angular应用如何实现按需加载http://www.alloyteam.com/2015/10/angular-application-how-to-load-on-demand/ 尝试通过AngularJS模块按需加载搭建大型应用（上）http://web.jobbole.com/86915/ 尝试通过AngularJS模块按需加载搭建大型应用（下）http://web.jobbole.com/87025/ angularjs ocLazyLoad分步加载js文件,angularjs ocLazyLoad按需加载jshttp://m.w2bc.com/article/158713 按需加载 AngularJS 的 Controllerhttp://beginor.github.io/2014/12/20/angularjs-controller-load-on-demand.html","tags":[{"name":"前端","slug":"前端","permalink":"http://yutaiwei.github.io/tags/前端/"},{"name":"angularjs","slug":"angularjs","permalink":"http://yutaiwei.github.io/tags/angularjs/"}]},{"title":"Express入门","date":"2016-07-13T14:09:59.000Z","path":"2016/07/13/Express入门/","text":"Express是node的后台快速开发框架创建http服务 12345678910111213141516171819let http = require('http');let fs = require('fs');let url = require('url');http.createServer(function (req,res) &#123; var urlObj = url.parse(req.url,true); var pathname = urlObj.pathname; if (pathname == '/')&#123; res.end('首页') &#125; else if(pathname == '/user')&#123; res.end('用户') &#125; else &#123; res.statusCode = 404; res.end('Not Found') &#125;&#125;).listen(3000,function () &#123; console.log('3000端口成功监听')&#125;); 也可以写成12345let express = require('express');let app = express();app.listen(8080,function()&#123; console.log('8080端口已经成功启动，服务器监听正常')&#125;) express 是一个node模块12- npm install express//安装express方法 注意文件夹名字不能与module模块名字相同 1234567891011121314151617let express = require('express');let app = express();app.get('/',function (req,res) &#123; res.end('首页');&#125;);app.get('user',function (req,res) &#123; res.end('用户');&#125;);app.get('*',function (req,res) &#123; res.end('页面未找到'); //*代表所有路径&#125;);//get方法对应http的方法名 /对应于根路径express.listen(9090,function () &#123; console.log('9090监听成功')&#125;); 中间件 中间件的含义： 是一个函数,可以设置一些公共的逻辑，对所有的路由生效，next也是一个函数，调用它表示继续向下执行 中间件的作用：进行权限判断，添加一些公共的方法 1234app.use(function (req,res，next) &#123; res.setHeader('Content-Type','text/html,charset:utf-8'); next();&#125;); 路由中间件 是一个中间件，但是里面包含了路由规则，把路由进行分类，把不同的路由写在不同的模块里例如 12345678let express = require('express');let app = express();let user = require('./routes/user');let article = require('./routes/article');app.use('/user',user);app.use('/article',article);app.listen(9090);// 有请求到来的时候，先匹配路径前缀 如果匹配才交由后面的路由中间件来处理 ==使用cmd命令模拟发送post请求==1curl -v http://www.baidu.com node实现页面跳转(重定向) 返回到来时的页面 1res.redirect('back'); 跳到指定的页面 1234app.post('/signup',function(req,res)&#123; res.redirect('/signin'); //参数是一个URL地址，不是文件路径&#125;); express 中经常用到的模块汇总请求体解析模块——body-parser 可以将前台get方法传过来的路径内容，或者post方法传过来的参数直接解析 1234567891011npm install body-parser --savelet bodyParser = require('body-parser');app.use(bodyParser.urlencoded(&#123;extended:true&#125;));//extended:true 当extended为false的时候，键值对中的值就为'String'或'Array'形式，为true的时候，则可为任何数据类型。//请求体解析还有这种写法app.use(bodyParser.json());//urlencoded解析body中的urlencoded字符， 只支持utf-8的编码的字符,也支持自动的解析gzip和 zlib，.json这个方法返回一个仅仅用来解析json格式的中间件，能接受任何body中任何Unicode编码的字符。 ==一般请求中有json发送的时候就需要调用bodyParser.json的方法==以上内容写完之后，可以直接在如果是get方法传进来的参数可以用1res.qurey.xxx中获取到 如果是post方法传进来的参数可以用1res.body.xxx中获取到 1234567可以获取的请求内容console.log(req.method); console.log(req.url); console.log(req.path);// req.path = pathname console.log(req.query); console.log(req.headers); console.log(req.body); ==node还可以通过自带的req.params来获取请求url中的参数值== 路径解析模块——path 处理有关文件路径的内容 1let path = require('path'); 绝对路径：==path.resolve== 123456789path.resolve('foo/bar', '/tmp/file/', '..', 'a/../subfile');// 返回 /tmp/subfile// 此方法的参数类似于命令行中的cd命令eg:cd foo/barcd /tmp/file/cd ..cd a/../subfile// cd ..返回上一层 使用适合当前系统的链接符号，连接多个路径：==path-join== 12345console.log(path.join(__dirname,'path.js'));//参数只能是字符串eg：var str = path.join('./path/./', './upload', '/file', '123.jpg');console.log(str); // path/upload/file/123.jpg 路径整理：==path.normalize== 123var str = path.normalize('./path//upload/data/../file/./123.jpg');console.log(str); // path/upload/file/123.jpg//将杂乱的路径例如： path//upload/../file/./123.jpg整理为 path/upload/file/123.jpg正常路径 解析路径：==path.parse== 把一个路径解析为一个 {root:’’, dir:’’, base:’’, ext:’’, name:’’} 这样的对象。 123456789path.parse('/home/user/dir/file.txt')// returns&#123; root : \"/\", dir : \"/home/user/dir\", base : \"file.txt\", ext : \".txt\", name : \"file\"&#125; 更多path模块的使用方法参见：http://www.cnblogs.com/52cik/p/learn-node-path.html 在node环境中每个模块下，都可以通过1234__dirname// 获取当前文件所在的目录的绝对路径__filename//当前文件所在的绝对路径 express路由：Router 可以通过router配置路由 123456789101112131415let router = express.Router();eg:let express = require('express');//router也是一个容器，此容器下面可以配置路由let router = express.Router();router.get('/signup',function(req,res)&#123; res.end('注册');&#125;);router.get('/signin',function(req,res)&#123; res.end('登录');&#125;);router.get('/signout',function(req,res)&#123; res.end('退出');&#125;);module.exports = router; express控制cooike：cookie-parsercookie可以应用在很多场景，例如保存未登录账户的用户的购物车信息引入cookie-parser1let cookiePaser = require('cookie-parser'); 使用cookie-parser需要传入一个秘钥1app.use(cookieParser('mima')); 向客户端写cooike1res.cookie('name','zfpx') 读取客户端的cooike1req.cookies 通过domain来设置向哪个域名发送此次写入的cookie1res.cookie('path-name','zfpx',&#123;domain:'a.zfpx.cn'&#125;); path路径是指向哪个路径发请求的时候会发送此cookie1res.cookie('path-name','zfpx',&#123;path:'/read1'&#125;); 获取服务器时间12expires的参数是一个绝对的时间 2017年1月15日12:33:29res.cookie('expire-name','zfpx',&#123;expires:new Date(Date.now()+10*1000)&#125;); 设置cooike的生命周期12开始倒计时，到10秒后销毁此cookieres.cookie('maxAge-name','zfpx',&#123;maxAge:10*1000&#125;); eg：利用express实现一个访问量统计12345678910let express = require('express');let cookieParser = require('cookie-parser');let app = express();app.use(cookieParser());app.get('/visit',function(req,res)&#123; var visit = isNaN(req.cookies.visit)?1:parseInt(req.cookies.visit)+1; res.cookie('visit',visit); res.send(`欢迎您第$&#123;visit&#125;次访问`);&#125;);app.listen(3333); express的静态资源节点 static通过设置中间件的方式，将客户端发送来的静态资源请求找到设置的对应的文件路径，并将该路径下找到的同名文件返回给客户端。1234567eg:app.use(express.static(path.join(__dirname, 'public')));//解析public文件夹在服务器上的绝对路径，并将客户端发送的所有静态文件请求都从public上查找，并将找到的同名文件返回给客户端eg2:var resolve =file=&gt;path.resolve(__dirname, file);app.use('/dist',express.static(resolve('./dist')));//客户端访问时，带有/dist的路径的进行解析，并将/dist路径下的同名文件进行返回。","tags":[]},{"title":"input绑定回车事件","date":"2016-06-10T02:26:43.000Z","path":"2016/06/10/input绑定回车事件/","text":"html部分：1&lt;input id=\"search-key\" type=\"text\" placeholder=\"请输入关键字\"&gt; JavaScript部分：1234567$('#search-key').keypress(function(event) &#123; var key = event.which; console.log(key); if(key == 13)&#123; //do something &#125;&#125;);","tags":[{"name":"前端","slug":"前端","permalink":"http://yutaiwei.github.io/tags/前端/"},{"name":"jquery","slug":"jquery","permalink":"http://yutaiwei.github.io/tags/jquery/"}]},{"title":"AngularJS 表单验证","date":"2016-06-02T14:01:59.000Z","path":"2016/06/02/AngularJS 表单验证/","text":"AngularJS 表单验证在使用 AngularJS 进行开发的时候，表单填写是一个很常见的需求，而表单验证又是比较让人头疼的部分，本文对此做一个总结。 在 Angular 的视图中使用的 form 已经不是 HTML 中的普通 form 了，而是一个被 Angular 封装过的指令。它可以完成普通 form 无法实现的功能，比如 form 嵌套，而且自带强大的验证功能。Angular 在对表单进行校验的时候会使用 ngModelController上的属性，如果不设置ng-model，则 Angular 无法知道form.$invalid 这个值是否为真。后面在自定义验证有对它的介绍。 本文在对表单的验证时使用了ng-messages，在文章最后也有对它的介绍。 input元素的type属性值： checkbox 创建一个复选框 email 创建一个接受邮件地址作为值的文本输入框 number 创建一个接收数值类型作为值的文本输入框 radio 创建一个单选框 text 创建一个接收任何值的标准文本输入框 url 创建一个接收URL作为值的文本输入框 监控表单的有效性 $pristine 如果用户没有与元素/表单产生交互，则返回true $dirty 如果用户与元素/表单产生过交互，则返回true $valid 当元素/表单内容的校验结果为有效时则返回true $invalid 当元素/表单内容的校验结果为无效时则返回true $error 提供校验错误的详情信息 原生表单验证在 form 层面，可以使用 ng-disabled来控制提交按钮的状态，在 form 表单项全部验证通过前不可点击，下面介绍一下通用的表单项验证选项。 input 验证选项AngularJS 的 input 标签 自带的验证选项有以下这些。 1234567891011&lt;input ng-model=\"\" [name=\"\"] [required=\"\"] [ng-required=\"\"] [ng-minlength=\"\"] [ng-maxlength=\"\"] [ng-pattern=\"\"] [ng-change=\"\"]&gt;...&lt;/input&gt; a. 必填 1&lt;input type=\"text\" name=\"myName\" ng-model=\"username\" required /&gt; 使用ng-required可以根据后面表达式的值设置是否 required。 在不满足required时form.myName.$error 为 {required: true} 。b. 长度 1&lt;input type=\"text\" name=\"myName\" ng-model=\"username\" ng-minlength=\"2\" ng-maxlength=\"10\" /&gt; 在不满足 ng-minlength/ng-maxlength时 form.myName.$error为 {minlength: true, maxlength: true}。 直接使用minlength/maxlength也有相同效果，而且 maxlength 可以设置最多输入 x 个字符，超过之后无法再输入。 c. 模式匹配 1&lt;input type=\"text\" name=\"myDesc\" ng-model=\"desc\" ng-pattern=\"/^[a-zA-Z]&#123;1,20&#125;$/\" /&gt; 在不满足 ng-pattern时 form.myName.$error为 {pattern: true}。 d. 其他 AngularJS 对特定格式也进行了校验。比如将 type设置为 url，email等，在没有特殊验证要求的情况下，可以直接使用这些自带的校验，或者通过自定义指令修改 Angular 内建验证器。不同 type 有不同的验证选项。 CSS ClassesAngular 会根据表单状态自动给表单和表单项添加以下几组样式： ng-valid 验证通过，与之相对的是ng-invalid-ng-valid-[key]通过自定义验证器添加的验证通过的值，与之相对的是ng-invalid-[key] ng-pristine未交互状态，与之相对的是 ng-dirty ng-touched未访问状态，与之相对的是ng-untouched ng-pending 满足 $asyncValidators的情况 这些在 ngModelController 的属性中都有对应值。 根据这些 class，可以为不同状态设置不同的样式，比如这样： 1234567input.ng-valid.ng-dirty &#123; border-color: #78FA89;&#125;input.ng-invalid.ng-dirty &#123; border-color: #FA787E;&#125; 自定义验证在 AngularJS 指令入门 一文中，提到过通过 require 属性和 controller 参数，可以实现指令之间的交互。那么，在自定义指令中使用 require: &#39;ngModel&#39;就可以使用 ngModel 指令的 controller 属性的实例了。 ngModelControllerngModel 提供了数据绑定、验证、CSS更新、数据格式化和编译等操作。下面简单介绍一下 ngModelController 常用的属性和方法。 核心属性a. $viewValue视图里的值 b. $modelValue数据模型里值 在 input事件触发的时候，$viewValue会同步到 $modelValue。默认情况下，这个是一旦 input中的内容有改变就触发。AngularJS 1.3 引入了 ng-model-options，可以让这个同步延迟到 blur 或者延迟一定的时间之后。 12&lt;input type=\"text\" name=\"username\" ng-model=\"username\" ng-model-options=\"&#123;updateOn:'blur'&#125;\"&gt;&lt;input type=\"text\" name=\"username\" ng-model=\"username\" ng-model-options=\"&#123; debounce: 500 &#125;\"&gt; 在$viewValue的值同步到 $modelValue时，会经过 $parsers、$validators 和 $asyncValidators三个核心管道（后两个是 AngularJS 1.3 以后新加的）进行处理，通过后才更新到 $modelValue上（如果验证器管道没通过，不会更新）。 核心管道a. $parsers改变视图值的格式，并更新的到模型（$viewValue -&gt; $modelValue），与之相对的是 $formatters，刚好反过来。 b. $validators用来添加同步验证器 c. $asyncValidators用来添加异步验证器 常用属性a. $error没有通过的验证器名称及对应的错误信息 b. $valid表单项是否都通过验证，都通过时为 true，与之相对的是$invalid c. $touched 表单项是否被访问过，如果获得过焦点，在失去时该值为 true，与之相对的是 $untouched d.$dirty 表示用户是否和表单项交互过（比如输入一些东西），只要有任何改变，该值为 true，与之相对的是 $pristine 常用方法a. $render定义视图具体的渲染方式 b. $setViewValue设置视图值（需要手动触发一个 $digest），使用场景是在自定义指令中监听自定义事件（比如使用具有回调的 jQuery 插件） ngMessagesng-messages是 AngularJS 1.3 提供的一个用来增强模版显示的模块，主要用在处理复杂的错误信息。 在以前的版本中，如果想处理错误信息的显示，可能需要定义一堆code再结合复杂的ng-if语句来实现。而且在输入同时满足多条错误规则的情况下，无法控制错误信息显示的优先级。这些，使用 ng-messages可以完美解决。 准备工作引入 angular-messages.js添加依赖：angular.module(&#39;app&#39;, [&#39;ngMessages&#39;]) 使用方法有两种使用方法，一是将ng-messages 当作属性指令使用：1234567&lt;form name=\"myForm\"&gt; &lt;input type=\"text\" ng-model=\"field\" name=\"myField\" required minlength=\"5\" /&gt; &lt;div ng-messages=\"myForm.myField.$error\"&gt; &lt;div ng-message=\"required\"&gt;必填&lt;/div&gt; &lt;div ng-message=\"minlength\"&gt;长度不够&lt;/div&gt; &lt;/div&gt;&lt;/form&gt; 这样会按照各个错误信息书写的先后顺序进行单一显示，如果想同时显示所有的错误信息，加个ng-messages-multiple： 1&lt;div ng-messages=\"myForm.myField.$error\" ng-messages-multiple&gt;&lt;/div&gt; 另一种是将 ng-messages 当作元素指令使用：1234&lt;ng-messages for=\"myForm.myField.$error\"&gt; &lt;ng-message when=\"required\"&gt;必填&lt;/ng-message&gt; &lt;ng-message when=\"minlength\"&gt;长度不够&lt;/ng-message&gt;&lt;/ng-messages&gt; 如果很多表单项的错误提示信息都一样，也可以把错误信息放在模版里，使用ng-messages-include指令来引用： 12&lt;div ng-messages=\"myForm.username.$error\" ng-messages-include=\"validateTemplate/error.html\"&gt;&lt;/div&gt; 错误模版文件： 12&lt;div ng-message=\"required\"&gt;必填&lt;/div&gt;&lt;div ng-message=\"minlength\"&gt;长度不够&lt;/div&gt;","tags":[{"name":"Angular","slug":"Angular","permalink":"http://yutaiwei.github.io/tags/Angular/"},{"name":"前端","slug":"前端","permalink":"http://yutaiwei.github.io/tags/前端/"}]},{"title":"AngularJS 中的服务Provider","date":"2016-05-25T14:01:59.000Z","path":"2016/05/25/AngularJS 中的服务Provider/","text":"在一个分层良好的 Angular 应用中，Controller 这一层应该很薄。也就是说，应用里大部分的业务逻辑和持久化数据都应该放在 Service 里。 为此，理解 AngularJS 中的几个 Provider 之间的区别很有必要。Provider 创建的新服务都可以用来注入。包括： provider factory service constant value 另外，内建的服务$controller和$filter 也可以被注入，同时也可以使用这些服务来获得新的过滤器和控制器。 下面介绍一下各自的用法和 provider、factory、value 三者之间的区别。 provider用于产生一个可配置的 Service，由两部分组成。第一部分的变量和函数是可以在app.config函数中访问的，可以在它们被其他地方访问到之前来修改它们。定义方式如下： 1234app.provider('myProvider', function()&#123; var a = ''; var func = function()&#123;&#125;;&#125;) 在 app.config函数对 a进行修改： 123app.config(function(myProviderProvider)&#123; myProvider.a = 'hello world';&#125;) 这也是在有如此简单的 factory 的情况下还使用 provider 的原因。 第二部分的变量和函数是通过$get()函数返回的，可以在任何传入了该 provider 的控制器中进行访问的。 12345678app.provider('myProvider', function()&#123; this.$get = function()&#123; return &#123; foo: function()&#123;&#125;, a: a &#125; &#125;&#125;) factoryfactory 返回一个对象。只需要创建一个对象，为它添加属性，然后返回这个对象。在控制器中注入该 factory，即可使用它的所有属性。 123456app.factory('myFactory', function()&#123; var fac = &#123;&#125;; fac.a = 'hello world'; fac.foo = function()&#123;&#125;; return fac;&#125;) 看得出来，factory 的第二个参数就是 provider 中$get要对应的函数实现。 serviceservice 类似于一个构造器， 通过new关键字实例化对象，将一些属性和方法直接添加到 this上，在创建 service 对象时，this会被作为返回值返回。 123456app.service('myService', function()&#123; var a = ''; this.setA = function()&#123;&#125;; this.getA = function()&#123;&#125;; this.foo = function()&#123;&#125;;&#125;) 注入myService 的控制器可以访问到绑定在myService 中 this上的 setA(),getA() 和 foo()三个方法。 constantconstant 用于定义常量，一旦定义就不能被改变。可以被注入到任何地方，但是不能被装饰器(decorator)装饰。 app.constant(‘APP_KEY’, ‘a1s2d3f4’) value与 constant 一样，可以用来定义值。但与 constant 的区别是：可以被修改，可以被 decorator 装饰，不能被注入到 config 中。 app.value(‘version’, ‘1.0’) value 通常用来为应用设置初始值。 decorator比较特殊，它不是 provider 。它是用来装饰其他 provider 的，不过 constant 除外，因为从源码可以看出，constant 不是通过 provider()方法创建的。 下面是一个用 decorator 装饰 value 的栗子。 1234app.value('version', '1.0');app.decorator('version', function ($delegate) &#123; return $delegate + '.1';&#125;) 那如果要使用前面的myService service，但是其中缺少一个你想要的 greet 函数。可以修改 service 吗？答案是不行！但是可以装饰它： 12345app.decorator('myService', function($delegate)&#123; $delegate.greet = function()&#123; return \"Hello, I am a new function of 'myService'\"; &#125;&#125;) $delegate代表实际上的 service 实例。 装饰一个 service 的能力是非常实用的，尤其是当我们想要使用第三方的 service 时，此时不需要将代码复制到我们的项目中，而只需要进行一些修改即可。 什么时候使用 provider 而不用 factory ？provider 是 factory 的加强版。当需要一个可配置的 factory 的时候，使用 provider。 简单介绍一下 AngularJS 运行应用的过程，分两个阶段，config 阶段和 run 阶段。config 阶段是设置任何的 provider 的阶段。也是设置任何的指令，控制器，过滤器以及其它东西的阶段。在 run 阶段，AngularJS 会编译你的 DOM 并启动应用。 factory 和 service 的区别是什么？factory 是普通 function，而 service 是一个构造器(constructor)，这样 Angular 在调用 service 时会用 new 关键字，而调用 factory 时只是调用普通的 function，所以 factory 可以返回任何东西，而 service 可以不返回。 参考 AngularJS 之 Factory vs Service vs Provider 理解AngularJS中的Service类型 AngularJS中的Provider们：Service和Factory等的区别","tags":[{"name":"Angular","slug":"Angular","permalink":"http://yutaiwei.github.io/tags/Angular/"},{"name":"前端","slug":"前端","permalink":"http://yutaiwei.github.io/tags/前端/"}]},{"title":"AngularJS 中 Controller 之间的通信","date":"2016-03-22T14:01:59.000Z","path":"2016/03/22/AngularJS 中 Controller 之间的通信/","text":"用 Angular 进行开发，基本上都会遇到 Controller 之间通信的问题，本文对此进行一个总结。 在 Angular 中，Controller 之间通信的方式主要有三种： 作用域继承。利用子 Controller 控制父 Controller 上的数据。（父 Controller 中的数据要为引用类型，不能是基本类型） 注入服务。把需要共享的数据注册为一个service，在需要的 Controller 中注入。 基于事件。利用 Angular 的事件机制，使用 $on、$emit和 $boardcast 其中，作用域继承仅限于上下级之间的通信，注入服务和基于事件的机制可以实现任意级别的 Controller 通信。 作用域继承这里直接上栗子。 页面： 123456&lt;div ng-controller=\"parentCtrl\"&gt; &lt;p&gt;data in parent controller : &#123;&#123;data.name&#125;&#125;&lt;/p&gt; &lt;div ng-controller=\"childCtrl\"&gt; &lt;input type=\"text\" ng-model=\"data.name\"&gt; &lt;/div&gt;&lt;/div&gt; 控制器： 1234567891011angular.module('demo', []).controller('parentCtrl', ['$scope', function($scope)&#123; $scope.data = &#123; name: 'htf' &#125;&#125;]).controller('childCtrl', ['$scope', function($scope)&#123; &#125;]) 以上是父 Controller 中的数据是引用类型的情况。如果父 Controller 中的数据是基本类型，可通过$scope.$parent.data 访问。 很显然，这种方式仅适用于父子级间 Controller 的通信。 注入服务在 Angular 中，服务是一个单例，所以在服务中生成一个对象，该对象就可以利用依赖注入的方式在所有的控制器中共享。 看个栗子，先定义一个service: 123456angular.module('demo') .factory('Data', function()&#123; return &#123; name: 'htf' &#125;; &#125;) 页面： 12345678&lt;div ng-controller=\"childCtrl1\"&gt; &lt;h3&gt;data in child controller 1 : &#123;&#123;data.name&#125;&#125;&lt;/h3&gt; &lt;input class=\"form-control\" type=\"text\" ng-model=\"data.name\"&gt;&lt;/div&gt;&lt;div ng-controller=\"childCtrl2\"&gt; &lt;h3&gt;data in child controller 2 : &#123;&#123;data.name&#125;&#125;&lt;/h3&gt; &lt;input class=\"form-control\" type=\"text\" ng-model=\"data.name\"&gt;&lt;/div&gt; 控制器： 1234567.controller('childCtrl1', ['$scope', 'Data', function($scope, Data)&#123; $scope.data = Data;&#125;]).controller('childCtrl2', ['$scope', 'Data', function($scope, Data)&#123; $scope.data = Data;&#125;]) 这种方式适用于任何需要通信的 Controller 之间。 基于事件Angular 为$scope 提供了冒泡和隧道机制，$broadcast会把事件广播给所有子 Controller，而$emit则会将事件冒泡传递给父 Controller，$on则是 Angular 的事件监听函数，利用这三者，可以实现上下级和同级（需要构造一个共同的父级 Controller）之间的通信。 上下级之间这种情况下比较简单。 如果是子 Controller 往父 Controller 上发送事件（从作用域往上发送事件），使用scope.$emit $scope.$emit&#40;”someEvent”, {}&#41;; 如果是父 Controller 往子 Controller 上发送事件（从作用域往下发送事件），使用 scope.$broadcast $scope.$broadcast(“someEvent”, {}); 无论是 $emit还是 $broadcast发送的事件，都用 $scope.$on接收：123$scope.$on(\"someEvent\", function(event, data) &#123; // 这里取到发送过来的数据 data&#125;); 同级之间同级之间利用事件通信有两种方法。一种是利用上下级之间事件传播的变形，另一种是借助 $rootScope 。 借助父 controller 先看第一种，在子 Controller 中向父 Controller 触发一个事件，然后在父 Controller 中监听事件，再广播给子 Controller ，这样通过事件携带的参数，实现了数据经过父 Controller，在同级 Controller 之间传播。 但是要注意，通过父 Controller 作为中介进行传递的话，子 Controller 触发的事件名和父 Controller 广播用的事件名不能一样，否则会进入死循环。 看代码：123456789&lt;div ng-controller=\"outerCtrl\"&gt; &lt;h3&gt;data in outer controller: &#123;&#123;name&#125;&#125;&lt;/h3&gt; &lt;div ng-controller=\"innerCtrl1\"&gt; &lt;input class=\"form-control\" type=\"text\" ng-model=\"name\" ng-change=\"change()\"&gt; &lt;/div&gt; &lt;div ng-controller=\"innerCtrl2\"&gt; &lt;input class=\"form-control\" type=\"text\" ng-model=\"name\" ng-change=\"change()\"&gt; &lt;/div&gt;&lt;/div&gt; 关键部分在控制器： 12345678910111213141516171819202122232425262728.controller('outerCtrl', ['$scope', function($scope)&#123; $scope.name = 'htf'; $scope.$on('dataChanged', function(event, data)&#123; $scope.name = data; // 2. 父 Ctrl 监听到 dataChanged 时间后，触发 changeData 事件 $scope.$broadcast('changeData', data); &#125;)&#125;]).controller('innerCtrl1', ['$scope', function($scope)&#123; $scope.change = function()&#123; // 1. 子 Ctrl1 中数据改变之后触发 dataChanged 事件 $scope.$emit('dataChanged', $scope.name); &#125; $scope.$on('changeData', function(event, data)&#123; $scope.name = data; &#125;)&#125;]).controller('innerCtrl2', ['$scope', function($scope)&#123; $scope.change = function()&#123; $scope.$emit('dataChanged', $scope.name); &#125; // 3. 监听到 changeData 事件后，改变子 Ctrl2 中 数据 $scope.$on('changeData', function(event, data)&#123; $scope.name = data; &#125;)&#125;]) 借助 $rootScope 每个 Angular 应用默认有一个根作用域$rootScope， 根作用域位于最顶层，从它往下挂着各级作用域。 所以，如果子控制器直接使用 $rootScope广播和接收事件，那么就可实现同级之间的通信。 看栗子： 123456&lt;div ng-controller=\"innerCtrlA\"&gt; &lt;input class=\"form-control\" type=\"text\" ng-model=\"name\" ng-change=\"change()\"&gt;&lt;/div&gt;&lt;div ng-controller=\"innerCtrlB\"&gt; &lt;input class=\"form-control\" type=\"text\" ng-model=\"name\" ng-change=\"change()\"&gt;&lt;/div&gt; 控制器： 12345678910111213141516171819.controller('innerCtrlA', ['$scope', '$rootScope', function($scope, $rootScope)&#123; $scope.change = function()&#123; // 广播事件 $rootScope.$broadcast('nameChanged', $scope.name); &#125; $rootScope.$on('nameChanged', function(event, data)&#123; $scope.name = data; &#125;)&#125;]).controller('innerCtrlB', ['$scope', '$rootScope', function($scope, $rootScope)&#123; $scope.change = function()&#123; $rootScope.$broadcast('nameChanged', $scope.name); &#125; // 监听事件 $rootScope.$on('nameChanged', function(event, data)&#123; $scope.name = data; &#125;)&#125;]) 参考 作用域与事件 Angularjs Controller 间通信机制 AngularJS控制器controller如何通信？ controller 间共享数据","tags":[{"name":"Angular","slug":"Angular","permalink":"http://yutaiwei.github.io/tags/Angular/"},{"name":"前端","slug":"前端","permalink":"http://yutaiwei.github.io/tags/前端/"}]},{"title":"AngularJS中的作用域","date":"2015-12-13T14:01:59.000Z","path":"2015/12/13/AngularJS中的作用域/","text":"问题引入使用 Angular 进行过一段时间的开发后，基本上都会遇到一个这样的坑： 123456789101112&lt;div ng-controller=\"TestCtrl\"&gt; &lt;p&gt;&#123;&#123;name&#125;&#125;&lt;/p&gt; &lt;div ng-if=\"show\"&gt; &lt;input type=\"text\" ng-model=\"name\"&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt;function TestCtrl($scope)&#123; $scope.show = true; $scope.name = 'htf';&#125;&lt;/script&gt; 把p 元素和input元素绑定同一个变量，你本以为，在输入框输入内容，p中显示的肯定也是随之变化的。 然而并不是这样，不管input 中的元素怎么变， p元素中的都没变化，WTF。 要说这是什么原因，那就要从 Angular 的作用域说起了。 作用域每个 Angular 应用默认有一个根作用域 $rootScope， 根作用域位于最顶层，从它往下挂着各级作用域。 通常情况下，页面中ng-model 绑定的变量都是在对应的 Controller 中定义的。如果一个变量未在当前作用域中定义，JavaScript 会通过当前 Controller 的 prototype 向上查找，也就是作用域的继承。 这又分两种情况。 基本类型变量 12345678910111213&lt;div ng-controller=\"OuterCtrl\"&gt; &lt;p&gt;&#123;&#123;x&#125;&#125;&lt;/p&gt; &lt;div ng-controller=\"InnerCtrl\"&gt; &lt;input type=\"text\" ng-model=\"x\"&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt;function OuterCtrl($scope)&#123; $scope.x = 'hello';&#125;function InnerCtrl($scope)&#123;&#125;&lt;/script&gt; 运行后会发现跟文章开头一样的问题，里面输入框变了，外面的没跟着变。 原因在于，InnerCtrl中并未定义x这个变量，取值的时候，会沿着原型链向上找，找到了OuterCtrl中定义的 x，然后赋值给自己，在InnerCtrl的输入框输入值时，改变的是InnerCtrl 中的x ，而对 OuterCtrl中的x无影响。此时，两个x是独立的。 不过，如果你不嫌麻烦的话，用$scope.$parent 可以绑定并影响上一层作用域中的基本变量： 1&lt;input type=\"text\" ng-model=\"$parent.x\"&gt; 引用类型变量那么，如果上下级作用域想共用变量怎么办呢？ 答案是使用引用类型变量。 1234567891011121314&lt;div ng-controller=\"OuterCtrl\"&gt; &lt;p&gt;&#123;&#123;x&#125;&#125;&lt;/p&gt; &lt;div ng-controller=\"InnerCtrl\"&gt; &lt;input type=\"text\" ng-model=\"x\"&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt;function OuterCtrl($scope)&#123; $scope.data = &#123;&#125;; $scope.data.x = 'hello';&#125;function InnerCtrl($scope)&#123;&#125;&lt;/script&gt; 在这种情况下，两者的 data是同一个引用，对这个对象上面的属性修改，是可以反映到两级对象上的。 ng-if中的作用域前面讲的是两级控制器之间的作用域，那跟前面提到的问题有什么关系呢？那个看着不是只有一个 Controller 吗？ 其实，并不是只有 Controller 可以创建作用域，ng-if等指令也会（隐式地）产生新作用域。 总结下来就是，ng-if、ng-switch 、ng-include 等会动态创建一块界面的东西，都是自带一级作用域。 因此，在开发过程中，为了避免模板中的变量歧义，应当尽可能使用命名限定，比如data.x，出现歧义的可能性就比单独的x要少得多。 总结始终将页面中的元素绑定到对象的属性（data.x）而不是 直接绑定到基本变量（x）上。 参考AngularJS实例教程（二）——作用域与事件","tags":[{"name":"Angular","slug":"Angular","permalink":"http://yutaiwei.github.io/tags/Angular/"},{"name":"前端","slug":"前端","permalink":"http://yutaiwei.github.io/tags/前端/"}]},{"title":"Angular JS 指令入门","date":"2015-11-05T12:01:59.000Z","path":"2015/11/05/Angular JS 指令入门/","text":"Angular JS 指令入门指令是运行在特定 dom 元素上的函数，用来扩展元素的功能。 一个简版的 directive 的形式是这样的 123456789101112app.directive('myDirective', myDirective);myDirective.$inject = [];function myDirective()&#123; return &#123; restrict: \"AE\", template: '' scope: &#123;&#125;, link: function()&#123;&#125; &#125;&#125; 下面介绍一些常用的选项。 选项restrict &#40;String&#41;表示指令在 dom 中以何种形式被声明 E 元素 A 属性（默认值） C 类名 M 注释（不建议使用） 属性（E）是最常用的声明指令方式，因为能兼容老版本IE，且不引入新标签。元素（A）方式适合创建一个完全独立、完整的组件。 priority（Number）指令优先级，默认为 0（最高1000，比如 ng-repeat ），如果需要同一元素上一个指令比另一个指令先被调用，可给它设置更高的优先级。 在 Angular 1.2 里面，如果使用 checkbox，同时绑定ng-model 和 ng-click，然后根据ng-model 的值在ng-click里进行相应的处理，像下面这样： 123456789&lt;input type=\"checkbox\" ng-model=\"formData.status\" ng-click=\"check()\"&gt;$scope.check = function()&#123; if($scope.formData.status)&#123; alert('true'); &#125;else&#123; alert('false'); &#125;&#125; 会发现，ng-model的值和 check里面的逻辑是相反的。其实这是因为在 Angular 1.2 里面，ng-click 的优先级比 ng-model高，导致在值更新前，ng-click就被触发。修复办法是用 ng-change替换 ng-click 。在 Angular 1.3 以上版本已经修复了这个问题。 template 和 templateUrl（String || Function）HTML 模版文件。 在调用指令后，模版文件是通过 XHR 来加载的，加载后会缓存到 $templateCache 服务中。 通过 AJAX 异步加载大量的模版会拖慢一个 Angular 应用的速度。可以提前将模版缓存到一个定义模版的 js 文件中，或者在加载ng-app 的首页同时将模版以 script 标签加载，然后在配置template的地方通过 js 获取。 123456&lt;script id=\"pagerTpl\" type=\"text/html\"&gt; &lt;div&gt;...&lt;/div&gt;&lt;/script&gt;template: document.querySelector('#pagerTpl').innerHTML transclude（Boolean）当指令定义的标签内部也有标签的时候，transclude设置为true可以让子标签的内容保持不变。 transclude 通常用来创建可复用的组件，可以将整个模版，包括其中的指令通过 transclude 全部传入一个指令中。典型的应用是模态对话框或导航栏。 replace（Boolean）replace 默认为false，表示模版会被当作子元素插入到调用此指令的元素内部。 设置为 true，则指令会被模版替换掉。 scope（Boolean || Object）scope默认为false，表示指令内和指令外共用同一作用域。设置为 true 的时候，表示从父作用域继承并创建一个新的作用域对象（是不是感觉很像 ng-show 和 ng-if 的区别），不过这两种情况用的比较少（作用域污染）。 最常用的通过一个空对象{ }，产生一个隔离作用域，用于创建可复用的组件。组件可以在未知上下文中使用，并且组件所处的外部作用域和内部作用域不会被不经意地污染。 但大多时候并不会直接使用无数据的隔离作用域。有三种办法让内部的隔离作用域同外部的作用域进行数据绑定。 == 是最常用的方式，通过它可以将本地作用域的属性同父级作用域上的属性进行双向绑定。 在元素中使用属性的方式为（不可以使用 {&#123; &#125;} ）： 12345&lt;div my-directive age=\"age\"&gt;&lt;/div&gt;scope: &#123; age: '='&#125; @使用 @可以将本地作用域同 dom 属性的值进行单向绑定，在使用父作用域中的值对指令中的属性初始赋值后，指令中属性值的修改不会影响父作用域中的值。 在元素中的使用方式为（有 {&#123; &#125;}）： 123456&lt;div my-directive my-name=\"&#123;&#123;name&#125;&#125;\"&gt;&lt;/div&gt;// 视图中的 - 连接的属性转换到指令定义中要使用驼峰式scope: &#123; name: '@myName'&#125; &amp;这是一个绑定函数方法的前缀标识符，通过 &amp; 可以对父级作用域进行绑定，以便在其中运行函数。 在元素中的使用方式为： 12345&lt;div my-directive change=\"changeName()\"&gt;&lt;/div&gt;scope: &#123; changeName: '&amp;change'&#125; controller（String || Function）一般情况下不需要使用指令的controller，只要使用 link就够了，controller和 link函数可以互换。但它是在预编译阶段执行的（先于compile）。 用controller的场景是该指令（a）会被其他指令（b）require 的时候，在 b 的指令里可以传入 a 的这个 controller，目的是为了指令间的复用和交流。而link 只能在指令内部中定义行为，无法做到这样。 controller的形式是这样的： 123controller: function($scope, $ele, $attrs, $transclude)&#123; ...&#125; require（String || Array）一般情况下不需要使用 require，它是和controller结合用的。require 参数用来引入其他指令或一个指令数组，并将引入指令的 controller 传给 link 函数的第四个参数。 编译 和 链接AngularJS 应用启动后，会经历两个阶段。一是编译阶段（compile），对模版dom进行转换（指令标签解析和变换），二是链接阶段（link），将作用域和 dom进行链接（数据绑定）。 编译在编译阶段，AngularJS 会遍历整个 HTML 文档并根据 JavaScript 中的指令定义来处理页面上声明的指令。 编译阶段可以改变原始的 dom（template element），由于此阶段还未对dom树进行数据绑定，所以此时对 dom树操作只需要较少的性能开销。比如ng-repeat（改变原始 dom生成多个 dom 节点） 和 ng-transclude（嵌入模版到指令中） 都是在这个阶段对 dom进行操作。 compile后，返回一个函数（link）或对象（preLink和postLink）。 compile 函数形式： 123456789/*** Compile function* * @param tElem - template element* @param tAttrs - attributes of the template element*/function(tEle, tAttrs)&#123; ...&#125; 链接链接阶段完成作用域和 dom 之间数据的绑定，dom事件监听器的注册，也是在这个阶段做。 link 函数形式： 1234function(scope, iElem, iAttrs, ctrl)&#123; ...&#125; 如果指令定义中有require 选项，link的函数签名中还会有第四个参数，代表控制器或所依赖指令的控制器。 声明指令123456789101112131415161718192021222324//默认不会产生任何作用域app.directive('direName',function()&#123; return &#123; require:'^?group', //^表示当前找不到则向上一级找，找不到则报错？找不到则不报错，注入进来的东西是null controller:function($scope)&#123;&#125;, restrict:'EA',//限制替换的范围 template:'',//要替换的模板/templateUrl:'tmpl/open.html' replace:false,//不替换外部的标签 transclude:true,//保留指令中的内容插入到带有ng-transclude的标签中 link:function(scope,element,attrs,ctrl)&#123; //操作dom元素 //scope当前指令所在的作用域，自己没有作用域则向上查找 //element jq对象（angular内置的），jquery要引入到angular之前，angular发现自己加载过了jquery，就不会加载自己的jquery了 //attrs 当前指令所有属性的集合 //ctrl代表的就是当前依赖的指令的控制器的实例 &#125;, scope:&#123; title:'@',//通过属性传递 获取的是属性对应的字符串 name:'=n',//通过属性传递 获取的是属性对应作用域上的变量 fn:'&amp;say' //通过属性传递一个方法，必须以对象的方式传递 say(&#123;n:1&#125;); &#125;/true //1.&#123;&#125; 完全和父作用域断绝关系 //2.true 产生作用域但是不断绝作用域的关系 &#125;&#125;); 两者区别 compile 是对指令的模板进行转换，link 是在模型和视图之间建立关联（包括注册事件监听） compile 对同一个指令的多个实例只会执行一次，link 对于指令的每个实例都会执行一次 compile 和 link 是互斥的，编写了 compile，自定义的 link 将无效 一般情况下只需要编写 link 栗子举个简单的行内编辑的栗子，默认显示，双击可编辑。 directive 文件 1234567891011121314151617181920212223242526272829app.directive('inlineEdit', inlineEdit);inlineEdit.$inject = ['$document'];function inlineEdit($document)&#123; return &#123; restrict: 'A', templateUrl: 'inline-edit.html', scope: &#123; desc: '=ngModel' &#125;, link: function(scope, ele, attrs)&#123; scope.isEdit = false; ele.on('dblclick', function()&#123; scope.isEdit = true; scope.$digest(); &#125;) $document.on('click', function(evt)&#123; var src = evt.srcElement || evt.target, parent = src.parentNode; if(parent.classList &amp;&amp; parent.classList[0] == 'inline-container')&#123; return; &#125; scope.isEdit = false; scope.$digest(); &#125;) &#125; &#125;&#125; template 文件 123456&lt;div class=\"inline-container\" ng-show=\"isEdit\"&gt; &lt;input type=\"text\" ng-model=\"desc\"&gt;&lt;/div&gt;&lt;div ng-if=\"!isEdit\"&gt; &#123;&#123;desc&#125;&#125;&lt;/div&gt; 然后，可以这样使用 1&lt;div ng-model=\"desc\" inline-edit&gt;&lt;/div&gt;","tags":[{"name":"Angular","slug":"Angular","permalink":"http://yutaiwei.github.io/tags/Angular/"},{"name":"前端","slug":"前端","permalink":"http://yutaiwei.github.io/tags/前端/"}]},{"title":"AngularJS入门篇","date":"2015-11-02T11:53:09.000Z","path":"2015/11/02/AngularJS入门篇/","text":"前言AngularJS是一个JavaScript框架，它通过指令扩展了HTML，且通过表达式绑定数据到 HTML。顺便一提，什么是框架？比如struts2、spring、hibernate、thinkphp、wordpress等等。那么，什么是组件？比如jdbc、jquery、swiper、layer、arttemplate等等。 一般来说，那些可复用的、用于简化开发工作的代码集合，大的叫框架，小的叫组件。有人说jquery是框架？当然可以，大小并没有明确边界。不要太纠结于概念，如无必要，勿增实体。 本文，主要学习归纳一下Angular的各种特性，包括双向数据绑定、定义应用和控制器、优化模板渲染延迟、自定义指令、作用域、HTTP请求获取数据、自定义服务、依赖注入、路由控制等。最后，会给出一个综合实例。 双向数据绑定单向数据绑定的原理：模板+数据=&gt;视图。目前大多数前端框架都是单向数据绑定，比如jQueryUI、BackBone、Flex。 双向数据绑定原理：模板+数据=&gt;视图，模板+视图=&gt;数据。 Angular采用的，就是双向数据绑定。 123456789101112131415&lt;!--helloworld.html--&gt;&lt;!DOCTYPE html&gt;&lt;html ng-app&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;双向数据绑定&lt;/title&gt; &lt;script src=\"http://code.angularjs.org/angular-1.0.1.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; Hello &#123;&#123;'World'&#125;&#125;!&lt;br/&gt; Your name: &lt;input type=\"text\" ng-model=\"yourname\" placeholder=\"World\"&gt; &lt;hr&gt; Hello &#123;&#123;yourname || 'World'&#125;&#125;!&lt;/body&gt;&lt;/html&gt; 定义应用和控制器angular对象，是Angular的根对象。类似于express框架中的express对象，类似于seajs框架的seajs对象，类似于浏览器的window对象。如果说angular对象是Angular中的班主任，那么应用（或者叫模块，app）就是Angular中的班长！而班主任不常出没，管事的就是班长。控制器（controller），就是普通同学小明，负责控制Angular应用程序中的数据。 123456789101112131415161718192021222324252627282930313233343536&lt;!--app.html--&gt;&lt;!DOCTYPE html&gt;&lt;html ng-app=\"myApp\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;定义应用和控制器&lt;/title&gt; &lt;style&gt; [ng\\:cloak], [ng-cloak], [data-ng-cloak], [x-ng-cloak], .ng-cloak, .x-ng-cloak &#123; display: none !important; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div ng-controller=\"myCtrl\"&gt; 名: &lt;input type=\"text\" ng-model=\"firstName\"&gt;&lt;br&gt; 姓: &lt;input type=\"text\" ng-model=\"lastName\"&gt;&lt;br&gt; &lt;br&gt; 姓名: &lt;span&gt;&#123;&#123;firstName + \" \" + lastName&#125;&#125;&lt;/span&gt;&lt;br&gt; 姓名2: &lt;span class=\"ng-cloak\"&gt;&#123;&#123;fullName()&#125;&#125;&lt;/span&gt;&lt;br&gt; 姓名3: &lt;span ng-bind=\"fullName()\"&gt;&lt;/span&gt; &lt;/div&gt; &lt;script src=\"http://code.angularjs.org/angular-1.0.1.min.js\"&gt;&lt;/script&gt; &lt;script&gt; var app = angular.module('myApp', []); app.controller('myCtrl', function($scope) &#123; $scope.firstName= \"John\"; $scope.lastName= \"Doe\"; $scope.fullName = function() &#123; return $scope.firstName + \" \" + $scope.lastName; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 优化模板渲染延迟在定义应用和控制器的例子中，我们看到，页面上先出现了表达式，之后才出现我们期望的结果。解决这个问题，常用的有两个办法。一个是使用ng-bind，另一个是添加ng-cloak样式。 自定义指令12345678910111213141516171819202122232425262728&lt;!--directive.html--&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;自定义指令&lt;/title&gt; &lt;script src=\"http://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js\"&gt;&lt;/script&gt; &lt;/head&gt;&lt;body ng-app=\"myApp\"&gt; &lt;runoob-directive&gt;&lt;/runoob-directive&gt; &lt;div runoob-directive&gt;&lt;/div&gt; &lt;div class=\"runoob-directive\"&gt;&lt;/div&gt; &lt;!-- 指令: runoob-directive --&gt; &lt;script&gt; var app = angular.module(\"myApp\", []); app.directive(\"runoobDirective\", function() &#123; return &#123; //restrict : \"A\", //restrict : \"C\", //restrict : \"M\", //replace : true, template : \"&lt;h1&gt;自定义指令!&lt;/h1&gt;\" &#125;; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 作用域12345678910111213141516171819202122232425262728&lt;!--scope.html--&gt;&lt;!DOCTYPE html&gt;&lt;html ng-app=\"myApp\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;作用域&lt;/title&gt; &lt;script src=\"http://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div ng-controller=\"myCtrl\"&gt; &lt;h1&gt;姓氏为 &#123;&#123;lastname&#125;&#125; 家族成员:&lt;/h1&gt; &lt;ul&gt; &lt;li ng-repeat=\"x in names\"&gt;&#123;&#123;x&#125;&#125; &#123;&#123;lastname&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; var app = angular.module('myApp', []); app.controller('myCtrl', function($scope, $rootScope) &#123; $scope.names = [\"Emil\", \"Tobias\", \"Linus\"]; $rootScope.lastname = \"Refsnes\"; &#125;); &lt;/script&gt; &lt;p&gt;注意 $rootScope 在循环对象内外都可以访问。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 上面的例子中，$scope的作用域为myCtrl这个ng-controller的范围，$rootScope的作用域为myApp这个ng-app的范围。 HTTP请求获取数据获取本地数据123456789101112131415161718192021222324&lt;!--http.html--&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;HTTP请求&lt;/title&gt; &lt;script src=\"http://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body ng-app=\"myApp\" &gt; &lt;div ng-controller=\"myCtrl\"&gt; &lt;h1&gt;欢迎你！&#123;&#123;username&#125;&#125;&lt;/h1&gt; &lt;/div&gt; &lt;p&gt; $http 服务向服务器请求信息，返回的值放入变量 \"username\" 中。&lt;/p&gt;&lt;script&gt; var app = angular.module('myApp', []); app.controller('myCtrl', function($scope, $http) &#123; $http.get(\"http.json\").then(function (response) &#123; $scope.username = response.data.username; &#125;); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; http.json中的内容为：123&#123; \"username\":\"voidking\" &#125; 需要注意的是，本例需要在服务器中访问。因为Angular的HTTP请求封装了XMLHttpRequest，而XMLHttpRequest的使用需要服务器环境。 获取服务器数据123456789101112131415161718192021222324252627282930313233343536373839&lt;!--http2.html--&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;HTTP请求服务器数据&lt;/title&gt; &lt;script src=\"http://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body ng-app=\"myApp\" &gt; &lt;div ng-controller=\"myCtrl\"&gt; &lt;h1&gt;欢迎你！&#123;&#123;username&#125;&#125;&lt;/h1&gt; &lt;/div&gt; &lt;p&gt; $http 服务向服务器请求信息，返回的值放入变量 \"username\" 中。&lt;/p&gt;&lt;script&gt; var app = angular.module('myApp', []); app.controller('myCtrl', function($scope, $http, $httpParamSerializer) &#123; $http(&#123; method:'POST', url:'/angulardemo/http.php', headers:&#123; 'Content-Type':'application/x-www-form-urlencoded' &#125;, dataType: 'json', data: $httpParamSerializer(&#123;username:'voidking'&#125;) &#125;).then(function successCallback(response) &#123; console.log(response.data); $scope.username = response.data.username; &#125;, function errorCallback(response) &#123; console.log(response.data); &#125;);; &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 新建http.php，内容如下：123456789&lt;?php $username = $_POST['username']; $result = array( 'code' =&gt; '0', 'ext' =&gt; 'success', 'username' =&gt; $username ); echo json_encode($result);?&gt; 自定义服务123456789101112131415161718192021222324252627282930313233343536373839&lt;!--service.html--&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;自定义Service&lt;/title&gt; &lt;script src=\"http://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body ng-app=\"myApp\" &gt; &lt;div ng-controller=\"myCtrl\"&gt; &lt;p&gt;自定义服务，用于转换16进制数：&lt;/p&gt; &lt;p&gt;255 的16进制是:&lt;/p&gt; &lt;h1&gt;&#123;&#123;hex&#125;&#125;&lt;/h1&gt; &lt;hr&gt; &lt;p&gt;在获取数组 [255, 251, 200] 值时使用过滤器:&lt;/p&gt; &lt;ul&gt; &lt;li ng-repeat=\"x in counts\"&gt;&#123;&#123;x | myFormat&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;script&gt; var app = angular.module('myApp', []); app.service('hexafy', function() &#123; this.myFunc = function (x) &#123; return x.toString(16); &#125; &#125;); app.controller('myCtrl', function($scope, hexafy) &#123; $scope.hex = hexafy.myFunc(255); $scope.counts = [255, 251, 200]; &#125;); app.filter('myFormat',['hexafy', function(hexafy) &#123; return function(x) &#123; return hexafy.myFunc(x); &#125;; &#125;]);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 当创建了自定义服务，并连接到应用上后，我们可以在控制器，指令，过滤器或其他服务中使用它。 依赖注入AngularJS 提供很好的依赖注入机制。什么是依赖注入？wiki 上的解释是：依赖注入（Dependency Injection，简称DI）是一种软件设计模式，在这种模式下，一个或更多的依赖（或服务）被注入（或者通过引用传递）到一个独立的对象（或客户端）中，然后成为了该客户端状态的一部分。该模式分离了客户端依赖本身行为的创建，这使得程序设计变得松耦合，并遵循了依赖反转和单一职责原则。与服务定位器模式形成直接对比的是，它允许客户端了解客户端如何使用该系统找到依赖。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293&lt;!--di.html--&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;AngularJS依赖注入&lt;/title&gt;&lt;/head&gt; &lt;body ng-app=\"mainApp\" &gt; &lt;h2&gt;AngularJS 简单应用&lt;/h2&gt; &lt;div ng-controller=\"CalcController\"&gt; &lt;p&gt;配置：&#123;&#123;constant&#125;&#125;&lt;/p&gt; &lt;p&gt;输入一个数字: &lt;input type = \"number\" ng-model = \"number\" /&gt;&lt;/p&gt; &lt;button ng-click = \"square()\"&gt;X&lt;sup&gt;2&lt;/sup&gt;&lt;/button&gt; &lt;p&gt;结果: &#123;&#123;result&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;hr&gt; &lt;div ng-controller=\"CalcController2\"&gt; &lt;p&gt;再输入一个数字: &lt;input type = \"number\" ng-model = \"number\" /&gt;&lt;/p&gt; &lt;button ng-click = \"square()\"&gt;X&lt;sup&gt;2&lt;/sup&gt;&lt;/button&gt; &lt;p&gt;结果: &#123;&#123;result&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script src=\"http://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js\"&gt;&lt;/script&gt;&lt;script&gt; var mainApp = angular.module(\"mainApp\", []); mainApp.config(function($provide) &#123; // 创建一个名叫MathService的provider $provide.provider('MathService', function() &#123; this.$get = function() &#123; var factory = &#123;&#125;; factory.multiply = function(a, b) &#123; return a * b; &#125; return factory; &#125;; &#125;); &#125;); // 创建一个名叫defaultInput的value mainApp.value(\"defaultInput\", 5); // 创建一个名叫constant的constant value mainApp.constant(\"constant\", \"constant value\"); // 将MathService、defaultInput、constant注入到控制器 mainApp.controller('CalcController', function($scope, MathService, defaultInput, constant) &#123; $scope.number = defaultInput; $scope.constant = constant; $scope.result = MathService.multiply($scope.number,$scope.number); $scope.square = function() &#123; $scope.result = MathService.multiply($scope.number,$scope.number); &#125; &#125;); /*--------以下是CalcController2的内容--------*/ // 创建一个名叫MathService2的factory mainApp.factory('MathService2', function() &#123; var factory = &#123;&#125;; factory.multiply = function(a, b) &#123; return a * b; &#125; return factory; &#125;); // 创建一个名叫CalcService2的service，并且注入MathService2 mainApp.service('CalcService2', function(MathService2)&#123; this.square = function(a) &#123; return MathService2.multiply(a,a); &#125; &#125;); // 将CalcService2注入到控制器 mainApp.controller('CalcController2',function($scope,CalcService2)&#123; $scope.number = 6; $scope.result = CalcService2.square($scope.number); $scope.square = function() &#123; $scope.result = CalcService2.square($scope.number,$scope.number); &#125; &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; provider()函数是用来创建provider对象的标准方法。 实际上，value()、constant()、factory()、service()全都是用来创建一个provider对象的方法，它们提供了一种方式来定义一个provider，而无需输入所有的复杂的代码。 路由控制AngularJS 路由允许我们通过不同的 URL 访问不同的内容。通过 AngularJS 可以实现多视图的单页Web应用（single page web application，SPA）。通常我们的URL形式为http://runoob.com/first/page ，但在单页Web应用中AngularJS 通过 # + 标记 实现，例如：123http://runoob.com/#/firsthttp://runoob.com/#/secondhttp://runoob.com/#/third 当我们点击以上的任意一个链接时，向服务端请的地址都是一样的 (http://runoob.com/)。 因为 # 号之后的内容在向服务端请求时会被浏览器忽略掉。 所以我们就需要在客户端实现 # 号后面内容的功能实现。 AngularJS 路由 就通过 # + 标记 帮助我们区分不同的逻辑页面并将不同的页面绑定到对应的控制器上。 AngularJS 模块的 config 函数用于配置路由规则。通过使用 configAPI，我们请求把$routeProvider注入到我们的配置函数并且使用$routeProvider.whenAPI来定义我们的路由规则。$routeProvider 为我们提供了 when(path,object) &amp; otherwise(object) 函数按顺序定义所有路由，函数包含两个参数:第一个参数是 URL 或者 URL 正则规则。第二个参数是路由配置对象。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!--router.html--&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"zh\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;路由控制&lt;/title&gt;&lt;/head&gt;&lt;body ng-app=\"ngRouteExample\" class=\"ng-scope\"&gt; &lt;div&gt; &lt;div id=\"navigation\"&gt; &lt;a href=\"#/home\"&gt;Home&lt;/a&gt; &lt;a href=\"#/about\"&gt;About&lt;/a&gt; &lt;/div&gt; &lt;div ng-view=\"\"&gt; &lt;/div&gt;&lt;script type=\"text/ng-template\" id=\"embedded.home.html\"&gt; &lt;h1&gt; Home &lt;/h1&gt;&lt;/script&gt;&lt;script src=\"http://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js\"&gt;&lt;/script&gt;&lt;script src=\"http://apps.bdimg.com/libs/angular-route/1.3.13/angular-route.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; angular.module('ngRouteExample', ['ngRoute']) .controller('HomeController', function ($scope, $route) &#123; $scope.$route = $route;&#125;) .controller('AboutController', function ($scope, $route) &#123; $scope.$route = $route;&#125;) .config(function ($routeProvider) &#123; $routeProvider. when('/home', &#123; templateUrl: 'embedded.home.html', controller: 'HomeController' &#125;). when('/about', &#123; templateUrl: 'about.html', controller: 'AboutController' &#125;). otherwise(&#123; redirectTo: '/home' &#125;); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 12&lt;!--about.html--&gt;&lt;h1&gt; About &lt;/h1&gt; 综合123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!--complex.html--&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"zh\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;综合实例&lt;/title&gt;&lt;/head&gt;&lt;body ng-app=\"ngRouteExample\" class=\"ng-scope\"&gt; &lt;div&gt; &lt;div id=\"navigation\"&gt; &lt;a href=\"#/page1\"&gt;Page1&lt;/a&gt; &lt;a href=\"#/page2\"&gt;Page2&lt;/a&gt; &lt;/div&gt; &lt;div ng-view=\"\"&gt; &lt;/div&gt;&lt;script src=\"http://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js\"&gt;&lt;/script&gt;&lt;script src=\"http://apps.bdimg.com/libs/angular-route/1.3.13/angular-route.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; var myApp = angular.module('ngRouteExample', ['ngRoute']); myApp.controller('Page1Controller', function ($scope, $route) &#123; $scope.$route = $route; $scope.content = '这是page1的内容'; &#125;); myApp.controller('Page2Controller', function ($scope, $route) &#123; $scope.$route = $route; $scope.content = '这是page2的内容'; &#125;) myApp.config(function ($routeProvider) &#123; $routeProvider. when('/page1', &#123; templateUrl: 'complex-page1.html', controller: 'Page1Controller' &#125;). when('/page2', &#123; templateUrl: 'complex-page2.html', controller: 'Page2Controller' &#125;). otherwise(&#123; redirectTo: '/page1' &#125;); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 12345&lt;!--complex-page1.html--&gt;&lt;div id=\"page1\" ng-controller=\"Page1Controller\"&gt; &lt;h1&gt;Page1&lt;/h1&gt; &lt;p&gt;&#123;&#123;content&#125;&#125;&lt;/p&gt;&lt;/div&gt; 12345&lt;!--complex-page2.html--&gt;&lt;div id=\"page2\" ng-controller=\"Page2Controller\"&gt; &lt;h1&gt;Page2&lt;/h1&gt; &lt;p&gt;&#123;&#123;content&#125;&#125;&lt;/p&gt;&lt;/div&gt; 后记至于输入验证、事件、动画、API等，本文不再讨论，用到时自行查阅文档。本文完整源码地址：https://github.com/voidking/angulardemo 记录一个hexo的坑：如果文中出现了双括号，而且双括号没有被代码块包含，那么解析会报错，无法生成页面。 查找到的解决办法：123&#123;% raw %&#125;内容&#123;% endraw %&#125; 经测试，无效，就用汉字代替好了。 书签AngularJS实战http://www.imooc.com/learn/156 AngularJS 教程 | 菜鸟教程http://www.runoob.com/angularjs/angularjs-tutorial.html AngularJS中文网http://www.apjs.net/ AngularJS中文社区http://angularjs.cn/ 图灵社区: 合集 : AngularJS入门教程http://www.ituring.com.cn/minibook/303 AngularJS: API: API Referencehttps://docs.angularjs.org/api ngCloakhttps://docs.angularjs.org/api/ng/directive/ngCloak AngularJS : Why ng-bind is better than 双括号 in angular?http://stackoverflow.com/questions/16125872/angularjs-why-ng-bind-is-better-than-in-angular Metronic3.3网页模板在线演示http://metronic.kp7.cn/ 框架到底是个什么东西？https://www.zhihu.com/question/32069908 理解AngularJS中的依赖注入http://sentsin.com/web/663.html Hexo的一个小BUG(Template render error)http://www.jianshu.com/p/738ebe02029b","tags":[{"name":"前端","slug":"前端","permalink":"http://yutaiwei.github.io/tags/前端/"},{"name":"angular","slug":"angular","permalink":"http://yutaiwei.github.io/tags/angular/"},{"name":"hexo","slug":"hexo","permalink":"http://yutaiwei.github.io/tags/hexo/"}]},{"title":"ES6对数组的扩展","date":"2015-10-23T11:57:30.000Z","path":"2015/10/23/ES6对数组的扩展/","text":"ECMAScript6对数组进行了扩展，为数组Array构造函数添加了from()、of()等静态方法，也为数组实例添加了find()、findIndex()等方法。下面一起来看一下这些方法的用法。 Array.from()Array.from()将类数组(array-like)对象与可遍历的对象转化为数组并返回。例如将dom节点集合转化为数组，以前我们可能都会这样写： 1234var divs = document.querySelectAll(\"div\");[].slice.call(divs).forEach(function (node) &#123; console.log(node);&#125;) 现在我们可以这样写： 1234var divs = document.querySelectAll(\"div\");Array.from(divs).forEach(function (node) &#123; console.log(node);&#125;) 上面两种写法基本上是相同的。 Array.from()也可以将ES6中新增的Set、Map等结构转化为数组： 12// 将Set结构转化为数组Array.from(new Set([1, 2, 3, 4])); // [1, 2, 3, 4] 12//将Map结构转化为数组Array.from(new Map([\"name\", \"zlw\"])); // [\"name\", \"zlw\"] 字符串既是类数组又是可遍历的，所以Array.from()也可将字符串转化为数组： 1Array.from(\"zlw\"); // [\"z\", \"l\", \"w\"] Array.from()还有两个可选参数，完整语法如下： 1Array.from(obj, mapFn, thisArg) mapFn其实就是数组的map方法，对数组的每个元素处理。thisArg是执行环境的上下文。Array.from(obj, mapFn, thisArg)等同于Array.from(obj).map(mapFn, thisArg)。 Array.of()Array.of()将其参数转化为数组。如： 1Array.of(1, 2, 3); // [1, 2, 3] 我们知道用Array构造函数也可以实现同样功能： 1Array(1, 2, 3) // [1, 2, 3] 他们的不同之处在于： 123Array.of(3); // [3]Array(3) // [undefined, undefined, undefined] 当传入一个参数时，Array.of()会返回只有一个元素的数组，而Array()会返回长度为传入参数而元素都为undefined的数组。 Array.prototype.fill()fill()方法用一个值填充数组给定开始和结束位置之间的的所有值，语法如下： 1fill(value, start, end) 参数start、end是填充区间，包含start位置，但不包含end位置。如果省略，则start默认值为0，end默认值为数组长度。如果两个可选参数中有一个是负数，则用数组长度加上该数来确定相应的位置。例： 123[1, 2, 3].fill(4) // [4, 4, 4][1, 2, 3].fill(4, 1, 2) // [1, 4, 3][1, 2, 3].fill(4, -3, -2) // [4, 2, 3] Array.prototype.find()与Array.prototype.findIndex()find()方法返回数组中符合条件的第一个元素，如果没有则返回undefind。语法如下： 1array.find(callback, context); 参数包括一个回调函数和一个可选参数(执行环境上下文）。回调函数会遍历数组的所有元素，直到找到符合条件的元素，然后find()方法返回该元素。例： 1234567[1, 2, 3, 4].find(function(el, index, arr) &#123; return el &gt; 2;&#125;) // 3[1, 2, 3, 4].find(function(el, index, arr) &#123; return el &gt; 4;&#125;) // undefined findIndex()方法与find()方法用法类似，返回的是第一个符合条件的元素的索引，如果没有则返回-1。例： 1234567[1, 2, 3, 4].findIndex(function(el, index, arr) &#123; return el &gt; 2;&#125;) // 2[1, 2, 3, 4].findIndex(function(el, index, arr) &#123; return el &gt; 4;&#125;) // -1 Array.prototype.entries()、Array.prototype.keys与Array.prototype.values()entries()、keys与values都返回一个数组迭代器对象。例： 1234567891011121314var entries = [1, 2, 3].entries();console.log(entries.next().value); // [0, 1]console.log(entries.next().value); // [1, 2]console.log(entries.next().value); // [2, 3]var keys = [1, 2, 3].keys();console.log(keys.next().value); // 0console.log(keys.next().value); // 1console.log(keys.next().value); // 2var valuess = [1, 2, 3].values();console.log(values.next().value); // 1console.log(values.next().value); // 2console.log(values.next().value); // 3 迭代器的next()方法返回的是一个包含value属性与done属性的对象，而value属性是当前遍历位置的值，done属性是一个布尔值，表示遍历是否结束。 我们也可以用for...of来遍历迭代器： 123456789101112131415for (let i of entries) &#123; console.log(i)&#125; // [0, 1]、[1, 2]、[2, 3]for (let [index, value] of entries) &#123; console.log(index, value)&#125; // 0 1、1 2、2 3for (let key of keys) &#123; console.log(key)&#125; // 0, 1, 2for (let value of values) &#123; console.log(value)&#125; // 1, 2, 3 Array.prototype.copyWithin()copyWithin()方法语法如下： 1arr.copyWithin(target, start, end = this.length) 最后一个参数为可选参数，省略则为数组长度。该方法在数组内复制从start(包含start)位置到end(不包含end)位置的一组元素覆盖到以target为开始位置的地方。例： 123[1, 2, 3, 4].copyWithin(0, 1) // [2, 3, 4, 4][1, 2, 3, 4].copyWithin(0, 1, 2) // [2, 2, 3, 4] 如果start、end参数是负数，则用数组长度加上该参数来确定相应的位置： 1[1, 2, 3, 4].copyWithin(0, -2, -1) // [3, 2, 3, 4] 需要注意copyWithin()改变的是数组本身，并返回改变后的数组，而不是返回原数组的副本。 数组推导(array comprehensions)数组推导就是利用for...of循环基于现有的数组生成新数组。例： 1[for (i of [1, 2, 3]) i * i] // [1, 4, 9] 数组推导允许使用if语句： 12345// 单个if语句[for (i of [1, 2, 3]) if (i &lt; 3) i] // [1, 2]//多重if语句[for (i of [1, 2, 3]) if (i &lt; 3) if (i &gt; 1) i] // [2] 需要注意的是for...of总是写在最前面。 数组推导也允许使用多重for..of循环： 1[for (i of [1, 2, 3]) for (j of [4, 5, 6]) i * j] // [4, 5, 6, 8, 10, 12, 12, 15, 18] 数组推导中还可以包含数组推导： 1[for (i of [1, 2, 3]) [for (j of [4, 5, 6]) i * j]] // [[4, 5, 6], [8, 10, 12], [12, 15, 18]] 各大浏览器对ES6的支持可以查看kangax.github.io/es5-compat-table/es6/。","tags":[{"name":"ES6","slug":"ES6","permalink":"http://yutaiwei.github.io/tags/ES6/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yutaiwei.github.io/tags/JavaScript/"}]},{"title":"对 js 中 this、apply、call 和闭包的理解","date":"2015-09-18T14:01:59.000Z","path":"2015/09/18/JavaScript 学习之基本语法/","text":"语法概述基本句法和变量语句以分号结尾，一个分号就表示一个语句结束。 JavaScript允许省略var，直接对未声明的变量赋值。也就是说，var a = 1 与 a = 1，这两条语句的效果相同。但是由于这样的做法很容易不知不觉地创建全局变量（尤其是在函数内部），所以建议总是使用var命令声明变量。 JavaScript引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。这造成的结果，就是所有的变量的声明语句（var 命令声明的变量），都会被提升到代码的头部，这就叫做变量提升（hoisting）。 JavaScript语言的标识符对大小写敏感。 JavaScript使用大括号将语句组成区块，但与大多数编程语言不一样，JavaScript的区块不构成单独的作用域（scope）。 else代码块总是跟随离自己最近的那个if语句。 switch结构，每个case代码块内部的break语句不能少，否则会接下去执行下一个case代码块，而不是跳出switch结构。 12345678910switch (fruit) &#123; case \"banana\": // ... break; case \"apple\": // ... break; default: // ...&#125; switch语句后面的表达式与case语句后面的表示式，在比较运行结果时，采用的是严格相等运算符（===），这意味着比较时不会发生类型转换。 switch结构不利于代码重用，往往可以用对象形式重写。1234567891011var o = &#123; banana: function ()&#123; return &#125;, apple: function ()&#123; return &#125;, default: function ()&#123; return &#125;&#125;;if (o[fruit])&#123; o[fruit]();&#125; else &#123; o['default']();&#125; break语句用于跳出代码块或循环。continue语句用于立即终止本次循环，返回循环结构的头部，开始下一次循环。 数据类型JavaScript的数据类型，共有六个类别和两个特殊值。六个类别的数据类型又可以分成两组：原始类型（primitive type）和合成类型（complex type）。原始类型包括三种数据类型：数值（number）、字符串（string）和布尔值（boolean），合成类型也包括三种数据类型：对象（object）、数组（array）和函数（function）。两个特殊值null和undefined。 JavaScript有三种方法，可以确定一个值到底是什么类型： typeof运算符 instanceof运算符 Object.prototype.toString方法 typeof运算符可以返回一个值的数据类型，数值、字符串、布尔值分别返回number、string、boolean，函数返回function，undefined返回undefined，除此以外，都返回object（包括数组、对象、null、window）。要想区分数组（Array）和对象（Object），可以用 instanceof运算符（if ( arr instanceof Array ) ）。 利用 typeof undefined 返回undefined这一点，typeof可以用来检查一个没有声明的变量，而不报错。 if (typeof v !== “undefined”){ // …} null表示”没有对象”，即该处不应该有值（转为数值时为0）。典型用法是： 作为函数的参数，表示该函数的参数不是对象。 作为对象原型链的终点。 undefined表示”缺少值”，就是此处应该有一个值，但是还未定义（转为数值时为NaN）。典型用法是： 变量被声明了，但没有赋值时，就等于undefined。 调用函数时，应该提供的参数没有提供，该参数等于undefined。 对象没有赋值的属性，该属性的值为undefined。 函数没有返回值时，默认返回undefined。 JavaScript会将预期为布尔值的位置出现的值自动转为布尔值，下面六个值被转为false，其他值都视为true。需要注意的是，空数组（[]）和空对象（{}）对应的布尔值，都是true。 undefined null false 0 NaN “”（空字符串） 结尾的分号分号表示一条语句的结尾。但是，有一些语法结构不需要在语句的结尾添加分号，主要是以下三种情况： for和while循环 分支语句：if， switch， try 函数的声明语句（但是函数表达式仍然要使用分号） 一般来说，在没有分号结尾的情况下，如果下一行起首的是(、 [ 、+、-、/这五个字符中的一个，分号不会被自动添加。只有下一行的开始与本行的结尾，无法放在一起解释，JavaScript引擎才会自动添加分号。另外，如果一行的起首是“自增”（++）或“自减”（–）运算符，则它们的前面会自动添加分号。如果continue、break、return和throw这四个语句后面，直接跟换行符，会自动添加分号。 数值概述JavaScript内部，所有数字都是以64位浮点数形式储存，即使整数也是如此。由于浮点数不是精确的值，所以涉及小数的比较和运算要特别小心。 64位浮点数格式的64个二进制位中，第0位到第51位储存有效数字部分，第52到第62位储存指数部分，第63位是符号位，0表示正数，1表示负数。 特殊数值NaN是JavaScript的特殊值，表示“非数字”（Not a Number），主要出现在将字符串解析成数字出错的场合。NaN不是一种独立的数据类型，而是一种特殊数值，它的数据类型依然属于Number。NaN不等于任何值，包括它本身。 使用isNaN之前，最好判断一下数据类型：123function myIsNaN(value) &#123; return typeof value === 'number' &amp;&amp; isNaN(value);&#125; 判断NaN更可靠的方法是，利用NaN是JavaScript之中唯一不等于自身的值这个特点，进行判断： 123function myIsNaN(value) &#123; return value !== value;&#125; Infinity表示“无穷”。除了0除以0得到NaN，其他任意数除以0，得到Infinity。isFinite函数返回一个布尔值，检查某个值是否为正常值，而不是Infinity。 isFinite(Infinity) // falseisFinite(-1) // trueisFinite(true) // trueisFinite(NaN) // false 与数值有关的全局方法parseInt方法： parseInt方法可以将字符串或小数转化为整数。如果字符串头部有空格，空格会被自动去除。 如果字符串包含不能转化为数字的字符，则不再进行转化，返回已经转好的部分。 如果字符串的第一个字符不能转化为数字（正负号除外），返回NaN。 parseInt方法还可以接受第二个参数（2到36之间），表示被解析的值的进制（可以用parseInt方法进行进制的转换）。 parseFloat方法：parseFloat方法用于将一个字符串转为浮点数，其他规则同parseInt。 字符串要在单引号字符串的内部使用单引号，可以在内部的单引号（或者双引号）前面加上反斜杠，用来转义。 如果长字符串必须分成多行，可以在每一行的尾部使用反斜杠。 字符串可以被视为字符数组，因此可以使用数组的方括号运算符，用来返回某个位置的字符（从0开始）。 字符串是不可变的，一旦被创建，永远无法改变。两个包含着完全相同的字符且字符顺序也相同的字符串被认为是相同的字符串。 ‘c’ + ‘a’ + ‘t’ === ‘cat’// true JavaScript使用Unicode字符集，每个字符在JavaScript内部都是以16位（即2个字节）的UTF-16格式储存。也就是说，JavaScript的单位字符长度固定为2个字节。 var s = ‘\\u00A9’;s // “©” 对象概述对象的生成方法，通常有三种方法： var o1 = {};var o2 = new Object();var o3 = Object.create(null); 读取属性有使用点运算符和方括号运算符两种方法。如果使用方括号运算符，键名必须放在引号里面，否则会被当作变量处理。数字键可以不加引号。 12345678var o = &#123; p: \"Hello\"， 0.7: \"World\"&#125;;o.p // \"Hello\"o[\"p\"] // \"Hello\"o[0.7] // \"World\" 检查变量是否声明时，不要使用 if(window.a) {...}写法，因为如果a属性是一个空字符串（或其他对应的布尔值为false的情况），则无法起到检查变量是否声明的作用。正确的写法如下： if(‘a’ in window) { …} 查看一个对象本身的所有属性，可以使用 Object.keys 方法，如：Object.keys(o) 。 删除一个属性，需要使用delete ，一旦使用delete命令删除某个属性，再读取该属性就会返回undefined，而且该属性不再包含在Object.keys的返回中。 如果不同的变量名指向同一个对象，那么它们都是这个对象的引用，也就是说指向同一个内存地址。修改其中一个变量，会影响到其他所有变量。 for...in循环用来遍历一个对象的全部属性。如果只想遍历对象本身的属性，可以使用 hasOwnProperty() 方法，在循环内部做一个判断。 12345for (var key in person) &#123; if (person.hasOwnProperty(key)) &#123; console.log(key); &#125;&#125; 类似数组的对象一个对象，只要有 数字键 和 length属性 ，就是一个类似数组的对象（array-like object）。但无法使用数组特有的一些方法，比如pop和push方法。而且，length属性不会随着成员的变化而变化。 12345678var a = &#123; 0:'a', 1:'b' length:2&#125;;a[1] // 'b'a.length // 2 典型的类似数组的对象是函数的arguments对象，以及大多数DOM元素集（比如 document.getElementsByTagName 的返回值），还有字符串。 通过函数的call方法，可以用slice方法将类似数组的对象，变成真正的数组。 var arr = Array.prototype.slice.call(a); 遍历类似数组的对象，可以采用for循环，也可以采用数组的forEach方法。 数组本质上，数组也属于对象，是字典结构（dictionary）的一个变种。所以typeof运算符返回数组的类型是object。 数组的length属性是可写的。如果人为设置一个小于当前成员个数的值，该数组的成员会自动减少到length设置的值。如果设置length大于当前元素个数，则数组的成员数量会增加到这个值，新增的位置填入空元素（undefined）。将数组清空的一个有效方法，就是将length属性设为0。 使用delete命令删除一个值，会形成空位，不影响length属性。因为这个键还在，只是值变为了undefined。 遍历数组的两种方法，一是使用for-in循环，二是用for循环或者while循环结合length属性。 函数JavaScript的函数与其他数据类型处于同等地位，可以使用其他数据类型的地方就能使用函数。可以把函数赋值给变量和对象的属性，也可以当作参数传入其他函数，或者作为函数的结果返回。 JavaScript引擎将函数名视同变量名，所以采用function命令声明函数时，整个函数会被提升到代码头部，即条件无效。要达到在条件语句中定义函数的目的，只有使用函数表达式。 123if (false)&#123; var f = function ()&#123;&#125;;&#125; 函数的name属性返回紧跟在function关键字之后的那个函数名。函数的toString方法返回函数的源码。 JavaScript只有两种作用域：一种是全局作用域，变量在整个程序中一直存在；另一种是函数作用域，变量只在函数内部存在。 JavaScript的函数参数传递方式是传值传递（passes by value），这意味着，在函数体内修改参数值，不会影响到函数外部。但是对于复合类型的变量来说，属性值是传址传递（pass by reference），也就是说，属性值是通过地址读取的。所以在函数体内修改复合类型变量的属性值，会影响到函数外部。 123456789101112131415// 修改原始类型的参数值var p = 1; function f(p)&#123; p = 2;&#125;f(p);p // 1// 修改对象的属性值var o = &#123; p:1 &#125;;function f(obj)&#123; obj.p = 2;&#125;f(o);o.p // 2 arguments对象包含了函数运行时的所有参数，这个对象只有在函数体内部才可以使用。 闭包（closure）就是定义在函数体内部的函数。其特点在于，在函数外部可以读取函数的内部变量。 123456789function f() &#123; var v = 1; var c = function ()&#123; return v; &#125;; return c;&#125;var o = f();o(); // 1 有时，需要在定义函数之后，立即调用该函数。然而不能在函数的定义之后加上圆括号，因为Javascript引擎看到function关键字之后，认为后面跟的是函数定义语句，不应该以圆括号结尾。解决方法就是让引擎知道，圆括号前面的部分不是函数定义语句，而是一个表达式，可以对此进行运算。 12345// 写法1(function()&#123; /* code */ &#125;()); // 写法2(function()&#123; /* code */ &#125;)(); 通常情况下，只对匿名函数使用这种“立即执行的函数表达式”。它的目的有两个：一是不必为函数命名，避免了污染全局变量；二是IIFE内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量。 ###运算符 加法运算符（+）需要注意的地方是，它除了用于数值的相加，还能用于字符串的连接（在运算子之中有字符串的情况下）。这种由于参数不同，而改变自身行为的现象，叫做“重载”（overload）。 加法运算符以外的其他算术运算符，都不会发生重载。它们的规则是：所有运算子一律转为数值，再进行相应的数学运算。 余数运算符（%）返回前一个运算子被后一个运算子除，所得的余数。运算结果的正负号由第一个运算子的正负号决定。为了得到正确的负数的余数值，需要先使用绝对值函数。 严格相等运算符（===）会比较值的类型和引用是否相同，相等运算符（==）在比较不同类型的数据时，会先将数据进行类型转换。 取反运算符（！）有转换数据类型的作用，对于非布尔值的数据，取反运算符会自动将其转为布尔值。如果对一个值连续做两次取反运算，等于将其转为对应的布尔值，与Boolean函数的作用相同。这是一种常用的类型转换的写法。 1234// 当x非null，非undefined，非\"\"时，执行条件语句中代码if(!!x)&#123; //do something!&#125; 且运算符的运算规则是：如果第一个运算子的布尔值为true，则返回第二个运算子的值（注意是值，不是布尔值）；如果第一个运算子的布尔值为false，则直接返回第一个运算子的值，且不再对第二个运算子求值。这种机制即“短路”。 尝试从undefined的成员属性中取值将会产生TypeError异常，这时可通过 &amp;&amp; 运算符来避免错误。 1234a.b // undefineda.b.c // throw \"TypeError\"// 可改为a.b &amp;&amp; a.b.c 或运算符的运算规则是：如果第一个运算子的布尔值为true，则返回第一个运算子的值，且不再对第二个运算子求值；如果第一个运算子的布尔值为false，则返回第二个运算子的值。或运算符常用于为一个变量设置默认值。 12345// 函数调用时，没有提供参数，则该参数默认设置为空字符串。function saveText(text) &#123; text = text || ''; // ...&#125; 三元条件运算符用问号（？）和冒号（：），分隔三个表达式。如果第一个表达式的布尔值为true，则返回第二个表达式的值，否则返回第三个表达式的值。通常来说，三元条件表达式与if...else语句具有同样表达效果，区别是后者没有返回值。 “异或运算”在两个二进制位不同时返回1，相同时返回0。连续对两个数a和b进行三次异或运算，aˆ=b, bˆ=a, aˆ=b，可以互换它们的值而不引入临时变量（详见 维基百科）。 左移运算符表示将一个数的二进制形式向前移动，尾部补0。左移运算符用于二进制数值非常方便。 右移运算符表示将一个数的二进制形式向右移动，头部补上最左位的值，即整数补0，负数补1。右移运算可以模拟2的整除运算。 在JavaScript中，圆括号是一种运算符，它有两种用法：如果把表达式放在圆括号之中，作用是求值；如果跟在函数的后面，作用是调用函数。 void运算符的作用是执行一个表达式，然后返回undefined。这个运算符主要是用于书签工具（bookmarklet）或者用于在超级链接中插入代码，目的是返回undefined可以防止网页跳转。 1234// 写法1javascript:void window.open(\"http://example.com/\")// 写法2&lt;a href=\"javascript:void(0)\" onclick=\"f();\"&gt;文字&lt;/a&gt; 数据类型转换Number函数将字符串转为数值，要比parseInt函数严格很多。基本上，只要有一个字符无法转成数值，整个字符串就会被转为NaN。 JavaScript自动转换有很大的不确定性，而且不易除错，建议在预期为布尔值、数值、字符串的地方，全部使用Boolean、Number和String方法进行显式转换。 四个特殊表达式（具体可参考此文 ）： 空数组 + 空数组 [] + []// “” 空数组 + 空对象 [] + {}// “[object Object]” 空对象 + 空数组 {} + []// 0 空对象 + 空对象 {} + {}// NaN 错误处理机制Error对象Error对象的实例有三个最基本的属性： name：错误名称 message：错误提示信息 stack：错误的堆栈（非标准属性，但是大多数平台支持） JavaScript的原生错误类型Error对象是最一般的错误类型，在它的基础上，JavaScript还定义了其他6种错误，也就是说，存在Error的6个派生对象。 SyntaxError是解析代码时发生的语法错误。 ReferenceError是引用一个不存在的变量时发生的错误。 RangeError是当一个值超出有效范围时发生的错误。主要有几种情况，一是数组长度为负数，二是Number对象的方法参数超出范围，以及函数堆栈超过最大值。 TypeError是变量或参数不是预期类型时发生的错误。 URIError是URI相关函数的参数不正确时抛出的错误。 eval函数没有被正确执行时，会抛出EvalError错误。 自定义错误通过继承Error对象，可以自定义一个错误对象 123456789function UserError(message) &#123; this.message = message || \"默认信息\"; this.name = \"UserError\";&#125;UserError.prototype = new Error();UserError.prototype.constructor = UserError;new UserError(\"这是自定义的错误！\"); try…catch…finallythrow语句的作用是中断程序执行，抛出一个意外或错误。它接受一个表达式作为参数。 为了对错误进行处理，需要使用try…catch结构。为了捕捉不同类型的错误，catch代码块之中可以加入判断语句。 123if (e instanceof RangeError) &#123; // code&#125; try…catch结构允许在最后添加一个finally代码块，表示不管是否出现错误，都必需在最后运行的语句。而且即使有return语句在前，finally代码块依然会得到执行，且在其执行完毕后，才会显示return语句的值。 12345678910111213function idle(x) &#123; try &#123; console.log(x); return 'result'; &#125; finally &#123; console.log(\"FINALLY\"); &#125;&#125;idle('hello')// hello// FINALLY// \"result\" 编程风格语法标记的风格表示区块起首的大括号，不要另起一行。 123block &#123; ...&#125; 圆括号在JavaScript中有两种作用，一种表示函数的调用，另一种表示表达式的组合。可以用空格，区分这两种不同的括号。表示函数调用和函数定义时，函数名与左括号之间没有空格。其他情况时，前面位置的语法元素与左括号之间，都有一个空格。 虽然在循环和判断的代码体只有一行时，JavaScript允许该区块（block）省略大括号。但最好总是使用大括号表示区块。 语法命令的风格避免使用全局变量；如果不得不使用，用大写字母表示变量名，比如UPPER_CASE。 JavaScript使用new命令，从构造函数生成一个新对象。这种做法的问题是，一旦你忘了加上new，myObject()内部的this关键字就会指向全局对象。因此，尽量使用Object.create()命令，替代new命令。如果不得不使用new，构造函数的函数名，采用首字母大写。 所有变量声明都放在函数的头部，所有函数都在使用之前定义。 不要使用”相等”（==）运算符，只使用”严格相等”（===）运算符。 不要将不同目的的语句，合并成一行。 不要使用自增（++）和自减（–）运算符，用+=和-=代替。 避免使用switch…case结构，用对象结构代替。 eval函数的作用是将一段字符串当作语句执行。问题是eval不提供单独的作用域，而是直接在当前作用域运行。因此，避免使用eval函数。 参考教程JavaScript 标准参考教程：基本语法","tags":[{"name":"前端","slug":"前端","permalink":"http://yutaiwei.github.io/tags/前端/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yutaiwei.github.io/tags/JavaScript/"}]},{"title":"JavaScript正则用法","date":"2015-09-15T04:37:03.000Z","path":"2015/09/15/JavaScript正则表达式/","text":"前言正则表达式（Regular Expression）主要是用来描述一个句法规则的模式。其实说的通俗一点，就是利用字符和元字符的组合，对一些符合既定句法的模式进行模糊匹配。它的主要功能是文本查询和字符串操作。本文讨论一下JavaScript中的正则表达式用法。 定义正则表达式1、定义正则表达式有两种形式，一种是普通方式，一种是构造函数方式。2、普通方式：var reg=/表达式/附加参数表达式：一个字符串，代表了某种规则，其中可以使用某些特殊字符，来代表特殊的规则，后面会详细说明。附加参数：用来扩展表达式的含义，目前主要有三个参数：g：代表可以进行全局匹配。i：代表不区分大小写匹配。m：代表可以进行多行匹配。上面三个参数，可以任意组合，代表复合含义，当然也可以不加参数。例子：12var reg=/a*b/;var reg=/abc+f/g; 3、构造函数方式：var reg=new RegExp(“表达式”,”附加参数”);其中“表达式”与“附加参数”的含义与上面那种定义方式中的含义相同。例子：12var reg=new RegExp(\"a*b\");var reg=new RegExp(\"abc+f\",\"g\"); 4、普通方式与构造函数方式的区别普通方式中的表达式必须是一个常量字符串，而构造函数中的表达式可以是常量字符串，也可以是一个js变量，例如根据用户的输入来作为表达式参数等等：1var reg=new RegExp(document.forms[0].exprfiled.value,\"g\"); 表达式模式1、表达式模式，是指表达式的表达方式与样式， 即 var reg=/表达式/附加参数 中的“表达式”怎样去描述？2、从规范上讲，表达式模式分为简单模式和复合模式。3、简单模式：是指通过普通字符的组合来表达的模式，例如1var reg=/abc0d/; 可见简单模式只能表示具体的匹配。4、复合模式：是指含有通配符来表达的模式，例如：1var reg=/a+b?\\w/; 其中的+、?和\\w都属于通配符，代表着特殊的含义。因此复合模式可以表达更为抽象化的逻辑。复合模式中各个通配符的含义及其使用请阅读下文给出的参考文档。 表达式操作1、表达式操作，在这里是指和表达式相关的方法，我们将介绍六个方法。2、表达式对象（RegExp）方法： （1）exec(str)，返回str中与表达式相匹配的第一个字符串，而且以数组的形式表现，当然如果表达式中含有捕捉用的小括号，则返回的数组中也可能含有()中的匹配字符串，例如：12var regx=/\\d+/;var rs=regx.exec(\"3432ddf53\"); 返回的rs值为：{3432}12var regx2=new RegExp(\"ab(\\d+)c\");var rs2=regx2.exec(\"ab234c44\"); 返回的rs2值为：{ab234c,234}另外，如果有多个合适的匹配，则第一次执行exec返回一个第一个匹配，此时继续执行exec，则依次返回第二个第三个匹配。例如：123var regx=/user\\d/g;var rs=regx.exec(\"ddduser1dsfuser2dd\");var rs1=regx.exec(\"ddduser1dsfuser2dd\"); 则rs的值为{user1}，rs1的值为{user2}，当然注意regx中的g参数是必须的，否则无论exec执行多少次，都返回第一个匹配。后面还有相关内容涉及到对此想象的解释。 （2）test(str)，判断字符串str是否匹配表达式，返回一个布尔值。例如：12var regx=/user\\d+/g;var flag=regx.test(\"user12dd\"); flag的值为true。 3、String对象方法 （1）match(expr)，返回与expr相匹配的一个字符串数组，如果没有加参数g，则返回第一个匹配，加入参数g则返回所有的匹配例子：123var regx=/user\\d/g;var str=\"user13userddduser345\";var rs=str.match(regx); rs的值为：{user1,user3} （2）search(expr)，返回字符串中与expr相匹配的第一个匹配的index值。例子：123var regx=/user\\d/g;var str=\"user13userddduser345\";var rs=str.search(regx); rs的值为：0 （3）replace(expr,str)，将字符串中匹配expr的部分替换为str。另外在replace方法中，str中可以含有一种变量符号$，格式为$n，代表匹配中被记住的第n的匹配字符串（注意小括号可以记忆匹配）。例子：123var regx=/user\\d/g;var str=\"user13userddduser345\";var rs=str.replace(regx,\"00\"); rs的值为：003userddd0045例子2：123var regx=/u(se)r\\d/g;var str=\"user13userddduser345\";var rs=str.replace(regx,\"$1\"); rs的值为：se3userdddse45对于replace(expr,str)方法还要特别注意一点，如果expr是一个表达式对象则会进行全局替换（此时表达式必须附加参数g，否则也只是替换第一个匹配），如果expr是一个字符串对象，则只会替换第一个匹配的部分，例如：123var regx=\"user\"var str=\"user13userddduser345\";var rs=str.replace(regx,\"00\"); rs的值为： 0013userddduser345 （4）split(expr)，将字符串以匹配expr的部分做分割，返回一个数组，而且表达式是否附加参数g都没有关系，结果是一样的。例子：123var regx=/user\\d/g;var str=\"user13userddduser345\";var rs=str.split(regx); rs的值为：{3userddd,45} 表达式相关属性1、表达式相关属性，是指和表达式相关的属性，如下面的形式：12var regx=/myexpr/;var rs=regx.exec(str); 其中，和表达式自身regx相关的属性有两个，和表达式匹配结果rs相关的属性有三个，下面将逐一介绍。2、和表达式自身相关的两个属性： （1）lastIndex，返回开始下一个匹配的位置，注意必须是全局匹配（表达式中带有g参数）时，lastIndex才会有不断返回下一个匹配值，否则该值为总是返回第一个下一个匹配位置，例如：1234567var regx=/user\\d/;var rs=regx.exec(\"sdsfuser1dfsfuser2\");var lastIndex1=regx.lastIndex;rs=regx.exec(\"sdsfuser1dfsfuser2\");var lastIndex2=regx.lastIndex;rs=regx.exec(\"sdsfuser1dfsfuser2\");var lastIndex3=regx.lastIndex; 上面lastIndex1为9，第二个lastIndex2也为9，第三个也是9；如果regx=/user/d/g，则第一个为9，第二个为18，第三个为0。 （2）source，返回表达式字符串自身。例如：123var regx=/user\\d/;var rs=regx.exec(\"sdsfuser1dfsfuser2\");var source=regx.source; source的值为user\\d3、和匹配结果相关的三个属性： （1）index，返回当前匹配的位置。例如：1234567var regx=/user\\d/;var rs=regx.exec(\"sdsfuser1dfsfuser2\");var index1=rs.index;rs=regx.exec(\"sdsfuser1dfsfuser2\");var index2=rs.index; rs=regx.exec(\"sdsfuser1dfsfuser2\");var index3=rs.index; index1为4，index2为4，index3为4，如果表达式加入参数g，则index1为4，index2为13，index3会报错（index为空或不是对象）。 （2）input，用于匹配的字符串。例如：123var regx=/user\\d/;var rs=regx.exec(\"sdsfuser1dfsfuser2\");var input=rs.input; input的值为sdsfuser1dfsfuser2。 （3）[0]，返回匹配结果中的第一个匹配值，对于match而言可能返回一个多值的数字，则除了[0]外，还可以取[1]、[2]等等。例如：12345var regx=/user\\d/;var rs=regx.exec(\"sdsfuser1dfsfuser2\");var value1=rs[0];rs=regx.exec(\"sdsfuser1dfsfuser2\");var value2=rs[0]; value1的值为user1,value2的值为user2 实际应用1、实际应用一描述：有一表单，其中有一个“用户名”input域要求：汉字，而且不能少于2个汉字，不能多于4个汉字。实现：12345678910111213141516&lt;script&gt;function checkForm(obj)&#123; var username=obj.username.value; var regx=/^[\\u4e00-\\u9fa5]&#123;2,4&#125;$/g; if(!regx.test(username))&#123; alert(\"Invalid username!\"); return false; &#125; return true;&#125;&lt;/script&gt;&lt;form name=\"myForm\" onSubmit=\"return checkForm(this)\"&gt; &lt;input type=\"text\" name=\"username\"/&gt; &lt;input type=\"submit\" vlaue=\"submit\"/&gt;&lt;/form&gt; 2、实际应用二描述：给定一个含有html标记的字符串，要求将其中的html标记去掉。实现：1234567891011&lt;script&gt;function toPlainText(htmlStr)&#123; var regx=/&lt;[^&gt;]*&gt;|&lt;\\/[^&gt;]*&gt;/gm; var str=htmlStr.replace(regx,\"\"); return str;&#125;&lt;/script&gt;&lt;form name=\"myForm\"&gt; &lt;textarea id=\"htmlInput\"&gt;&lt;/textarea&gt; &lt;input type=\"button\" value=\"submit\" onclick=\"toPlainText(document.getElementById('htmlInput').value\"/&gt;&lt;/form&gt; 参考文档js正则表达式语法http://blog.csdn.net/zaifendou/article/details/5746988 正则表达式30分钟入门教程http://demo.voidking.com/reprint/正则表达式/正则表达式30分钟入门教程.htm 常用的正则表达式http://demo.voidking.com/reprint/正则表达式/常用的正则表达式.htm 正则表达式速查表http://demo.voidking.com/reprint/正则表达式/正则表达式速查表.htm 正则表达式测试器http://demo.voidking.com/reprint/正则表达式/正则表达式测试器.htm 正则表达式在线测试器详情请见：http://demo.voidking.com/reprint/regexpal/ deerchao大侠正则表达式原文地址http://www.jb51.net/tools/zhengze.html","tags":[{"name":"前端","slug":"前端","permalink":"http://yutaiwei.github.io/tags/前端/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yutaiwei.github.io/tags/JavaScript/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://yutaiwei.github.io/tags/正则表达式/"}]},{"title":"ES6的新写法","date":"2015-08-29T14:08:15.000Z","path":"2015/08/29/ES6的新写法/","text":"Let声明变量 let没有预解释 let定义的是块级作用域 123456789101112for(var i = 0;i&lt;3;i++)&#123; for(var i = 0;i&lt;3;i++)&#123; console.log(i) &#125;&#125;//i同时变化，输出012for(let i = 0;i&lt;3;i++)&#123; for(let i = 0;i&lt;3;i++)&#123; console.log(i) &#125;&#125;//形成块级作用域 输出012012012 let一个作用域内不可以重复声明 私有所用域的新写法 老写法 123~function()&#123;&#125; 新写法 12&#123;&#125;//一个花括号一个作用域 解构赋值 数组的解构 1234var [num1,num2] = arrconsole.log(num1,num2)//则num1等于arr[0]//num2等于arr[1] 对象的解构 123456let obj = &#123;name:'lkp',age:19,home:&#123;&#125;&#125;let name = obj.namelet age = obj.agelet&#123;name:name1,age:age1&#125; = obj;console.log(name1,age1)let&#123;name:&#123;province,city&#125;,hoddy:[one]&#125; 模板字符串1`此处添加一个变量$&#123;变量名&#125;` 箭头函数1234567891011let double = num =&gt; num*2;//声明一个函数名：箭头左边是参数右边是返回值，一进一出//如果多于一个参数，或者没有参数得话，左边要用小括号包裹let add = (a,b) =&gt; a+b//如果不只有返回值的话，需要用花括包裹，如果有返回值需要加returnlet add = (a,b) =&gt; &#123; console.log(a,b); return a+b;&#125;//箭头函数没有自己的this指针，只会引用外层this指针，定义阶段就已经确定箭头函数内部的没有this指针，也无法改变指向 数组的新方法 map filter find sort 声明的短属性12345let obj = &#123; name, age&#125;//当声明的变量名与变量值相等时，只写一个就可以 类123456789101112131415161718192021class Animal &#123; constructor()&#123; this.type = 'animal' &#125; says(say)&#123; console.log(this.type + ' says ' + say) &#125;&#125;let animal = new Animal()animal.says('hello') //animal says helloclass Cat extends Animal &#123; constructor()&#123; super() this.type = 'cat' &#125;&#125;let cat = new Cat()cat.says('hello') //cat says hello promise1234567891011121314151617181920212223242526272829class Promise &#123; //构造函数 constructor(task) &#123; //初始化一个私有变量 this._status = '初始态'; //开始执行task任务并且把绑定后的方法传进去 task(this.resolve.bind(this), this.reject.bind(this)); &#125;//成功方法 1. 把状态改为成功态 2.调用成功的回调 resolve(result) &#123; this._status = '成功态'; this._success(result); &#125;//失败的方法 1. 把状态改为失败态 2. 调用失败的回调 reject(err) &#123; this._status = '失败态'; this._fail(err); &#125; //用来给客户端 传入成功和失败的回调函数并保存在实例内部 then(success, fail) &#123; this._success = success; this._fail = fail; &#125;&#125;module.exports = Promise;promise有且只有一个方法，then方法，可以链式操作，执行一个成功的回调，一个失败的回调。 调用promise的方法123456789101112let promise = new Promise(function(resolve,reject)&#123; //这是我们的异步任务，里面会放一些异步任务代码 fs.readFile('1.txt','utf8',function(err,data)&#123; if(err)&#123; //如果失败了需要告诉 客户失败的原因 reject(err); &#125;else&#123; //如果成功了需要把结果送给客户 resolve(data); &#125; &#125;)&#125;); 同时执行多个并发promise.all请求，提高效率，提高可读性123Promise.all([xxx,xxx]).then(function(result)&#123; //promise参数中放的放的每一个回调函数，result中也是一个数据，为每一个回调的返回值。只有每个回调执行完成之后，才会执行then方法。&#125;) promise.race方法1类似all请求，会将先执行完的请求执行then方法","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yutaiwei.github.io/tags/JavaScript/"}]},{"title":"Javascript学习笔记—3","date":"2015-08-17T11:27:20.000Z","path":"2015/08/17/Javascript学习笔记——实践篇/","text":"注释本文中的文件名，写在了代码注释中。既然用到了三种文件，就把这三种文件的注释方法先说明一下。 HTML注释语法&lt;!--注释的内容--&gt;,示例如下：1&lt;!--欢迎来到VoidKing的主页--&gt; CSS注释语法/*注释的内容*/，示例如下：12345/*这是注释*//*这也是注释可以分段*/ Javascript注释和C语言相同，语法//注释的内容或者/*注释的内容*/，示例如下：1234//这是注释/*这也是注释*/ 使用Javascript在html页面中使用Javascript，有三种方法： body中body中的Javascript代码，相当于C语言中位于main函数内代码，格式如下：1234567891011&lt;!--index.html--&gt;&lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;script type=\"text/javascript\"&gt; document.write(\"voidking.com\"); alert(\"voidking.com\"); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; head中head中的Javascript代码，相当于C语言中位于main函数外的代码，一般是封装好的函数。格式如下：123456789101112131415161718192021222324&lt;!--index.html--&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"charset=utf-8\" /&gt; &lt;script type=\"text/javascript\"&gt; function hello()&#123; var str=prompt(\"VoidKing的网址是什么？\",\"请在这里输入\"); if(str!=null &amp;&amp; str!=\"\") &#123; alert(\"你输入的是：\"+str); &#125; else &#123; alert(\"你什么也没有输入！\"); &#125; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;script type=\"text/javascript\"&gt; hello(); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 外部head中的Javascript代码不易维护，所以多数情况下我们会使用外部引用来代替。格式如下：123456789101112&lt;!--index.html--&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"charset=utf-8\" /&gt; &lt;script type=\"text/javascript\" src=\"javascript.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;script type=\"text/javascript\"&gt; hello(); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 123456789101112//javascript.jsfunction hello()&#123; var str=prompt(\"VoidKing的网址是什么？\",\"请在这里输入\"); if(str!=null &amp;&amp; str!=\"\") &#123; alert(\"你输入的是：\"+str); &#125; else &#123; alert(\"你什么也没有输入！\"); &#125; &#125; 使用CSS上面我们已经说完了使用Javascript的三种方式，爱思考的小伙伴肯定想到了CSS的使用方法，在这里，我也总结一下。 内联样式当特殊的样式需要应用到个别元素时，就可以使用内联样式。格式如下：12345678910&lt;!--index.html--&gt;&lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;p style=\"color:red;margin-left:20px\"&gt; This is a paragraph. &lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 内部样式当单个文件需要特别样式的时候，就可以使用内部样式表。格式如下:1234567891011121314&lt;!--index.html--&gt;&lt;html&gt; &lt;head&gt; &lt;style type=\"text/css\"&gt; body&#123;background-color:red&#125; p&#123;margin-left:20px&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt; This is a paragraph. &lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 外部样式当样式需要被应用到很多页面的时候，外部样式表最适合。格式如下：1234567891011&lt;!--index.html--&gt;&lt;html&gt; &lt;head&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\"/&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt; This is a paragraph. &lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 123/*style.css*/body&#123;background-color:red&#125;p&#123;margin-left:20px&#125; 借花献佛本来想自己整理出一批好的例子，但是，无意中发现了一个网站，已经做得非常好了。所以，void在这里就偷懒一下。例子精品，还附有教程讲解，分享给大家——梦之都！ 结束语这篇文章比预期的用时要短上很多，主要因为，我把痛苦的工作全部交给梦之都了，好机智地说！还想写个提高篇来着，但是能力有限，不能误人子弟啊！所以，Javascript笔记至此结束，接下来，该是jQuery了！","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yutaiwei.github.io/tags/JavaScript/"}]},{"title":"Cookie、localStorage和sessionStorage","date":"2015-08-03T03:18:09.000Z","path":"2015/08/03/Cookie、localStorage和sessionStorage/","text":"前言在《使用accessToken记录登录状态》一文中，已经讨论了Cookie的增删查改。本文详细探讨一下Cookie、localStorage和sessionStorage的概念差别，以及localStorage的用法。 CookieCookie的特点是小，只有4k，常用来存储辨别用户信息的数据，比如accessToken。而且，Cookie有数量限制，每个特定的域名下，最多生成50个Cookie（IE7+）。最大的优势是几乎所有的浏览器都支持。 localStoragelocalStorage 是 HTML5 标准中新加入的技术，拥有5M的存储空间，主流浏览器都支持。 存储123456789101112if(window.localStorage)&#123; var x = window.localStorage.userInfo? JSON.parse(window.localStorage.userInfo):&#123;&#125;; if((x.unionid == undefined) || (x.unionid == \"undefined\"))&#123; var temp = &#123; unionid: $('#unionid').val(), openid: $('#openid').val(), nickname: $('#nickname').val(), headimgurl:$ ('#headimgurl').val() &#125;; window.localStorage.userInfo = JSON.stringify(temp); &#125;&#125; 读取123var temp = (window.localStorage &amp;&amp; window.localStorage.userInfo)?JSON.parse(window.localStorage.userInfo):&#123;&#125;var unionid = temp.unionid;console.log(unionid); sessionStoragesessionStorage和localStorage非常相似，最主要的差别，是生命周期。localStorage除非被清除，否则永久保存；sessionStorage关闭页面或浏览器后被清除。 异同 特性 Cookie localStorage sessionStorage 数据的生命期 可设置失效时间，默认是关闭浏览器后失效 除非被清除，否则永久保存 仅在当前会话下有效，关闭页面或浏览器后被清除 存放数据大小 4K左右 一般为5MB 一般为5MB 与服务器端通信 每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题 仅在客户端（即浏览器）中保存，不参与和服务器的通信 仅在客户端（即浏览器）中保存，不参与和服务器的通信 易用性 需要程序员自己封装，源生的Cookie接口不友好 源生接口可以接受，亦可再次封装来对Object和Array有更好的支持 源生接口可以接受，亦可再次封装来对Object和Array有更好的支持 书签详说 Cookie, LocalStorage 与 SessionStoragehttps://segmentfault.com/a/1190000002723469 HTML5 localStorage本地存储实际应用举例 谈谈本地存储利弊Cookie、localStorage、sessionStoragehttp://www.tuicool.com/articles/fM32ier","tags":[{"name":"前端","slug":"前端","permalink":"http://yutaiwei.github.io/tags/前端/"},{"name":"html","slug":"html","permalink":"http://yutaiwei.github.io/tags/html/"}]},{"title":"JavaScript 中 this 的用法","date":"2015-07-26T14:01:59.000Z","path":"2015/07/26/JavaScript 中 this 的用法/","text":"在 JavaScript 中，this 是动态绑定，或称为运行期绑定的。一般而言，在Javascript中，this 指向函数执行时的当前对象。 由于其运行期绑定的特性，JavaScript 中的 this 可以是全局对象、当前对象或者任意对象，这完全取决于函数的调用方式。JavaScript 中函数的调用有以下几种方式：没有明确的调用对象，作为对象方法调用，使用 new 关键字作为构造函数调用，和使用apply、 call 和 eval 调用。 没有明确的当前对象时当没有明确的执行时的当前对象时，this 指向全局对象window。 纯粹的函数调用举个栗子123456var x = 1;function test()&#123; var x = 2; alert(this.x);&#125;test(); // 1 再看个复杂的栗子 123456789101112131415161718var name = \"window\";var Bob = &#123; name: \"Bob\", showName: function()&#123; alert(this.name); &#125;&#125;;var Tom = &#123; name: \"Tom\", showName: function()&#123; var fun = Bob.showName; fun(); &#125;&#125;;Tom.showName(); //window 其实也不复杂，只要按照上面那句话来判断就行。 setTimeout、setInterval和匿名函数在浏览器中 setTimeout、setInterval和匿名函数执行时的当前对象是全局对象 window，这条可以看成是上一条的一个特殊情况。 123456789101112var name = \"Bob\"; var nameObj = &#123; name : \"Tom\", showName : function()&#123; alert(this.name); &#125;, waitShowName : function()&#123; setTimeout(this.showName, 1000); &#125; &#125;; nameObj.waitShowName(); // Bob setTimeout 可以看做是一个延迟执行的匿名函数。 12345waitShowName : function()&#123; function(__callback)&#123; __callback(); &#125;(this.showName); &#125; 由于匿名函数的当前对象是 window，所以当在该匿名函数中运行回调函数时，回调函数的this 指向了window，所以 alert 出来 window.name。 作为对象方法调用时使用这种调用方式时，this被自然绑定到该对象。 通常情况 12345678var text = 'window'var obj = &#123; text: 'obj', foo: function()&#123; console.log(this.text); &#125;&#125;obj.foo(); // obj 内部函数调用但是，如果在 obj 的foo()内部再声明一个函数，在内部函数中调用 this，像下面这样： 123456789101112'use strict';var obj = &#123; text: 'hello world', foo: function()&#123; return function()&#123; console.log(this.text); &#125;() &#125;&#125;obj.foo(); // Uncaught TypeError: Cannot read property 'text' of undefined 这是因为 this指针只在 foo 方法的函数内指向 obj ，在函数内部定义的函数，this又指向 undefined了！（在非 strict 模式下，它重新指向全局对象 window ！） 修复的办法是用一个that 变量首先捕获 this： 1234567891011'use strict';var obj = &#123; text: 'obj', foo: function()&#123; var that = this; return function()&#123; console.log(that.text); &#125;() &#125;&#125;obj.foo(); // obj 三种特殊情况new关键字 - 作为构造函数调用时 所谓构造函数，就是通过这个函数生成一个新对象。这时，this 就指这个新对象。 12345678910function Person(__name)&#123; this.name = __name; // this 指向使用该构造函数构造的新对象&#125;Person.prototype.show = function()&#123; alert(this.name);&#125;var Bob = new Person(\"Bob\");Bob.show(); //Bob apply 和 call在 JavaScript 中函数也是对象，对象则有方法，apply()和 call() 就是函数对象的方法。它们能够强制改变函数执行时的当前对象，让 this 指向其他对象。 apply()接收两个参数，第一个参数就是需要绑定的this变量，第二个参数是 Array，表示函数本身的参数。call() 与apply()的唯一区别就是把函数本身的参数一个个传入。 // 对普通函数调用，通常把 this 绑定为 nullMath.max.apply(null, [3, 5, 4]); // 5Math.max.call(null, 3, 5, 4); // 5 举个使用apply() 改变当前对象的栗子： 123456789101112131415var name = \"window\"; var someone = &#123; name: \"Bob\", showName: function()&#123; alert(this.name); &#125;&#125;;var other = &#123; name: \"Tom\"&#125;; someone.showName.apply(); // windowsomeone.showName.apply(other); // Tom apply()的参数为空时，默认调用全局对象。 eval对于 eval 函数，其执行时候似乎没有指定当前对象，但实际上其this 并非指向 window，因为该函数执行时的作用域是当前作用域，即等同于在该行将里面的代码填进去。 12345678910var name = \"window\";var Bob = &#123; name: \"Bob\", showName: function()&#123; eval(\"alert(this.name)\"); &#125;&#125;;Bob.showName(); //Bob 参考 Javascript中this关键字详解 深入浅出 JavaScript 中的 this Javascript的this用法","tags":[{"name":"前端","slug":"前端","permalink":"http://yutaiwei.github.io/tags/前端/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yutaiwei.github.io/tags/JavaScript/"}]},{"title":"flex布局详解","date":"2015-07-26T14:01:10.000Z","path":"2015/07/26/flex布局详解/","text":"flex布局flex可以指定对齐方式，可以解决所有盒子的对齐方式。并利用上页面中的剩余空间。 首先要给最外层的元素设置 12display:flex//或者display:inlineflex 设定主轴的方向 主轴默认是从左往右的方向 交叉轴默认是从上往下的，与主轴垂直。1flex-direction:row|row-reverse// 超出容器是否换行 1234flex-wrap: wrap;//超出后换行flex-wrap: wrap-reverse;//超出后换行 从下往上 复合属性 12flex-flow: column wrap;//超出后换行并且竖直方向排列 确定主轴的对齐方式 12justify-content: flex-end;//flex-start flex-space-ground flex-space-between 交叉轴对齐方式 1234align-items: flex-end;//在交叉轴方向从底部对齐align-items: baseline;//在交叉轴方向从文字基线对齐 设置子容器在父容器中的对齐方式 会覆盖 align-items的值1align-self: center; 处理交叉轴的空白空间 12align-content: flex-start;//对多行起作用，超出的部分会自动留白，并且向头部靠拢，单行使用 align-items 安排容器的排列顺序 - order 12order: -1;//默认值是0，值越小越在前面，可以为负值 基本步骤为： 设置布局方式 设定主轴方向 子元素超过父容器是否换行 确定子元素在主轴或者交叉轴的对齐方式 order安排子元素的排列顺序 核心属性 flex-grow 扩展比例：当盒子中有剩余空间时起作用 默认值0 flex-shrink 收缩比例：当有溢出内容时起作用 默认值是1 flex-basis 基准值：当扩展容器或者收缩容器 时以此值为基准 默认值为auto//基准值为auto时计算中会默认取宽度 溢出比例计算方式为父元素的总宽度 x 基准值的和 y 扩展比例的总和 k ，如果3个盒子每个扩展比例为a、b、c则每个盒子的宽度为(x-y)*a/k+每个盒子自己的基准值 收缩比例的计算方式为：每个子元素算上收缩比例的基准值/所有子元素算上收缩比例的基准值 = 收缩的内容/溢出的内容 ==注意如果有内容，不能收缩到小于自身内容的宽度==","tags":[{"name":"前端","slug":"前端","permalink":"http://yutaiwei.github.io/tags/前端/"},{"name":"css","slug":"css","permalink":"http://yutaiwei.github.io/tags/css/"}]},{"title":"css雪碧图","date":"2015-07-26T04:58:00.000Z","path":"2015/07/26/css雪碧图/","text":"前言CSS雪碧 即CSS Sprite，也有人叫它CSS精灵，是一种CSS图像合并技术，该方法是将小图标合并到一张图片上，然后利用css的背景定位来显示需要显示的图片部分。优点：减少加载网页图片时对服务器的请求次数，提高页面的加载速度，减少鼠标滑过的一些bug。 制作雪碧图的制作，可以使用PS，也可以使用专门的雪碧图制作工具。制作时，最好制作成一列或者一行，定位时会方便一些。下面这个工具挺好用，分享给大家：https://yunpan.cn/cMKygj2hnrBBe 访问密码 f516 css雪碧图简单制作工具（源码）https://github.com/iwangx/sprite 如果要制作svg雪碧图，推荐使用AI。 定位位置雪碧图定位的关键，在于background-position。诀窍在于“调试”，在页面控制背景图上下左右移动，很快就定位好了。 以上面的雪碧图为例，假设我们要显示微博的图标，那么scss代码如下： 123456.icon-weibo&#123; width: 20px; height: 20px; background: url(../../img/test/index/icon.png) no-repeat; background-position: 0px -60px;&#125; 大小假设我们的要显示的图标比雪碧图大，或者比雪碧图小，该怎么办？background-size。 1234567.icon-weibo&#123; width: 40px; height: 40px; background: url(../../img/test/index/icon.png) no-repeat; background-position: -2px -116px; background-size: 118%;&#125; 移动端很多时候，我们并不使用px作为单位，而是rem或者百分比，这时候，该怎么控制雪碧图的位置和大小？利用svg图片。 1&lt;span class=\"i i_menu_0\"&gt;&lt;/span&gt; 123456789101112.i &#123; width: 0.8rem; height: 0.8rem; background: url(../images/ico_global.svg) no-repeat; display: inline-block; background-size: 1100%;&#125;.i_menu_0 &#123; background-position: 0% 0%; &#125;.i_menu_1 &#123; background-position: 10% 0%; &#125;.i_menu_2 &#123; background-position: 20% 0%; &#125;.i_menu_3 &#123; background-position: 30% 0%; &#125;.i_menu_4 &#123; background-position: 40% 0%; &#125;.i_menu_5 &#123; background-position: 50% 0%; &#125; 后记至于PS和AI的使用，在慕课网和网易云课堂上有很多优秀教程，不要错过。 书签CSS雪碧图的实现方法（即背景定位）http://www.suixin8.com/59.html CSS3技术-雪碧图自适应缩放http://www.imooc.com/wiki/detail/id/183 利用动态viewport+rem制作一张自适应的svg雪碧图iconhttp://www.open-open.com/lib/view/open1452229325136.html SVG的用法http://www.webhek.com/svg/","tags":[{"name":"前端","slug":"前端","permalink":"http://yutaiwei.github.io/tags/前端/"},{"name":"css","slug":"css","permalink":"http://yutaiwei.github.io/tags/css/"}]},{"title":"JavaScript 基础--1","date":"2015-07-25T14:01:59.000Z","path":"2015/07/25/JavaScript 基础/","text":"基本语法数据类型null表示一个空的值，而undefined表示值未定义，然而区分两者的意义不大，大多数情况下都应该用 null，undefined 仅在判断函数参数是否传递的情况下有用。 字符串indexOf() 会搜索指定字符串出现的位置。substring(start, end)返回指定索引区间的子串。substr(start, length) 返回从start下标开始的指定数目的子串。 数组slice()是对应String的substring()版本，它截取Array的部分元素，然后返回一个新的Array。如果不给slice()传递任何参数，它就会从头到尾截取所有元素，利用这一点可以很容易复制一个Array。 push()向Array的末尾添加若干元素，pop()则把Array的最后一个元素删除掉。 如果要往Array的头部添加若干元素，使用unshift()方法，shift()方法则把Array的第一个元素删掉。 splice()方法是修改Array的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素。语法是：-splice（） 将原数组清空，将原数组内容以新数组形式返回。 splice（n） 从索引n开始，删除到最后，将删除部分以新数组返回，原数组改变。 splice（n，m） 从索引n开始，删除m项，将删除部分以新数组返回，原数组改变。 splice（n，m，x） 从索引n开始，删除m个，x替换删除部分，返回删除项，原数组改变。 splice（n，0，x） 从索引n开始，一个都不删除，返回空数组，将x增加到索引n的前面，原数组改变。 join()方法把当前Array的每个元素都用指定的字符串连接起来，然后返回连接后的字符串： 12var arr = ['A', 'B', 'C', 1, 2, 3];arr.join('-'); // 'A-B-C-1-2-3' 对象用in操作符可以检测对象是否拥有某一属性。 1234var obj = &#123; a: 'hello'&#125;;'a' in obj; //true 要判断一个属性是否是对象自身拥有的，而不是继承得到的，可以用hasOwnProperty()方法。 obj.hasOwnProperty(‘a’); // trueobj.hasOwnProperty(‘toString’); // false 循环for ... in 循环，可以把一个对象的所有属性依次循环出来，结合 hasOwnProperty()，还可以过滤掉对象继承的属性。 123456789var o = &#123; a: 'hello', b: 'world'&#125;;for (var key in o) &#123; if (o.hasOwnProperty(key)) &#123; alert(key); // 'hello', 'world' &#125;&#125; Map和SetMap 和 Set都是ES6引入的。 JavaScript的默认对象表示方式{} 可以视为其他语言中的Map或Dictionary的数据结构，即一组键值对，但有个问题，就是键必须是字符串。Map解决了这个问题。 初始化Map时直接赋值： 12var m = new Map([['aa', 11], ['bb', 22], ['cc', 33]]);m.get('bb'); //22 初始化一个空 Map： 1234567var m = new Map();m.set('dd', 44);m.set('ee', 55);m.has('ee'); //truem.get('ee'); //55m.delete('ee');m.get('ee'); //undefined Set是一组key的集合，但不存储value。由于key不能重复，所以，在 Set中，没有重复的key。 123var s = new Set([1, 2, 3]); s; //Set &#123;1, 2, 3&#125;s.add(4); //Set &#123;1, 2, 3, 4&#125; 遍历Map和Set可以用for...of循环： 12345678// 遍历Mapfor(var x of m)&#123; alert(x[0] + '=' + x[1]);&#125;// 遍历Setfor(var x of s)&#123; alert(x);&#125; 函数函数定义和调用函数定义 定义函数的方式有两种 一是函数声明： 123function sayA()&#123; alert('A');&#125; 二是函数表达式： 123var sayB = function()&#123; alert('B');&#125; 前者会在代码执行之前提前加载到作用域中，后者则是在代码执行到那一行的时候才会有定义（js奇葩的变量提升机制会将sayB提前，但它的赋值不会提前）。如果使用函数表达式定义，必须在定义后调用，否则会报function undefined。 JavaScript允许传入任意个参数而不影响调用。 arguments arguments只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数。 变量作用域 全局变量会绑定到window上，为减少冲突，可把自己的代码全部放入唯一的名字空间中。 123// 唯一的全局变量MYAPP:var MYAPP = &#123;&#125;;MYAPP.version = 1.0; JavaScript的变量作用域实际上是函数内部，无法在for循环等语句块中定义具有局部作用域的变量。ES6引入了新的关键字let可以申明一个块级作用域的变量。 123for (let i=0; i&lt;100; i++) &#123; sum += i;&#125; ES6中的新关键字const可以定义常量，并具有块级作用域。 高阶函数可以接收函数作为参数的函数称之为高阶函数。 下面以ES5中 Array 自带的几个高阶函数举例。 map() 对数组的每个元素进行一定操作（映射）后，会返回一个新的数组。 123456function pow(x) &#123; return x * x;&#125;var arr = [1, 2, 3, 4, 5];arr.map(pow); // [1, 4, 9, 16, 25] reduce() 把一个函数作用在这个Array的[x1, x2, x3…]上，这个函数必须接收两个参数，reduce()把结果继续和序列的下一个元素做累积计算，其效果就是： [x1, x2, x3, x4].reduce(f) = f(f(f(x1, x2), x3), x4) filter() 创建一个新的匹配过滤条件的数组。把传入的函数依次作用于每个元素，然后根据返回值是true还是false决定保留还是丢弃该元素。 比如把一个数组中的偶数全部删掉： 1234var arr = [1, 2, 4, 5, 6, 9, 10, 15];arr.filter(function (x) &#123; return x % 2 === 1;&#125;); // [1, 5, 9, 15] sort() Array的sort()方法默认把所有元素先转换为String再排序，但可以自定义一个排序规则，并以函数形式传入sort()中。 1234var arr = [10, 20, 1, 2];arr.sort(function (x, y) &#123; return x &gt; y ? 1 : -1&#125;); // [1, 2, 10, 20] forEach() 为每个元素执行对应的方法。 1234var arr = [10, 20];arr.forEach(function(item,index)&#123; console.log(item); //10 20&#125;); 标准对象几条规则 用 parseInt()或 parseFloat() 来转换任意类型到 number 用 String()来转换任意类型到string，或者直接调用某个对象的toString()方法 typeof操作符可以判断出number、boolean、string、function和 undefined 判断 Array要使用Array.isArray(arr) 判断null请使用 myVar === null Date获取当前系统时间： var now = new Date(); 创建一个指定日期和时间的Date对象： var d = new Date(2015, 5, 19, 20, 15, 30, 123);d; // Fri Jun 19 2015 20:15:30 GMT+0800 (CST) 另一种创建指定日期和时间的方法： 12345var d = Date.parse('2015-06-24T19:49:22.875+08:00');d; // 1435146562875// 将时间戳转换为一个Datevar d = new Date(1435146562875);d; // Wed Jun 24 2015 19:49:22 GMT+0800 (CST) 获取当前时间戳的方法： 1234567var time = new Date();//换取当前系统时间var year = time.getFullYear();//获取年 如：2017var month = time.getMonth() + 1;//获取月份，因为从0开始，所以加1var day = time.getDate();//获取天var hours = time.getHours();//时var minutes = time.getMinutes();//分var seconds = time.getSeconds();//秒 JSON概念在JSON中，一共就这么几种数据类型：number、boolean、string、null、array和object。 JSON规定字符集必须是UTF-8，因此不存在多语言问题。为了统一解析，JSON的字符串规定必须用双引号””，Object的键也必须用双引号””。 把任何JavaScript对象变成JSON，就是把这个对象序列化成一个JSON格式的字符串，这样才能够通过网络传递给其他计算机。 收到一个JSON格式的字符串，只需要把它反序列化成一个JavaScript对象，就可以在JavaScript中直接使用这个对象了。 序列化 JSON.stringify(obj) 可以把obj对象序列化成JSON格式的字符串。 12345var obj = &#123; a: 'hello world', b: 666&#125;;JSON.stringify(obj); //\"&#123;\"a\":\"hello world\",\"b\":666&#125;\" 加上参数可以按缩进输出： 1234567JSON.stringify(obj, null, ' ');/*\"&#123; \"a\": \"hello world\", \"b\": 666&#125;\"*/ 第二个参数用于控制如何筛选对象的键值，比如只输出属性a，可用： JSON.stringify(obj, [‘a’], ‘ ‘); 第二个参数也可以是一个函数，这样对象的每个键值对都会被函数先处理。 如果想要精确控制如何序列化对象，可以给 obj 定义一个toJSON()的方法，直接返回JSON应该序列化的数据。 12345678910var obj = &#123; a: 'hello world', b: 666, toJSON: function()&#123; return &#123; \"a\": this.a &#125; &#125;&#125;;JSON.stringify(obj); //\"&#123;\"a\":\"hello world\"&#125;\" 反序列化 拿到一个JSON格式的字符串，我们直接用JSON.parse()把它变成一个JavaScript对象。 12JSON.parse('&#123;\"a\":\"hello world\",\"b\":666&#125;'); //Object &#123;a: \"hello world\", b: 666&#125; JSON.parse()还可以接收一个函数，用来转换解析出的属性： 123JSON.parse('&#123;\"a\":\"hello world\",\"b\":666&#125;', function(key, value)&#123; ...&#125;); 面向对象编程创建对象JavaScript对每个创建的对象都会设置一个原型，指向它的原型对象。 创建对象有两种方法，一是直接用{...}创建一个对象外，二是用构造函数的方法来创建对象。例如1234567function Student(name) &#123; this.name = name; // 这种方式定义的函数不能被多个对象共享 this.hello = function () &#123; alert('Hello, ' + this.name); &#125;&#125; 可以用关键字new来调用这个函数，并返回一个对象。如果不写new，这就是一个普通函数，返回undefined。 可以编写一个createObj函数，封装new操作，通用的模式如下： 12345678910111213function Student(obj) &#123; this.name = obj.name || '匿名'; // 默认值为'匿名' this.grade = obj.grade || 1; // 默认值为1&#125;// 可以被多个对象共享Student.prototype.hello = function () &#123; alert('Hello, ' + this.name);&#125;;function createStudent(obj) &#123; return new Student(obj || &#123;&#125;)&#125; 原型继承JavaScript的原型继承实现方式： 定义新的构造函数，并在内部用call() 调用希望“继承”的构造函数，并绑定this； 借助中间函数 F 实现原型链继承，最好通过封装的 extends函数完成； 继续在新的构造函数的原型上定义新方法。 以实现PrimaryStudent对Student的继承举例，先编写可以复用的extends函数： 123456function extends(Child, Parent)&#123; var F = function()&#123;&#125;; F.prototype = Parent.prototype; Child.prototype = new F(); Child.prototype.constructor = Child;&#125; 继承的实现： 12345678910111213141516171819function Student(obj)&#123; this.name = obj.name || 'aaa';&#125;Student.prototype.hello = function()&#123; alert('hello' + this.name);&#125;function PrimaryStudent(obj)&#123; Student.call(this, obj); this.grade = obj.grade || 1;&#125;// 实现原型继承链:extends(PrimaryStudent, Student);// 绑定其他方法到PrimaryStudent原型:PrimaryStudent.prototype.getGrade = function()&#123; alert(this.grade);&#125; 浏览器浏览器对象window window对象不但充当全局作用域，而且表示浏览器窗口。 window.innerWidth：内部宽度 window.innerHeight：内部高度 内部宽高是指除去菜单栏、工具栏、边框等占位元素后，用于显示网页的净宽高。兼容性：IE&lt;=8不支持。 navigator navigator对象表示浏览器的信息，最常用的属性包括： navigator.appName：浏览器名称 navigator.appVersion：浏览器版本 navigator.language：浏览器设置的语言 navigator.platform：操作系统类型 navigator.userAgent：浏览器设定的User-Agent字符串 navigator的信息可以很容易地被用户修改，所以JavaScript读取的值不一定是正确的。 screen screen对象表示屏幕的信息，常用的属性有： 列表项screen.width：屏幕宽度 screen.height：屏幕高度 screen.colorDepth：返回颜色位数，如8、16、24 location location对象表示当前页面的URL信息。 location.href：获取一个完整的URL location.assign()：加载一个新页面 location.reload()：重新加载当前页面 url各部分值可以通过如下方式获取： 1234567// http://www.example.com:8080/path/index.html?a=1&amp;b=2#TOPlocation.protocol; // 'http'location.host; // 'www.example.com'location.port; // '8080'location.pathname; // '/path/index.html'location.search; // '?a=1&amp;b=2'location.hash; // 'TOP' document document对象表示当前页面，document对象就是整个DOM数的根节点。 document.title：浏览器窗口标题 document.cookie：获取当前页面的Cookie document.getElementById()：按ID获得一个DOM节点 document.getElementsByTagName():按Tag名称获得一组DOM节点 document.getElementsByClassName():按Class名称获得一组DOM节点 操作dom遍历 方法一是上面document的三个getElement方法。 方法二是使用querySelector()和querySelectorAll()。 更新 document.innerHTML：不但可以修改一个DOM节点的文本内容，还可以直接通过HTML片段修改DOM节点内部的子树。 document.innerText：自动对字符串进行HTML编码，保证无法设置任何HTML标签。 插入 appendChild：使用 parentElement.appendChild(someElement)，把一个子节点添加到父节点的最后一个子节点。 insertBefore：使用parentElement.insertBefore(newElement, referenceElement)，把子节点会插入到referenceElement之前。 删除 首先要获得该节点本身以及它的父节点，然后，调用父节点的removeChild把自己删掉。 AJAX1234567891011121314151617181920212223var request;if (window.XMLHttpRequest) &#123; request = new XMLHttpRequest();&#125; else &#123; request = new ActiveXObject('Microsoft.XMLHTTP'); //兼容低版本IE&#125;// 发送请求:request.open('GET', url);request.send();request.onreadystatechange = function () &#123; // 状态发生变化时，函数被回调 if (request.readyState === 4) &#123; // 成功完成 // 判断响应结果: if (request.status === 200) &#123; // 成功，通过responseText拿到响应的文本: return success(request.responseText); &#125; else &#123; // 失败，根据响应码判断失败原因: return fail(request.status); &#125; &#125; else &#123; // HTTP请求还在继续... &#125;&#125; 跨域的解决： 在同源域名下架设一个代理服务器来转发 JSONP 使用HTML5的CORS document.domain window.name Promise可以用来优化异步操作，使代码更优雅。Promise有各种开源实现，在ES6中被统一规范，由浏览器直接支持。 1234567var p1 = new Promise(test);var p2 = p1.then(function (result) &#123; console.log('成功：' + result);&#125;);var p3 = p2.catch(function (reason) &#123; console.log('失败：' + reason);&#125;); 串联起来可简化为： 12345new Promise(test).then(function (result) &#123; console.log('成功：' + result);&#125;).catch(function (reason) &#123; console.log('失败：' + reason);&#125;); 并行执行异步任务： 12345678910var p1 = new Promise(function (resolve, reject) &#123; setTimeout(resolve, 500, 'P1');&#125;);var p2 = new Promise(function (resolve, reject) &#123; setTimeout(resolve, 600, 'P2');&#125;);// 同时执行p1和p2，并在它们都完成后执行then:Promise.all([p1, p2]).then(function (results) &#123; console.log(results); // 获得一个Array: ['P1', 'P2']&#125;);","tags":[{"name":"前端","slug":"前端","permalink":"http://yutaiwei.github.io/tags/前端/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yutaiwei.github.io/tags/JavaScript/"}]},{"title":"JavaScript 正则表达式","date":"2015-07-25T14:01:59.000Z","path":"2015/07/25/JavaScript 正则表达式/","text":"创建一个正则表达式（/…/）核心JavaScript有两种方式创建一个正则表达式：一种是直接通过/正则表达式/写出来，另一种是通过 new RegExp(&#39;正则表达式&#39;)创建一个RegExp对象。 RegExp对象的test()方法用于测试给定的字符串是否符合条件，返回 true或者false。 举例用正则表达式切分字符串比用固定的字符更灵活。如果用户输入了一组标签，可能用逗号、分号或空格分隔，现在需要用正则表达式来把不规范的输入转化成正确的数组： ‘a,b;; c d’.split(/[\\s\\,\\;]+/); // [‘a’, ‘b’, ‘c’, ‘d’] 元字符（. \\d \\w \\s）核心元字符大致分两种，一种是用来匹配文本的（比如 .），另一只是正则表达式的语法所要求的（比如[和]）. . 字符可以匹配任何单个的字符、字母、数字甚至 . 字符本身。 在匹配特殊字符（比如[、] 、\\ 、+ 、* 、? 等在正则表达式中有特殊含义的字符）本身时，需要用元字符\\转义。 空白字符常用的空白字符主要有换行符（\\n）、回车符（\\r）、制表符（\\t）。 其中\\r\\n匹配一个“回车+换行”组合，是 Windows 的文本行结束标签；Unix 只是用一个换行符来结束一个文本行。 使用 \\r\\n\\r\\n 可以匹配两个连续的行尾标签，即空白行。在Unix/Linux上使用 \\n\\n匹配空白行。 字符类别匹配数字：\\d 表示任何一个数字字符（等价于[0-9]） ; \\D 表示任意一个非数字字符（等价于 [^0-9]）。 匹配字母和数字： \\w 表示任何一个字母数字字符（大小写均可）或下划线字符（等价于 [a-zA-Z0-9_]）; \\W表示任意一个非字母数字字符（大小写均可）或下划线字符（等价于[^a-zA-Z0-9_]）。 匹配空白字符：\\s表示任何一个空白字符（等价于 [\\f\\n\\r\\t\\v]）;\\S表示任何一个非空白字符（等价于 [^\\f\\n\\r\\t\\v]） 举例.a.\\.xls可以匹配文件名含a的以.xls结尾的文件。 字符区间（[] ^）核心[] 用来定义一个字符集合，其含义是必须匹配该集合里的字符之一。 定义一个字符集合的具体做法有两种：一是把所有字符列举出来，二是用元字符以字符区间方式给出。 字符集合可以用^来取非，表示除了该字符集合里的字符，其他字符都可以被匹配。 注意，在字符集合里使用 . 和 +这样的元字符将被解释为普通字符，不需要被转义，[\\w.]和 [\\w\\.]的使用效果一样。 举例[0-9a-zA-Z\\_]可以匹配一个数字、字母或者下划线（单个字符）。 [^0-9] 可以匹配任何不是数字的字符。 ^[\\u4e00-\\u9fa5]可以匹配汉字。 重复匹配（+ * ? {n,m}）核心+匹配至少1个字符；*匹配任意个字符（包括0个）；?匹配0个或1个字符；{n} 匹配 n 个字符；{n,m}匹配 n~m 个字符。 正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。加个?就可以让其变成非贪婪匹配（懒惰型）。 举例[a-zA-Z\\_\\$][0-9a-zA-Z\\_\\$]* 可以匹配由字母或下划线、$开头，后接任意个由一个数字、字母或者下划线、$组成的字符串，也就是JavaScript允许的变量名。 \\d{3,8}表示3-8个数字，比如’1234567’。 对 living in &lt;B&gt;AK&lt;/B&gt; and &lt;B&gt;HI&lt;/B&gt;用 &lt;[Bb].*&lt;/[Bb]匹配，得到 &lt;B&gt;AK&lt;/B&gt; and &lt;B&gt;HI&lt;/B&gt;，而用 *的懒惰版本*? ，即 &lt;[Bb].*?&lt;/[Bb] 匹配，可以得到 &lt;B&gt;AK&lt;/B&gt;和&lt;B&gt;HI&lt;/B&gt;。 位置匹配（\\b ^ $）核心单词边界\\b 用来匹配一个单词的开始或结尾，它匹配的是一个这样的位置：这个位置位于一个能够用来构成单词的字符（\\w）和一个不能用来单词的字符（W）之间。\\b 只匹配一个位置，不匹配任何字符。\\B作用与 \\b 相反，匹配一个前后都不是单词边界的连字符。 字符串边界^匹配行字符串的开头； $匹配行字符串的结尾。 举例对 The cat scattered his food all over the room用\\bcat\\b 匹配，只会得到第二个单词cat。用 \\bcat将会匹配以cat开头的任何单词。 js也可以匹配 &#39;jsp&#39;，但是加上^js$就变成了整行匹配，就只能匹配 &#39;js&#39;了。 子表达式分组匹配（() |）核心除了简单地判断是否匹配之外，正则表达式还有提取子串的强大功能。用()表示的就是要提取的分组（Group）。 子表达式的常见用途是：对重复次数元字符的作用对象做出精确的设定和控制，对|控制符的 OR条件做出准确定义。 如果正则表达式中定义了组，就可以在RegExp对象上用exec()方法提取出子串来。 exec()方法在匹配成功后，会返回一个Array，第一个元素始终是原始字符串本身，后面的字符串表示匹配成功的子串。 exec()方法在匹配失败时返回null。 举例^(\\d{3})-(\\d{3,8})$分别定义了两个组，可以直接从匹配的字符串中提取出区号和本地号码： var reg = /^(\\d{3})-(\\d{3,8})$/;reg.exec(‘010-12345’); // [‘010-12345’, ‘010’, ‘12345’]reg.exec(‘010 12345’); // null (19|20)\\d{2} 匹配一个以19或20开头的4位数字，可以用来匹配年份。 全局匹配（g i m）JavaScript的正则表达式中，g表示全局匹配。 全局匹配可以多次执行exec()方法来搜索一个匹配的字符串。当我们指定g标志后，每次运行 exec()，正则表达式本身会更新 lastIndex属性，表示上次匹配到的最后索引。 全局匹配类似搜索，因此不能使用/^...$/，那样只会最多匹配一次。 正则表达式还可以指定i标志，表示忽略大小写，m 标志，表示执行多行匹配。 举例1234567891011var s = 'JavaScript, VBScript';var re=/[a-zA-Z]+Script/g;// 使用全局匹配:re.exec(s); // ['JavaScript']re.lastIndex; // 10re.exec(s); // ['VBScript']re.lastIndex; // 20re.exec(s); // null，直到结束仍没有匹配到","tags":[{"name":"前端","slug":"前端","permalink":"http://yutaiwei.github.io/tags/前端/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yutaiwei.github.io/tags/JavaScript/"}]},{"title":"CSS实现文本溢出显示省略号","date":"2015-07-25T13:43:53.000Z","path":"2015/07/25/CSS实现文本溢出显示省略号/","text":"单行文本溢出显示省略号1234width: 300px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; 如果字符串长度超过300px，那么超出部分就变成...。 多行文本溢出显示省略号1234display: -webkit-box;-webkit-box-orient: vertical;-webkit-line-clamp: 3;overflow: hidden; 因为使用了WebKit的CSS扩展属性，该方法适用于WebKit浏览器及移动端； -webkit-line-clamp用来限制在一个块元素显示的文本的行数。为了实现该效果，它需要组合其他的WebKit属性。常见结合属性：display: -webkit-box; 必须结合的属性 ，将对象作为弹性伸缩盒子模型显示 。-webkit-box-orient 必须结合的属性 ，设置或检索伸缩盒对象的子元素的排列方式 。 怎样在js中判断文本是否溢出问题描述：一段文字限定行数，使用css把多余文字显示为省略号，请问怎么通过js判断这段文字是否有文字显示为省略号？ 思路一王晨帅哥提供了一个思路：取消css的-webkit-line-clamp属性，看看元素高度是否发生了变化，变化了就是有文字显示为省略号。 好想法，最后小编改进后如下：这段文字在页面上放两份，一份限定行数，正常显示；另一份不限定行数，隐藏起来。然后，对比这两段文字的高度是否相同。具体实现：1234567891011121314151617181920212223242526272829// scss部分.info&#123; font-size: 1.2rem; margin-top: .6rem; display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: 4; overflow: hidden; p&#123; &amp;:not(:first-child)&#123; margin-top: .4rem; &#125;; line-height: 1.8rem; &#125;&#125;.info-hidden&#123; position: fixed; z-index: -10; visibility: hidden; font-size: 1.2rem; margin-top: .6rem; p&#123; &amp;:not(:first-child)&#123; margin-top: .4rem; &#125;; line-height: 1.8rem; &#125;&#125; 123456// js部分var $info = $('.info');var $info_hidden = $('.info-hidden');if($info.height() === $info_hidden.height())&#123; $('.more').hide();&#125; 思路二后来张伟林帅哥提供了一个更好的思路：既然已经知道了限定的行数，那么判断一个高度就可以了。结合line-height，高度用scrollheight，判断scrollheight &gt; line-height*你决定的行数。 小编马上搜索了一个scrollheight，发现，原来scrollHeight可以返回元素的完整高度。那么，比较一下scrollHeight和height不就可以了么？具体实现：1234567// js部分var $info = $('.info');console.log($info.height());console.log($info[0].scrollHeight);if($info.height() &gt;= $info[0].scrollHeight)&#123; $('.more').hide();&#125; 后记利用js也可以实现文本溢出显示省略号，可以参考书签中的dotdotdot，很形象的名字。。。 书签CSS实现单行、多行文本溢出显示省略号（…）http://www.daqianduan.com/6179.html jQuery.dotdotdothttp://www.bootcdn.cn/jQuery.dotdotdot/","tags":[{"name":"前端","slug":"前端","permalink":"http://yutaiwei.github.io/tags/前端/"},{"name":"css","slug":"css","permalink":"http://yutaiwei.github.io/tags/css/"}]},{"title":"Javascript学习笔记—2","date":"2015-07-25T02:57:02.000Z","path":"2015/07/25/Javascript学习笔记——基础篇/","text":"什么是JavascriptJavascript是一种基于对象的脚本语言。 基于对象（Object-Based）不提供抽象、继承、重载等有关面向对象语言的功能。而是把其他语言创建的对象统一起来，形成一个对象系统，以供使用。脚本语言最大的特点就是不需要编译和链接。传统编程语言有四个步骤“编写-&gt;编译-&gt;链接-&gt;运行”，而脚本语言只有两个步骤“编写 -&gt; 运行”。 脚本语言是解释执行而非编译执行。windows下，命令提示符界面，就是输入脚本语言的shell；经常见到的“*.bat”批处理文件，就是脚本文件。而在linux系统里面，脚本、脚本编程的概念更是常见。 shell，提供用户使用界面的软件。在windows中，win+R，输入cmd，出现的那个黑黝黝的窗口就是一个shell；打开任务管理器，看到的那个explorer.exe程序，也是一个shell，它叫做GUI shell。在linux中，如果不使用图形用户界面，那么，你所看到的，就是一个shell，一般的linux系统都会提供几种shell供你选择；而如果使用图形用户界面，你看到的界面，就是一个GUI shell。 什么是对象一切都是对象。比如“你”就是一个对象，你拥有姓名、性别、身高、体重等等属性信息，也有跳跃、奔跑、吃饭、睡觉等等方法。 Javascript中使用的对象，分为内置对象和自定义对象。 常见的内置对象有Array、String、Math、Date、Document、Form、Anchor、Link、Image、Windows、Screen、Navigator、Location、History、Frame、DOM、RegExp、StyleSheet、Event、FileSystemObject、Drive、Folder、File、XMLHttpRequest、Error…… Javascript出现的原因1、表单验证。早期的验证全部在服务端，比如注册时需要输入邮箱，而邮箱有固定格式，中间有一个“@”。为了验证一个邮箱格式，就需要发送请求给服务端，服务端的压力很大，多么令人蛋疼。为了减轻服务器的压力，需要一种可以运行在客户端的精小高效的语言。 2、网页交互性。随着互联网的发展，单纯的网页浏览已经无法满足用户的需求，越来越多的用户渴望与网页进行交互。为了改善用户的交互体验，需要开发一种语言，而这种语言运行在服务端是不合适的。 火药的发明，最初并没有想到可以用来打仗。Javascript的作者也没想到，Javascript能够发展到现在这么强大：（1）在浏览器的状态栏或者警告框里，向访问者显示信息。（2）验证表单内容。（3）当访问者将鼠标指针移动到图像上面时，自动替换图像。（4）创建与访问者交互的广告栏，而不仅仅是显示一幅图像。（5）检测可用浏览器或其属性，并且只在支持它们的浏览器上运行高级功能。（6）检测已安装的插件，并在需要某一插件时通知访问者。（7）在不需要访问者重新加载网页的情况下，修改整个或部分网页。（8）显示从远程服务器检索到的数据，或者与远程服务器交互数据。……总结一下，大致分为表单验证、网页特效、浏览器检测。 语法汉语有语法，英语有语法，编程语言也有语法，Javascript也不例外。 语法，简而言之，就是语言表达的规则。你说“我真帅！”，大家理解你的意思，但是你说“帅真我！”，就没有人明白了！同样的，只有遵循一定的规则，浏览器才能明白你写的某句代码的意思。 数据类型数值型、字符串、布尔型、null、undefined、对象、数组 变量和常量和C、Java基本相同，不多解释，如果你没有学过编程，就按照数学中的理解就好了。 运算符和表达式和C、Java基本相同，不懂的同学请自行百度、读书，此处不展开了。 流程和C、Java基本相同，学过C、Java的同学请自行跳过本节。 其实所有的编程语言的执行流程都可以分为四种：（1）顺序。排队买饭，就是一个顺序流程。 （2）条件。假设有两个窗口，窗口一卖饭，窗口二卖汤。如果你想打饭，就去窗口一；如果你想打汤，就去窗口二。这里的“想打饭”和“想打汤”就是条件。 （3）循环。排队买饭，终于排到我了，这时我发现钱不够，于是我回宿舍拿钱；之后回来排队，终于又排到我了，钱还是不够，于是我又回宿舍拿钱……这个过程，就是循环。终于有一次，我的钱拿够了，买到了饭，这个循环就结束了。 （4）其他。比如continue、break、异常处理等。continue，排队买饭，还没有排到我，我发现钱没带，于是提前结束本次排队，回宿舍拿钱，回来后重新排队。break，排队买饭，还没有排到我，突然不想买了，于是结束排队。异常处理，排队买饭，突然收到一个紧急电话，必须去跑1000米。这个紧急电话，就是一个异常，跑1000米，就是处理。 函数和程序函数是用来实现一个功能的程序块。 举个例子，打电话告诉老爸缺钱了。这个过程，有两个动作，“打电话”和“告诉”。这里的“打电话”和“告诉”就是两个函数，也就是两个程序块。 程序块是什么？那些用大括号括起来的代码就是程序块。 程序呢？程序就是命令序列的集合。通俗一点说，程序就是做一件事情的步骤的集合。 “打电话”是一个程序，可以分为这样几个步骤：掏出手机，找到号码，拨号，等待接通。 当然你可以分的更细，比如“掏出手机”也可以看成一个程序，分为这样几个步骤：伸手拿到手机，提高一厘米，提高一厘米，提高一厘米…… 闭包闭包是啥玩意？各种专业文档中给出了void根本看不懂的定义。这里借用阮一峰的理解：闭包就是能够读取和保持其他函数内部变量的函数。 1、作用域要理解闭包，首先必须理解Javascript的变量作用域。变量作用域无非两种：全局变量和局部变量。 Javascript特有“链式作用域”结构。js寻找变量的定义会从最近的区域开始，本地找不到就往上一层区域，直到找到命名空间的顶端，在浏览器的世界里顶端就是window对象了。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。 2、一个例子1234567891011121314151617&lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;script &gt; function f1()&#123; var n = \"hello voidking\"; function f2()&#123; alert(n); &#125; return f2; &#125; var result = f1(); result(); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 运行这段代码，浏览器弹出了“hello voidking”对话框。 这段代码中的f2，就是一个闭包。 虽然外部函数已经返回，但是内部函数仍然记得外部函数定义的变量。 由于在Javascript中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。 在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。功能类似于Java对象中的set和get函数。 3、传引用闭包可以更新外部变量的值。 Javascript中函数的传参是传值，而不是传引用。而在闭包中，其存储的是一个对外部变量的引用。 正则表达式说到正则表达式，很多人会想到通配符。正则表达式和通配符的不同在哪里呢？ 1、通配符是系统级的，在bash shell界面下可以直接使用；正则表达式是需要工具支持的，比如grep、sed、awk等工具。2、通配符一般用来查找文件、文件夹；正则表达式的匹配更加精确，主要用来文本过滤和字符串的操作。 Javascript对于正则表达式有很好的支持，也就是说，我们可以很方便的进行文本过滤和字符串操作。比如开篇提到的邮箱格式验证，我们就可以用正则表达式来实现。 DOMDOM，文档对象模型（Document Object Model）。 DOM独立于语言和平台，是一套标准接口，用来对XML和HTML文档进行增删查改。 DOM规范的核心就是树模型，对于要解析的HTML文档，解析器会把HTML文档加载到内存中，在内存中为HTML文件建立逻辑形式的节点树。而每一个节点，代表一个可以进行交互的对象。 XMLXML，可扩展标记语言（eXtensible Markup Language）。 它的格式很HTML很像，但是，HTML的标记是固定的，不区分大小写；而XML的标记是自定义的，区分大小写的。 XML文档结构分为3个部分：序言、主体和尾声。其中尾声可有可无。如果把一个HTML文档看做是一个主体（一棵树），那么，XML和HTML文档结构的不同，就在于XML多了一个序言，而且，主体可能不止一棵树。 事件编程语言中的事件，我们可以简单理解为事情。 当一件事情发生，我们可能会产生反应，也许不会。 比如，你们的老师让你们写一篇实验报告，这就是一个事件。这个事件发生后，你就会去写实验报告，这就是反应。也许你会吐槽，告诉远方的某位姑娘，老师多么无聊，让你们写实验报告。这时，虽然姑娘也知道了这件事，但是微微一笑（没有去写报告吧），或者连反应都没有。而更多的不知道这个事件的人，当然就当做没发生。 Javascript中的事件，提供了与窗口以及当前加载文档交互的基础。而Javascript对事件的处理，也就是通常所说的反应。 CookieCookie（小甜饼）是由浏览器存储在客户端系统的文本，而且与浏览器的每次请求一同发送到服务器。使用Cookie可以方便地帮助Web服务器保存有关访客的信息。 Cookie常用于以下场合：（1）保存用户登录状态（2）跟踪用户行为（3）定制界面（4）创建购物车 AjaxAjax，异步Javascript和XML（Asynchronous Javascript and XML），被称为远程脚本技术。 Javascript在早期，和服务器通信的方法只有一个——提交表单，远程脚本技术使两者之间的通信变得更加丰富。它可以使Javascript超越客户端的界限，使其能够处理Web服务器上的文件。 特点：局部更新，节省带宽，提高加载速度。 结束语看完上面的概念，是不是在想：什么玩意儿？看不懂没关系，知道有那么一回事就行，下一篇实践篇将会告诉你Javascript到底怎么玩。以上内容也许理解失误的地方，感谢大家留言指正。 参考文档李炎恢的Javascript视频教程《Javascript完全学习手册（作者张银鹤等）》《Javascript基础教程（第七版，作者Tom Negrino、Dori Smith）》《Javascript开发技术详解（作者李峰、晁阳）》一些技术大牛的博客……","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yutaiwei.github.io/tags/JavaScript/"}]},{"title":"css阴影效果","date":"2015-07-25T02:50:25.000Z","path":"2015/07/25/css阴影效果/","text":"有阴影的图，看上去高大上些？不管怎样，UI设计了阴影，咱就照做好了。语法：1box-shadow: h-shadow v-shadow blur spread color inset; 解释： 值 描述 h-shadow 必需。水平阴影的位置。允许负值。 v-shadow 必需。垂直阴影的位置。允许负值。 blur 可选。模糊距离。 spread 可选。阴影的尺寸。 color 可选。阴影的颜色。请参阅 CSS 颜色值。 inset 可选。将外部阴影 (outset) 改为内部阴影。 常见用法：123div&#123; box-shadow: 10px 10px 5px #0cc;&#125; 四个值分别是水平阴影位置、垂直阴影位置、模糊距离、颜色。 实际案例：123&lt;a href=\"\" class=\"confirm\"&gt; &lt;span&gt;马上去抢2G流量&lt;/span&gt;&lt;/a&gt; 12345678910111213141516.confirm&#123; display: inline-block; box-shadow: 0 .5rem 1.5rem #0cc; border-radius: 5px; margin-top: 12%; width: 98%; height: 17%; background: url(../../img/flowrate/blue.jpg) no-repeat; background-size: 100% 100%; color: #fff; span&#123; display: inline-block; margin-top: 3%; font-size: 1.5rem; &#125;&#125; 最终效果如下：","tags":[{"name":"前端","slug":"前端","permalink":"http://yutaiwei.github.io/tags/前端/"},{"name":"css","slug":"css","permalink":"http://yutaiwei.github.io/tags/css/"}]},{"title":"JavaScript之函数科里化","date":"2015-07-25T00:00:00.000Z","path":"2015/07/25/JavaScript之函数柯里化/","text":"什么是柯里化(currying)？维基百科中的解释是：柯里化是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。意思就是当函数被调用时，返回的函数还需要设置一些传入的参数。首先来看一个简单的例子，有下面一个函数： function add(num1, num2) { return num1 + num2; } 我们把它改写成下面这样： var fn = function(a) { return function (b) { return a + b; } } 可以这样调用函数：fn(2)(3)。上面使用了匿名函数来实现多参数函数的方法，虽然这并不是柯里化的函数，但可以帮助我们理解柯里化的含义。 ###实现通用柯里化函数###我们可以在内置构造函数Function()的原型上来添加一个柯里化函数，这样所有的函数都可以调用。下面是通用柯里化函数的实现： Function.prototype.currying = function () { var that = this; var args = [].slice.call(arguments); return function () { return that.apply(null, args.concat([].slice.call(arguments))); } } 现在用柯里化函数将上面的add函数柯里化： var curriedAdd = add.currying(2); curriedAdd(3); // 5 也可以一次性传入两个参数： var curriedAdd = add.currying(2， 3); curriedAdd(); // 5 我们知道在原生对象的原型上扩展方法是不太好的，因为可能会导致命名冲突。所以最好不要把currying函数扩展在Function的原型上，下面是改写的currying函数： function currying(fn) { var args = [].slice.call(arguments, 1); return function () { return that.apply(null, args.concat([].slice.call(arguments))); } } 改写之后currying函数的第一个参数是要被柯里化的函数，可以这样调用： var curriedAdd = currying(add, 2); curriedAdd(3); // 5 或 var curriedAdd = currying(add, 2， 3); curriedAdd(); // 5 上面的add函数只是两个数字的相加，如果我们需要n个数字相加，上面的currying函数已经不能满足要求了，下面是修改后的currying函数： function currying(fn) { var argsArr = []; return function () { if (arguments.length === 0) { return fn.apply(null, argsArr); } else { [].push.apply(argsArr, arguments); } } } 多个数字相加： var add = function () { var num = 0; [].forEach.call(arguments, function (item, i) { num += item; }) return num; } var curriedAdd = currying(add); curriedAdd(2); curriedAdd(3); curriedAdd(4); curriedAdd(5); curriedAdd(); 这样做有什么好处呢？假如说我们只想知道这个月花了多少钱，而中间的某一天之前花了多少我们并不想知道，我们只在乎结果，不在乎过程，上面的currying函数很好地解决了这个问题。有的人说这样做可以节省性能，我倒觉得这和性能没多大关系，或者说这样做的目的并不是为了性能，因为每次计算结果和最后一起计算结果是一样的，都是要计算一样的次数。还有一个好处就是可以复用currying函数，比如我们要多个数字相乘或者其他操作，都可以用currying函数，处理数字只需修改fn参数就可以。 说到柯里化就不得不说Function.prototype.bind这个方法了，它也实现了函数的柯里化。我们可以自己来实现一个bind函数： function bind（fn, context） { var args = [].slice.call(arguments, 2); return function () { return fn.apply(context, args.concat([].slice.call(arguments))); } } 假如我们需要改变fn中的this上下文，就可以用bind函数，否则可以用currying函数。","tags":[{"name":"前端","slug":"前端","permalink":"http://yutaiwei.github.io/tags/前端/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yutaiwei.github.io/tags/JavaScript/"}]},{"title":"CSS3的了解","date":"2015-07-21T14:39:19.000Z","path":"2015/07/21/CSS3之初体验/","text":"自CSS3流行以来，虽然以前看过一遍所有的新增属性，但其实在实际项目中用到的少之又少。所以没有形成系统性的认识，以及看到效果立马就能想到解决方案的能力。然后最近正好遇到一个需要绘制大量动画的需求，所以决定趁此机会好好研究一下这个既熟悉又陌生的css3。 在正式开始css3之前，先来介绍一些比较经典的css3实例，让大家好好感受一下css3的魅力，本文会提到以下几个css3的属性： border-radius、::after、attr和content、box-sizing、linear-gradient、radial-gradient、box-shadow border-radius 相信这个属性，写过css的同学都知道，用来产生圆角，比如画一个圆形： 123456div &#123; width:100px; height:100px; background:red; border-radius:100px; //border-radius:100%;&#125; 然后我们来看看它的语法：border-radius: [左上] [右上] [右下] [左下]，于是我们来画一个半圆 123456div &#123; width: 100px; height: 50px; background: red; border-radius: 50px 50px 0 0;&#125; 那如果要画一个椭圆该怎么办呢？你会发现上面的语法貌似做不到了，其实border-radius的值还有一种语法: x半径/y半径： 123456div &#123; width: 100px; height: 50px; background: red; border-radius: 50px/25px;&#125; 如果我要画半个椭圆，又要咋办呢？ 123456div &#123; width: 100px; height: 50px; background: red; border-radius: 100% 0 0 100% /50%;&#125; ::after这里拿个简单的例子来看，我们要画一个放大镜，如下图： 分析一下，这个放大镜可以由两个div组成，一个是黑色的圆环，一个是黑色把手（旋转45度）。所以我们就需要用两个div来实现吗？答案是NO，一个div也是可以的，我们可以借助::after来添加一个元素。同理如果需要三个div，我们还可以使用::before再添加一个元素。下面看一下代码： 12345678910111213141516171819div &#123; width: 50px; height: 50px; border-radius: 50%; border: 5px solid #333; position: relative;&#125;div::after &#123; content: ''; display: block; width: 8px; height: 60px; border-radius: 5px; background: #333; position: absolute; right: -22px; top: 38px; transform: rotate(-45deg);&#125; attr和content比如我们要实现一个悬浮提示的功能。传统方法，使用title属性就能实现，但是现在我们要更美观，可以使用css3提供的attr：能够在css中获取到元素的某个属性值，然后插入到伪元素的content中去。 假如我们的html代码如下： 1&lt;div data-title=\"hello, world\"&gt;hello...&lt;/div&gt; 我们来看看实现这个插件的css代码： 12345678910111213div &#123; position: relative;&#125;div:hover::after &#123; content: attr(data-title); //取到data-title属性的值 display: inline-block; padding: 10px 14px; border: 1px solid #ddd; border-radius: 5px; position: absolute; top: -50px; left: -30px;&#125; 当hover的时候，在元素尾部添加一个内容为data-title属性值的元素，所以就实现了hover显示的效果，如下图所示： box-sizing我们知道，在标准盒子模型中，元素的总宽＝content + padding + border + margin。 css中的盒子模型大家可能都知道，但是这个盒子模型的属性可能没有那么多人知道，box-sizing属性就是用来重定义这个计算方式的，它有三个取值，分别是：content-box（默认）、border-box、padding-box 一般来说，假如我们需要有一个占宽200px、padding10px、border5px的div，经过计算，要这么定义样式。 123456div &#123; width: 170px; //这里的宽度要使用200-10*2-5*2 = 170得到。 height: 50px; padding: 10px; border: 5px solid red;&#125; 然后我们来使用一下box-sizing属性。 1234567div &#123; box-sizing: border-box; width: 200px; //这里的宽度就是元素所占总宽度，不需要计算 height: 50px; padding: 10px; border: 5px solid red;&#125; linear-gradient做活动页面的时候我们经常会遇到这样的需求： 顶部的中间一张大banner图片，然后整个区域的背景色要根据图片背景色渐变。就可以使用这个属性了。 12345div &#123; width: 200px; height: 50px; background: linear-gradient(to right, red, yellow, black, green);&#125; 是不是很有趣？其实，linear-gradient还有更多有趣的功能，你可以根据下面的动图去感受一下： 你以为这就完了？等等，还有更强大的呢！repeating-linear-gradient，来感受一下： linear-gradient还有更加强大的功能，比如它可以给元素添加多个渐变，从而达到更NB的效果。 radial-gradient上面的linear-gradient是线性渐变，这个属性是径向渐变。下面的代码实现了一个chrome的logo。 1234567891011121314151617div.chrome &#123; width: 180px; height: 180px; border-radius: 50%; box-shadow: 0 0 4px #999, 0 0 2px #ddd inset; background: radial-gradient(circle, #4FACF5 0, #2196F3 28%, transparent 28%), radial-gradient(circle, #fff 33%, transparent 33%), linear-gradient(-50deg, #FFEB3B 34%, transparent 34%), linear-gradient(60deg, #4CAF50 33%, transparent 33%), linear-gradient(180deg, #FF756B 0, #F44336 30%, transparent 30%), linear-gradient(-120deg, #FFEB3B 40%, transparent 40%), linear-gradient(-60deg, #FFEB3B 30%, transparent 30%), linear-gradient(0deg, #4CAF50 45%, transparent 45%), linear-gradient(60deg, #4CAF50 30%, transparent 30%), linear-gradient(120deg, #F44336 50%, transparent 50%), linear-gradient(180deg, #F44336 30%, transparent 30%);&#125; 实现原理就是使用了多个渐变色放在div上，友协被遮住，视觉上就产生了想要的效果，是不是很强大！看了下图你就知道其实就是在div上加了很多个渐变。 box-shadow上面的例子大都是对css3新属性的了解和认识，这个实例则是有关于解决方案的例子。 需求：我们要实现下面这个效果图（三个边框：黑色，绿色，红色）： 解法一：假如没有css3知识，我们可以做这样做：用三个div，分别设置边框，然后分别控制宽高和位置来达到这个效果。显然，很复杂，这里就不贴代码了。 解法二：现在我们有css3的知识了，借助box-shadow就可以轻松解决这个问题。先来看看它的语法：box-shadow: [x偏移] [y偏移] [阴影模糊宽度] [阴影宽度] [颜色]，并且还能添加多个阴影，使用逗号隔开。 当然你还可以继续增加，四重边框，五重边框……都不再是问题啦。另外，还能加圆角，阴影会贴紧内层div。 使用这种方法，有一个缺点就是，不支持虚线边框。 解法三： 使用outline（只能支持两重边框） 使用这种方法的缺点就是，只能支持两层的边框，而且还不能根据容器的border-radius自动贴合。 总结通过这段时间对css3的深入了解，发现css3真的很强大，研究起来还是挺有趣的，只有想不到，感觉没有做不到。不过为了实现很酷炫的效果，可能需要编写大量的css代码，这个时候使用什么技术就需要我们自己来衡量了。","tags":[{"name":"CSS3","slug":"CSS3","permalink":"http://yutaiwei.github.io/tags/CSS3/"},{"name":"实例","slug":"实例","permalink":"http://yutaiwei.github.io/tags/实例/"}]}]