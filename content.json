[{"title":"我的生活","date":"2018-03-12T06:53:59.000Z","path":"2018/03/12/我的生活/","text":"","tags":[]},{"title":"AngularJS 中 Controller 之间的通信","date":"2016-03-22T14:01:59.000Z","path":"2016/03/22/AngularJS 中 Controller 之间的通信/","text":"用 Angular 进行开发，基本上都会遇到 Controller 之间通信的问题，本文对此进行一个总结。 在 Angular 中，Controller 之间通信的方式主要有三种： 作用域继承。利用子 Controller 控制父 Controller 上的数据。（父 Controller 中的数据要为引用类型，不能是基本类型） 注入服务。把需要共享的数据注册为一个service，在需要的 Controller 中注入。 基于事件。利用 Angular 的事件机制，使用 $on、$emit和 $boardcast 其中，作用域继承仅限于上下级之间的通信，注入服务和基于事件的机制可以实现任意级别的 Controller 通信。 作用域继承这里直接上栗子。 页面： 123456&lt;div ng-controller=\"parentCtrl\"&gt; &lt;p&gt;data in parent controller : &#123;&#123;data.name&#125;&#125;&lt;/p&gt; &lt;div ng-controller=\"childCtrl\"&gt; &lt;input type=\"text\" ng-model=\"data.name\"&gt; &lt;/div&gt;&lt;/div&gt; 控制器： 1234567891011angular.module('demo', []).controller('parentCtrl', ['$scope', function($scope)&#123; $scope.data = &#123; name: 'htf' &#125;&#125;]).controller('childCtrl', ['$scope', function($scope)&#123; &#125;]) 以上是父 Controller 中的数据是引用类型的情况。如果父 Controller 中的数据是基本类型，可通过$scope.$parent.data 访问。 很显然，这种方式仅适用于父子级间 Controller 的通信。 注入服务在 Angular 中，服务是一个单例，所以在服务中生成一个对象，该对象就可以利用依赖注入的方式在所有的控制器中共享。 看个栗子，先定义一个service: 123456angular.module('demo') .factory('Data', function()&#123; return &#123; name: 'htf' &#125;; &#125;) 页面： 12345678&lt;div ng-controller=\"childCtrl1\"&gt; &lt;h3&gt;data in child controller 1 : &#123;&#123;data.name&#125;&#125;&lt;/h3&gt; &lt;input class=\"form-control\" type=\"text\" ng-model=\"data.name\"&gt;&lt;/div&gt;&lt;div ng-controller=\"childCtrl2\"&gt; &lt;h3&gt;data in child controller 2 : &#123;&#123;data.name&#125;&#125;&lt;/h3&gt; &lt;input class=\"form-control\" type=\"text\" ng-model=\"data.name\"&gt;&lt;/div&gt; 控制器： 1234567.controller('childCtrl1', ['$scope', 'Data', function($scope, Data)&#123; $scope.data = Data;&#125;]).controller('childCtrl2', ['$scope', 'Data', function($scope, Data)&#123; $scope.data = Data;&#125;]) 这种方式适用于任何需要通信的 Controller 之间。 基于事件Angular 为$scope 提供了冒泡和隧道机制，$broadcast会把事件广播给所有子 Controller，而$emit则会将事件冒泡传递给父 Controller，$on则是 Angular 的事件监听函数，利用这三者，可以实现上下级和同级（需要构造一个共同的父级 Controller）之间的通信。 上下级之间这种情况下比较简单。 如果是子 Controller 往父 Controller 上发送事件（从作用域往上发送事件），使用scope.$emit $scope.$emit&#40;”someEvent”, {}&#41;; 如果是父 Controller 往子 Controller 上发送事件（从作用域往下发送事件），使用 scope.$broadcast $scope.$broadcast(“someEvent”, {}); 无论是 $emit还是 $broadcast发送的事件，都用 $scope.$on接收：123$scope.$on(\"someEvent\", function(event, data) &#123; // 这里取到发送过来的数据 data&#125;); 同级之间同级之间利用事件通信有两种方法。一种是利用上下级之间事件传播的变形，另一种是借助 $rootScope 。 借助父 controller 先看第一种，在子 Controller 中向父 Controller 触发一个事件，然后在父 Controller 中监听事件，再广播给子 Controller ，这样通过事件携带的参数，实现了数据经过父 Controller，在同级 Controller 之间传播。 但是要注意，通过父 Controller 作为中介进行传递的话，子 Controller 触发的事件名和父 Controller 广播用的事件名不能一样，否则会进入死循环。 看代码：123456789&lt;div ng-controller=\"outerCtrl\"&gt; &lt;h3&gt;data in outer controller: &#123;&#123;name&#125;&#125;&lt;/h3&gt; &lt;div ng-controller=\"innerCtrl1\"&gt; &lt;input class=\"form-control\" type=\"text\" ng-model=\"name\" ng-change=\"change()\"&gt; &lt;/div&gt; &lt;div ng-controller=\"innerCtrl2\"&gt; &lt;input class=\"form-control\" type=\"text\" ng-model=\"name\" ng-change=\"change()\"&gt; &lt;/div&gt;&lt;/div&gt; 关键部分在控制器： 12345678910111213141516171819202122232425262728.controller('outerCtrl', ['$scope', function($scope)&#123; $scope.name = 'htf'; $scope.$on('dataChanged', function(event, data)&#123; $scope.name = data; // 2. 父 Ctrl 监听到 dataChanged 时间后，触发 changeData 事件 $scope.$broadcast('changeData', data); &#125;)&#125;]).controller('innerCtrl1', ['$scope', function($scope)&#123; $scope.change = function()&#123; // 1. 子 Ctrl1 中数据改变之后触发 dataChanged 事件 $scope.$emit('dataChanged', $scope.name); &#125; $scope.$on('changeData', function(event, data)&#123; $scope.name = data; &#125;)&#125;]).controller('innerCtrl2', ['$scope', function($scope)&#123; $scope.change = function()&#123; $scope.$emit('dataChanged', $scope.name); &#125; // 3. 监听到 changeData 事件后，改变子 Ctrl2 中 数据 $scope.$on('changeData', function(event, data)&#123; $scope.name = data; &#125;)&#125;]) 借助 $rootScope 每个 Angular 应用默认有一个根作用域$rootScope， 根作用域位于最顶层，从它往下挂着各级作用域。 所以，如果子控制器直接使用 $rootScope广播和接收事件，那么就可实现同级之间的通信。 看栗子： 123456&lt;div ng-controller=\"innerCtrlA\"&gt; &lt;input class=\"form-control\" type=\"text\" ng-model=\"name\" ng-change=\"change()\"&gt;&lt;/div&gt;&lt;div ng-controller=\"innerCtrlB\"&gt; &lt;input class=\"form-control\" type=\"text\" ng-model=\"name\" ng-change=\"change()\"&gt;&lt;/div&gt; 控制器： 12345678910111213141516171819.controller('innerCtrlA', ['$scope', '$rootScope', function($scope, $rootScope)&#123; $scope.change = function()&#123; // 广播事件 $rootScope.$broadcast('nameChanged', $scope.name); &#125; $rootScope.$on('nameChanged', function(event, data)&#123; $scope.name = data; &#125;)&#125;]).controller('innerCtrlB', ['$scope', '$rootScope', function($scope, $rootScope)&#123; $scope.change = function()&#123; $rootScope.$broadcast('nameChanged', $scope.name); &#125; // 监听事件 $rootScope.$on('nameChanged', function(event, data)&#123; $scope.name = data; &#125;)&#125;]) 参考 作用域与事件 Angularjs Controller 间通信机制 AngularJS控制器controller如何通信？ controller 间共享数据","tags":[{"name":"Angular","slug":"Angular","permalink":"http://yutaiwei.github.io/tags/Angular/"},{"name":"前端","slug":"前端","permalink":"http://yutaiwei.github.io/tags/前端/"}]}]