[{"title":"AngularJS按需加载js","date":"2016-08-02T15:57:39.000Z","path":"2016/08/02/AngularJS按需加载js/","text":"前言Angular是一个单页面应用，随着系统的迭代，首屏代码会越来越大，所以对《AngularJS入门》中的代码进行改造，实现AngularJS可以按需加载js和css。 实现这个需求，有三个方案：1、利用requirejs。requirejs并不是按照angular规范开发的第三方插件，后期估计会有很多坑，放弃。 2、利用ui-router和ocLazyLoad。 每次“页面跳转”都要额外请求js并加载，浪费带宽增加页面加载时间，基本抛弃了预加载。 每一个路由都需要配置resolve属性，太low。 模块化程度太低，不利于以后代码移植和维护。 3、自己写需要的组件。最好的方案，然而技术要求太高，放弃。 综上，第三种方案暂时无法实现，放弃；第一种方案坑太多，放弃；第二种方案也不好，但是相对容易，而且是针对angular的插件，就它了。1234bower install angular#1.5.8bower install angular-ui-routerbower install oclazyloadbower install bootstrap 核心代码123456789101112131415161718192021222324252627282930313233&lt;!--dynamic/index.html--&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"zh\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;link rel=\"stylesheet\" href=\"bower_components/bootstrap/dist/css/bootstrap.min.css\"&gt; &lt;style&gt; body&#123; font-family: \"Microsoft Yahei\"; &#125; .navigator&#123; width: 500px;margin: 0 auto &#125; .navigator li&#123; color: #000;font-size: 14px; &#125; &lt;/style&gt; &lt;title&gt;按需加载js&lt;/title&gt;&lt;/head&gt;&lt;body ng-app=\"myApp\"&gt; &lt;ul class=\"navigator nav nav-pills\"&gt; &lt;li role=\"presentation\" class=\"active\"&gt;&lt;a href=\"#home\" ng-click=\"isActive($event)\"&gt;主页&lt;/a&gt;&lt;/li&gt; &lt;li role=\"presentation\" class=\"active\"&gt;&lt;a href=\"#page2\"&gt;Page2&lt;/a&gt;&lt;/li&gt; &lt;li role=\"presentation\" class=\"active\"&gt;&lt;a href=\"#page3\" ng-click=\"isActive($event)\"&gt;Page3&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div ui-view style=\"width: 500px;margin: 50px auto 0\"&gt;&lt;/div&gt;&lt;script src=\"bower_components/angular/angular.min.js\"&gt;&lt;/script&gt;&lt;script src=\"bower_components/angular-ui-router/release/angular-ui-router.min.js\"&gt;&lt;/script&gt;&lt;script src=\"bower_components/oclazyload/dist/ocLazyLoad.min.js\"&gt;&lt;/script&gt;&lt;script src=\"public/js/index.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/* *dynamic/public/js/index.js*/var myApp=angular.module(\"myApp\",[\"ui.router\",\"oc.lazyLoad\"]);myApp.config(function ($stateProvider,$urlRouterProvider) &#123; $urlRouterProvider.when(\"\",\"/home\"); $stateProvider.state('home',&#123; url:\"/home\", templateUrl: 'views/homepage.html', controller: 'homeController', resolve:&#123; loadMyCtrl:['$ocLazyLoad',function ($ocLazyLoad) &#123; return $ocLazyLoad.load(&#123; name:\"homeApp\", files:[\"public/js/homepage.js\"] &#125;) &#125;] &#125; &#125;); $stateProvider.state('page2',&#123; url:\"/page2\", templateUrl:'views/page2.html', resolve:&#123; loadMyCtrl:function ($ocLazyLoad) &#123; return $ocLazyLoad.load(&#123; name:'page2App', files:[\"public/js/page2.js\"] &#125;) &#125; &#125; &#125;) $stateProvider.state('page3',&#123; url:\"/page3\", templateUrl:'views/page3.html', resolve:&#123; loadMyCtrl:function ($ocLazyLoad) &#123; return $ocLazyLoad.load(&#123; name:'page3App', files:[\"public/js/page3.js\",\"public/js/page3-ext.js\"] &#125;) &#125; &#125; &#125;) &#125;); 12345&lt;!--dynamic/views/homepage.html--&gt;&lt;div id=\"home\" ng-controller=\"homeController\"&gt; &lt;h1&gt;首页&lt;/h1&gt; &#123;&#123;content&#125;&#125;&lt;/div&gt; 123456/* *dynamic/public/js/homepage.js*/angular.module('myApp').controller('homeController', function ($scope) &#123; $scope.content = '这是主页的内容';&#125;); 完整代码github自取：https://github.com/voidking/angulardemo/tree/master/dynamic 书签RequireJS官方文档http://requirejs.org/docs/start.html Dynamically Loading Controllers and Views with AngularJShttp://weblogs.asp.net/dwahlin/dynamically-loading-controllers-and-views-with-angularjs-and-requirejs angular应用如何实现按需加载http://www.alloyteam.com/2015/10/angular-application-how-to-load-on-demand/ 尝试通过AngularJS模块按需加载搭建大型应用（上）http://web.jobbole.com/86915/ 尝试通过AngularJS模块按需加载搭建大型应用（下）http://web.jobbole.com/87025/ angularjs ocLazyLoad分步加载js文件,angularjs ocLazyLoad按需加载jshttp://m.w2bc.com/article/158713 按需加载 AngularJS 的 Controllerhttp://beginor.github.io/2014/12/20/angularjs-controller-load-on-demand.html","tags":[{"name":"前端","slug":"前端","permalink":"http://yutaiwei.github.io/tags/前端/"},{"name":"angularjs","slug":"angularjs","permalink":"http://yutaiwei.github.io/tags/angularjs/"}]},{"title":"AngularJS 表单验证","date":"2016-06-02T14:01:59.000Z","path":"2016/06/02/AngularJS 表单验证/","text":"AngularJS 表单验证在使用 AngularJS 进行开发的时候，表单填写是一个很常见的需求，而表单验证又是比较让人头疼的部分，本文对此做一个总结。 在 Angular 的视图中使用的 form 已经不是 HTML 中的普通 form 了，而是一个被 Angular 封装过的指令。它可以完成普通 form 无法实现的功能，比如 form 嵌套，而且自带强大的验证功能。Angular 在对表单进行校验的时候会使用 ngModelController上的属性，如果不设置ng-model，则 Angular 无法知道form.$invalid 这个值是否为真。后面在自定义验证有对它的介绍。 本文在对表单的验证时使用了ng-messages，在文章最后也有对它的介绍。 input元素的type属性值： checkbox 创建一个复选框 email 创建一个接受邮件地址作为值的文本输入框 number 创建一个接收数值类型作为值的文本输入框 radio 创建一个单选框 text 创建一个接收任何值的标准文本输入框 url 创建一个接收URL作为值的文本输入框 监控表单的有效性 $pristine 如果用户没有与元素/表单产生交互，则返回true $dirty 如果用户与元素/表单产生过交互，则返回true $valid 当元素/表单内容的校验结果为有效时则返回true $invalid 当元素/表单内容的校验结果为无效时则返回true $error 提供校验错误的详情信息 原生表单验证在 form 层面，可以使用 ng-disabled来控制提交按钮的状态，在 form 表单项全部验证通过前不可点击，下面介绍一下通用的表单项验证选项。 input 验证选项AngularJS 的 input 标签 自带的验证选项有以下这些。 1234567891011&lt;input ng-model=\"\" [name=\"\"] [required=\"\"] [ng-required=\"\"] [ng-minlength=\"\"] [ng-maxlength=\"\"] [ng-pattern=\"\"] [ng-change=\"\"]&gt;...&lt;/input&gt; a. 必填 1&lt;input type=\"text\" name=\"myName\" ng-model=\"username\" required /&gt; 使用ng-required可以根据后面表达式的值设置是否 required。 在不满足required时form.myName.$error 为 {required: true} 。b. 长度 1&lt;input type=\"text\" name=\"myName\" ng-model=\"username\" ng-minlength=\"2\" ng-maxlength=\"10\" /&gt; 在不满足 ng-minlength/ng-maxlength时 form.myName.$error为 {minlength: true, maxlength: true}。 直接使用minlength/maxlength也有相同效果，而且 maxlength 可以设置最多输入 x 个字符，超过之后无法再输入。 c. 模式匹配 1&lt;input type=\"text\" name=\"myDesc\" ng-model=\"desc\" ng-pattern=\"/^[a-zA-Z]&#123;1,20&#125;$/\" /&gt; 在不满足 ng-pattern时 form.myName.$error为 {pattern: true}。 d. 其他 AngularJS 对特定格式也进行了校验。比如将 type设置为 url，email等，在没有特殊验证要求的情况下，可以直接使用这些自带的校验，或者通过自定义指令修改 Angular 内建验证器。不同 type 有不同的验证选项。 CSS ClassesAngular 会根据表单状态自动给表单和表单项添加以下几组样式： ng-valid 验证通过，与之相对的是ng-invalid-ng-valid-[key]通过自定义验证器添加的验证通过的值，与之相对的是ng-invalid-[key] ng-pristine未交互状态，与之相对的是 ng-dirty ng-touched未访问状态，与之相对的是ng-untouched ng-pending 满足 $asyncValidators的情况 这些在 ngModelController 的属性中都有对应值。 根据这些 class，可以为不同状态设置不同的样式，比如这样： 1234567input.ng-valid.ng-dirty &#123; border-color: #78FA89;&#125;input.ng-invalid.ng-dirty &#123; border-color: #FA787E;&#125; 自定义验证在 AngularJS 指令入门 一文中，提到过通过 require 属性和 controller 参数，可以实现指令之间的交互。那么，在自定义指令中使用 require: &#39;ngModel&#39;就可以使用 ngModel 指令的 controller 属性的实例了。 ngModelControllerngModel 提供了数据绑定、验证、CSS更新、数据格式化和编译等操作。下面简单介绍一下 ngModelController 常用的属性和方法。 核心属性a. $viewValue视图里的值 b. $modelValue数据模型里值 在 input事件触发的时候，$viewValue会同步到 $modelValue。默认情况下，这个是一旦 input中的内容有改变就触发。AngularJS 1.3 引入了 ng-model-options，可以让这个同步延迟到 blur 或者延迟一定的时间之后。 12&lt;input type=\"text\" name=\"username\" ng-model=\"username\" ng-model-options=\"&#123;updateOn:'blur'&#125;\"&gt;&lt;input type=\"text\" name=\"username\" ng-model=\"username\" ng-model-options=\"&#123; debounce: 500 &#125;\"&gt; 在$viewValue的值同步到 $modelValue时，会经过 $parsers、$validators 和 $asyncValidators三个核心管道（后两个是 AngularJS 1.3 以后新加的）进行处理，通过后才更新到 $modelValue上（如果验证器管道没通过，不会更新）。 核心管道a. $parsers改变视图值的格式，并更新的到模型（$viewValue -&gt; $modelValue），与之相对的是 $formatters，刚好反过来。 b. $validators用来添加同步验证器 c. $asyncValidators用来添加异步验证器 常用属性a. $error没有通过的验证器名称及对应的错误信息 b. $valid表单项是否都通过验证，都通过时为 true，与之相对的是$invalid c. $touched 表单项是否被访问过，如果获得过焦点，在失去时该值为 true，与之相对的是 $untouched d.$dirty 表示用户是否和表单项交互过（比如输入一些东西），只要有任何改变，该值为 true，与之相对的是 $pristine 常用方法a. $render定义视图具体的渲染方式 b. $setViewValue设置视图值（需要手动触发一个 $digest），使用场景是在自定义指令中监听自定义事件（比如使用具有回调的 jQuery 插件） ngMessagesng-messages是 AngularJS 1.3 提供的一个用来增强模版显示的模块，主要用在处理复杂的错误信息。 在以前的版本中，如果想处理错误信息的显示，可能需要定义一堆code再结合复杂的ng-if语句来实现。而且在输入同时满足多条错误规则的情况下，无法控制错误信息显示的优先级。这些，使用 ng-messages可以完美解决。 准备工作引入 angular-messages.js添加依赖：angular.module(&#39;app&#39;, [&#39;ngMessages&#39;]) 使用方法有两种使用方法，一是将ng-messages 当作属性指令使用：1234567&lt;form name=\"myForm\"&gt; &lt;input type=\"text\" ng-model=\"field\" name=\"myField\" required minlength=\"5\" /&gt; &lt;div ng-messages=\"myForm.myField.$error\"&gt; &lt;div ng-message=\"required\"&gt;必填&lt;/div&gt; &lt;div ng-message=\"minlength\"&gt;长度不够&lt;/div&gt; &lt;/div&gt;&lt;/form&gt; 这样会按照各个错误信息书写的先后顺序进行单一显示，如果想同时显示所有的错误信息，加个ng-messages-multiple： 1&lt;div ng-messages=\"myForm.myField.$error\" ng-messages-multiple&gt;&lt;/div&gt; 另一种是将 ng-messages 当作元素指令使用：1234&lt;ng-messages for=\"myForm.myField.$error\"&gt; &lt;ng-message when=\"required\"&gt;必填&lt;/ng-message&gt; &lt;ng-message when=\"minlength\"&gt;长度不够&lt;/ng-message&gt;&lt;/ng-messages&gt; 如果很多表单项的错误提示信息都一样，也可以把错误信息放在模版里，使用ng-messages-include指令来引用： 12&lt;div ng-messages=\"myForm.username.$error\" ng-messages-include=\"validateTemplate/error.html\"&gt;&lt;/div&gt; 错误模版文件： 12&lt;div ng-message=\"required\"&gt;必填&lt;/div&gt;&lt;div ng-message=\"minlength\"&gt;长度不够&lt;/div&gt;","tags":[{"name":"Angular","slug":"Angular","permalink":"http://yutaiwei.github.io/tags/Angular/"},{"name":"前端","slug":"前端","permalink":"http://yutaiwei.github.io/tags/前端/"}]},{"title":"AngularJS 中的服务Provider","date":"2016-05-25T14:01:59.000Z","path":"2016/05/25/AngularJS 中的服务Provider/","text":"在一个分层良好的 Angular 应用中，Controller 这一层应该很薄。也就是说，应用里大部分的业务逻辑和持久化数据都应该放在 Service 里。 为此，理解 AngularJS 中的几个 Provider 之间的区别很有必要。Provider 创建的新服务都可以用来注入。包括： provider factory service constant value 另外，内建的服务$controller和$filter 也可以被注入，同时也可以使用这些服务来获得新的过滤器和控制器。 下面介绍一下各自的用法和 provider、factory、value 三者之间的区别。 provider用于产生一个可配置的 Service，由两部分组成。第一部分的变量和函数是可以在app.config函数中访问的，可以在它们被其他地方访问到之前来修改它们。定义方式如下： 1234app.provider('myProvider', function()&#123; var a = ''; var func = function()&#123;&#125;;&#125;) 在 app.config函数对 a进行修改： 123app.config(function(myProviderProvider)&#123; myProvider.a = 'hello world';&#125;) 这也是在有如此简单的 factory 的情况下还使用 provider 的原因。 第二部分的变量和函数是通过$get()函数返回的，可以在任何传入了该 provider 的控制器中进行访问的。 12345678app.provider('myProvider', function()&#123; this.$get = function()&#123; return &#123; foo: function()&#123;&#125;, a: a &#125; &#125;&#125;) factoryfactory 返回一个对象。只需要创建一个对象，为它添加属性，然后返回这个对象。在控制器中注入该 factory，即可使用它的所有属性。 123456app.factory('myFactory', function()&#123; var fac = &#123;&#125;; fac.a = 'hello world'; fac.foo = function()&#123;&#125;; return fac;&#125;) 看得出来，factory 的第二个参数就是 provider 中$get要对应的函数实现。 serviceservice 类似于一个构造器， 通过new关键字实例化对象，将一些属性和方法直接添加到 this上，在创建 service 对象时，this会被作为返回值返回。 123456app.service('myService', function()&#123; var a = ''; this.setA = function()&#123;&#125;; this.getA = function()&#123;&#125;; this.foo = function()&#123;&#125;;&#125;) 注入myService 的控制器可以访问到绑定在myService 中 this上的 setA(),getA() 和 foo()三个方法。 constantconstant 用于定义常量，一旦定义就不能被改变。可以被注入到任何地方，但是不能被装饰器(decorator)装饰。 app.constant(‘APP_KEY’, ‘a1s2d3f4’) value与 constant 一样，可以用来定义值。但与 constant 的区别是：可以被修改，可以被 decorator 装饰，不能被注入到 config 中。 app.value(‘version’, ‘1.0’) value 通常用来为应用设置初始值。 decorator比较特殊，它不是 provider 。它是用来装饰其他 provider 的，不过 constant 除外，因为从源码可以看出，constant 不是通过 provider()方法创建的。 下面是一个用 decorator 装饰 value 的栗子。 1234app.value('version', '1.0');app.decorator('version', function ($delegate) &#123; return $delegate + '.1';&#125;) 那如果要使用前面的myService service，但是其中缺少一个你想要的 greet 函数。可以修改 service 吗？答案是不行！但是可以装饰它： 12345app.decorator('myService', function($delegate)&#123; $delegate.greet = function()&#123; return \"Hello, I am a new function of 'myService'\"; &#125;&#125;) $delegate代表实际上的 service 实例。 装饰一个 service 的能力是非常实用的，尤其是当我们想要使用第三方的 service 时，此时不需要将代码复制到我们的项目中，而只需要进行一些修改即可。 什么时候使用 provider 而不用 factory ？provider 是 factory 的加强版。当需要一个可配置的 factory 的时候，使用 provider。 简单介绍一下 AngularJS 运行应用的过程，分两个阶段，config 阶段和 run 阶段。config 阶段是设置任何的 provider 的阶段。也是设置任何的指令，控制器，过滤器以及其它东西的阶段。在 run 阶段，AngularJS 会编译你的 DOM 并启动应用。 factory 和 service 的区别是什么？factory 是普通 function，而 service 是一个构造器(constructor)，这样 Angular 在调用 service 时会用 new 关键字，而调用 factory 时只是调用普通的 function，所以 factory 可以返回任何东西，而 service 可以不返回。 参考 AngularJS 之 Factory vs Service vs Provider 理解AngularJS中的Service类型 AngularJS中的Provider们：Service和Factory等的区别","tags":[{"name":"Angular","slug":"Angular","permalink":"http://yutaiwei.github.io/tags/Angular/"},{"name":"前端","slug":"前端","permalink":"http://yutaiwei.github.io/tags/前端/"}]},{"title":"AngularJS 中 Controller 之间的通信","date":"2016-03-22T14:01:59.000Z","path":"2016/03/22/AngularJS 中 Controller 之间的通信/","text":"用 Angular 进行开发，基本上都会遇到 Controller 之间通信的问题，本文对此进行一个总结。 在 Angular 中，Controller 之间通信的方式主要有三种： 作用域继承。利用子 Controller 控制父 Controller 上的数据。（父 Controller 中的数据要为引用类型，不能是基本类型） 注入服务。把需要共享的数据注册为一个service，在需要的 Controller 中注入。 基于事件。利用 Angular 的事件机制，使用 $on、$emit和 $boardcast 其中，作用域继承仅限于上下级之间的通信，注入服务和基于事件的机制可以实现任意级别的 Controller 通信。 作用域继承这里直接上栗子。 页面： 123456&lt;div ng-controller=\"parentCtrl\"&gt; &lt;p&gt;data in parent controller : &#123;&#123;data.name&#125;&#125;&lt;/p&gt; &lt;div ng-controller=\"childCtrl\"&gt; &lt;input type=\"text\" ng-model=\"data.name\"&gt; &lt;/div&gt;&lt;/div&gt; 控制器： 1234567891011angular.module('demo', []).controller('parentCtrl', ['$scope', function($scope)&#123; $scope.data = &#123; name: 'htf' &#125;&#125;]).controller('childCtrl', ['$scope', function($scope)&#123; &#125;]) 以上是父 Controller 中的数据是引用类型的情况。如果父 Controller 中的数据是基本类型，可通过$scope.$parent.data 访问。 很显然，这种方式仅适用于父子级间 Controller 的通信。 注入服务在 Angular 中，服务是一个单例，所以在服务中生成一个对象，该对象就可以利用依赖注入的方式在所有的控制器中共享。 看个栗子，先定义一个service: 123456angular.module('demo') .factory('Data', function()&#123; return &#123; name: 'htf' &#125;; &#125;) 页面： 12345678&lt;div ng-controller=\"childCtrl1\"&gt; &lt;h3&gt;data in child controller 1 : &#123;&#123;data.name&#125;&#125;&lt;/h3&gt; &lt;input class=\"form-control\" type=\"text\" ng-model=\"data.name\"&gt;&lt;/div&gt;&lt;div ng-controller=\"childCtrl2\"&gt; &lt;h3&gt;data in child controller 2 : &#123;&#123;data.name&#125;&#125;&lt;/h3&gt; &lt;input class=\"form-control\" type=\"text\" ng-model=\"data.name\"&gt;&lt;/div&gt; 控制器： 1234567.controller('childCtrl1', ['$scope', 'Data', function($scope, Data)&#123; $scope.data = Data;&#125;]).controller('childCtrl2', ['$scope', 'Data', function($scope, Data)&#123; $scope.data = Data;&#125;]) 这种方式适用于任何需要通信的 Controller 之间。 基于事件Angular 为$scope 提供了冒泡和隧道机制，$broadcast会把事件广播给所有子 Controller，而$emit则会将事件冒泡传递给父 Controller，$on则是 Angular 的事件监听函数，利用这三者，可以实现上下级和同级（需要构造一个共同的父级 Controller）之间的通信。 上下级之间这种情况下比较简单。 如果是子 Controller 往父 Controller 上发送事件（从作用域往上发送事件），使用scope.$emit $scope.$emit&#40;”someEvent”, {}&#41;; 如果是父 Controller 往子 Controller 上发送事件（从作用域往下发送事件），使用 scope.$broadcast $scope.$broadcast(“someEvent”, {}); 无论是 $emit还是 $broadcast发送的事件，都用 $scope.$on接收：123$scope.$on(\"someEvent\", function(event, data) &#123; // 这里取到发送过来的数据 data&#125;); 同级之间同级之间利用事件通信有两种方法。一种是利用上下级之间事件传播的变形，另一种是借助 $rootScope 。 借助父 controller 先看第一种，在子 Controller 中向父 Controller 触发一个事件，然后在父 Controller 中监听事件，再广播给子 Controller ，这样通过事件携带的参数，实现了数据经过父 Controller，在同级 Controller 之间传播。 但是要注意，通过父 Controller 作为中介进行传递的话，子 Controller 触发的事件名和父 Controller 广播用的事件名不能一样，否则会进入死循环。 看代码：123456789&lt;div ng-controller=\"outerCtrl\"&gt; &lt;h3&gt;data in outer controller: &#123;&#123;name&#125;&#125;&lt;/h3&gt; &lt;div ng-controller=\"innerCtrl1\"&gt; &lt;input class=\"form-control\" type=\"text\" ng-model=\"name\" ng-change=\"change()\"&gt; &lt;/div&gt; &lt;div ng-controller=\"innerCtrl2\"&gt; &lt;input class=\"form-control\" type=\"text\" ng-model=\"name\" ng-change=\"change()\"&gt; &lt;/div&gt;&lt;/div&gt; 关键部分在控制器： 12345678910111213141516171819202122232425262728.controller('outerCtrl', ['$scope', function($scope)&#123; $scope.name = 'htf'; $scope.$on('dataChanged', function(event, data)&#123; $scope.name = data; // 2. 父 Ctrl 监听到 dataChanged 时间后，触发 changeData 事件 $scope.$broadcast('changeData', data); &#125;)&#125;]).controller('innerCtrl1', ['$scope', function($scope)&#123; $scope.change = function()&#123; // 1. 子 Ctrl1 中数据改变之后触发 dataChanged 事件 $scope.$emit('dataChanged', $scope.name); &#125; $scope.$on('changeData', function(event, data)&#123; $scope.name = data; &#125;)&#125;]).controller('innerCtrl2', ['$scope', function($scope)&#123; $scope.change = function()&#123; $scope.$emit('dataChanged', $scope.name); &#125; // 3. 监听到 changeData 事件后，改变子 Ctrl2 中 数据 $scope.$on('changeData', function(event, data)&#123; $scope.name = data; &#125;)&#125;]) 借助 $rootScope 每个 Angular 应用默认有一个根作用域$rootScope， 根作用域位于最顶层，从它往下挂着各级作用域。 所以，如果子控制器直接使用 $rootScope广播和接收事件，那么就可实现同级之间的通信。 看栗子： 123456&lt;div ng-controller=\"innerCtrlA\"&gt; &lt;input class=\"form-control\" type=\"text\" ng-model=\"name\" ng-change=\"change()\"&gt;&lt;/div&gt;&lt;div ng-controller=\"innerCtrlB\"&gt; &lt;input class=\"form-control\" type=\"text\" ng-model=\"name\" ng-change=\"change()\"&gt;&lt;/div&gt; 控制器： 12345678910111213141516171819.controller('innerCtrlA', ['$scope', '$rootScope', function($scope, $rootScope)&#123; $scope.change = function()&#123; // 广播事件 $rootScope.$broadcast('nameChanged', $scope.name); &#125; $rootScope.$on('nameChanged', function(event, data)&#123; $scope.name = data; &#125;)&#125;]).controller('innerCtrlB', ['$scope', '$rootScope', function($scope, $rootScope)&#123; $scope.change = function()&#123; $rootScope.$broadcast('nameChanged', $scope.name); &#125; // 监听事件 $rootScope.$on('nameChanged', function(event, data)&#123; $scope.name = data; &#125;)&#125;]) 参考 作用域与事件 Angularjs Controller 间通信机制 AngularJS控制器controller如何通信？ controller 间共享数据","tags":[{"name":"Angular","slug":"Angular","permalink":"http://yutaiwei.github.io/tags/Angular/"},{"name":"前端","slug":"前端","permalink":"http://yutaiwei.github.io/tags/前端/"}]},{"title":"AngularJS中的作用域","date":"2015-12-13T14:01:59.000Z","path":"2015/12/13/AngularJS中的作用域/","text":"问题引入使用 Angular 进行过一段时间的开发后，基本上都会遇到一个这样的坑： 123456789101112&lt;div ng-controller=\"TestCtrl\"&gt; &lt;p&gt;&#123;&#123;name&#125;&#125;&lt;/p&gt; &lt;div ng-if=\"show\"&gt; &lt;input type=\"text\" ng-model=\"name\"&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt;function TestCtrl($scope)&#123; $scope.show = true; $scope.name = 'htf';&#125;&lt;/script&gt; 把p 元素和input元素绑定同一个变量，你本以为，在输入框输入内容，p中显示的肯定也是随之变化的。 然而并不是这样，不管input 中的元素怎么变， p元素中的都没变化，WTF。 要说这是什么原因，那就要从 Angular 的作用域说起了。 作用域每个 Angular 应用默认有一个根作用域 $rootScope， 根作用域位于最顶层，从它往下挂着各级作用域。 通常情况下，页面中ng-model 绑定的变量都是在对应的 Controller 中定义的。如果一个变量未在当前作用域中定义，JavaScript 会通过当前 Controller 的 prototype 向上查找，也就是作用域的继承。 这又分两种情况。 基本类型变量 12345678910111213&lt;div ng-controller=\"OuterCtrl\"&gt; &lt;p&gt;&#123;&#123;x&#125;&#125;&lt;/p&gt; &lt;div ng-controller=\"InnerCtrl\"&gt; &lt;input type=\"text\" ng-model=\"x\"&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt;function OuterCtrl($scope)&#123; $scope.x = 'hello';&#125;function InnerCtrl($scope)&#123;&#125;&lt;/script&gt; 运行后会发现跟文章开头一样的问题，里面输入框变了，外面的没跟着变。 原因在于，InnerCtrl中并未定义x这个变量，取值的时候，会沿着原型链向上找，找到了OuterCtrl中定义的 x，然后赋值给自己，在InnerCtrl的输入框输入值时，改变的是InnerCtrl 中的x ，而对 OuterCtrl中的x无影响。此时，两个x是独立的。 不过，如果你不嫌麻烦的话，用$scope.$parent 可以绑定并影响上一层作用域中的基本变量： 1&lt;input type=\"text\" ng-model=\"$parent.x\"&gt; 引用类型变量那么，如果上下级作用域想共用变量怎么办呢？ 答案是使用引用类型变量。 1234567891011121314&lt;div ng-controller=\"OuterCtrl\"&gt; &lt;p&gt;&#123;&#123;x&#125;&#125;&lt;/p&gt; &lt;div ng-controller=\"InnerCtrl\"&gt; &lt;input type=\"text\" ng-model=\"x\"&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt;function OuterCtrl($scope)&#123; $scope.data = &#123;&#125;; $scope.data.x = 'hello';&#125;function InnerCtrl($scope)&#123;&#125;&lt;/script&gt; 在这种情况下，两者的 data是同一个引用，对这个对象上面的属性修改，是可以反映到两级对象上的。 ng-if中的作用域前面讲的是两级控制器之间的作用域，那跟前面提到的问题有什么关系呢？那个看着不是只有一个 Controller 吗？ 其实，并不是只有 Controller 可以创建作用域，ng-if等指令也会（隐式地）产生新作用域。 总结下来就是，ng-if、ng-switch 、ng-include 等会动态创建一块界面的东西，都是自带一级作用域。 因此，在开发过程中，为了避免模板中的变量歧义，应当尽可能使用命名限定，比如data.x，出现歧义的可能性就比单独的x要少得多。 总结始终将页面中的元素绑定到对象的属性（data.x）而不是 直接绑定到基本变量（x）上。 参考AngularJS实例教程（二）——作用域与事件","tags":[{"name":"Angular","slug":"Angular","permalink":"http://yutaiwei.github.io/tags/Angular/"},{"name":"前端","slug":"前端","permalink":"http://yutaiwei.github.io/tags/前端/"}]},{"title":"Angular JS 指令入门","date":"2015-11-05T12:01:59.000Z","path":"2015/11/05/Angular JS 指令入门/","text":"Angular JS 指令入门指令是运行在特定 dom 元素上的函数，用来扩展元素的功能。 一个简版的 directive 的形式是这样的 123456789101112app.directive('myDirective', myDirective);myDirective.$inject = [];function myDirective()&#123; return &#123; restrict: \"AE\", template: '' scope: &#123;&#125;, link: function()&#123;&#125; &#125;&#125; 下面介绍一些常用的选项。 选项restrict &#40;String&#41;表示指令在 dom 中以何种形式被声明 E 元素 A 属性（默认值） C 类名 M 注释（不建议使用） 属性（E）是最常用的声明指令方式，因为能兼容老版本IE，且不引入新标签。元素（A）方式适合创建一个完全独立、完整的组件。 priority（Number）指令优先级，默认为 0（最高1000，比如 ng-repeat ），如果需要同一元素上一个指令比另一个指令先被调用，可给它设置更高的优先级。 在 Angular 1.2 里面，如果使用 checkbox，同时绑定ng-model 和 ng-click，然后根据ng-model 的值在ng-click里进行相应的处理，像下面这样： 123456789&lt;input type=\"checkbox\" ng-model=\"formData.status\" ng-click=\"check()\"&gt;$scope.check = function()&#123; if($scope.formData.status)&#123; alert('true'); &#125;else&#123; alert('false'); &#125;&#125; 会发现，ng-model的值和 check里面的逻辑是相反的。其实这是因为在 Angular 1.2 里面，ng-click 的优先级比 ng-model高，导致在值更新前，ng-click就被触发。修复办法是用 ng-change替换 ng-click 。在 Angular 1.3 以上版本已经修复了这个问题。 template 和 templateUrl（String || Function）HTML 模版文件。 在调用指令后，模版文件是通过 XHR 来加载的，加载后会缓存到 $templateCache 服务中。 通过 AJAX 异步加载大量的模版会拖慢一个 Angular 应用的速度。可以提前将模版缓存到一个定义模版的 js 文件中，或者在加载ng-app 的首页同时将模版以 script 标签加载，然后在配置template的地方通过 js 获取。 123456&lt;script id=\"pagerTpl\" type=\"text/html\"&gt; &lt;div&gt;...&lt;/div&gt;&lt;/script&gt;template: document.querySelector('#pagerTpl').innerHTML transclude（Boolean）当指令定义的标签内部也有标签的时候，transclude设置为true可以让子标签的内容保持不变。 transclude 通常用来创建可复用的组件，可以将整个模版，包括其中的指令通过 transclude 全部传入一个指令中。典型的应用是模态对话框或导航栏。 replace（Boolean）replace 默认为false，表示模版会被当作子元素插入到调用此指令的元素内部。 设置为 true，则指令会被模版替换掉。 scope（Boolean || Object）scope默认为false，表示指令内和指令外共用同一作用域。设置为 true 的时候，表示从父作用域继承并创建一个新的作用域对象（是不是感觉很像 ng-show 和 ng-if 的区别），不过这两种情况用的比较少（作用域污染）。 最常用的通过一个空对象{ }，产生一个隔离作用域，用于创建可复用的组件。组件可以在未知上下文中使用，并且组件所处的外部作用域和内部作用域不会被不经意地污染。 但大多时候并不会直接使用无数据的隔离作用域。有三种办法让内部的隔离作用域同外部的作用域进行数据绑定。 == 是最常用的方式，通过它可以将本地作用域的属性同父级作用域上的属性进行双向绑定。 在元素中使用属性的方式为（不可以使用 {&#123; &#125;} ）： 12345&lt;div my-directive age=\"age\"&gt;&lt;/div&gt;scope: &#123; age: '='&#125; @使用 @可以将本地作用域同 dom 属性的值进行单向绑定，在使用父作用域中的值对指令中的属性初始赋值后，指令中属性值的修改不会影响父作用域中的值。 在元素中的使用方式为（有 {&#123; &#125;}）： 123456&lt;div my-directive my-name=\"&#123;&#123;name&#125;&#125;\"&gt;&lt;/div&gt;// 视图中的 - 连接的属性转换到指令定义中要使用驼峰式scope: &#123; name: '@myName'&#125; &amp;这是一个绑定函数方法的前缀标识符，通过 &amp; 可以对父级作用域进行绑定，以便在其中运行函数。 在元素中的使用方式为： 12345&lt;div my-directive change=\"changeName()\"&gt;&lt;/div&gt;scope: &#123; changeName: '&amp;change'&#125; controller（String || Function）一般情况下不需要使用指令的controller，只要使用 link就够了，controller和 link函数可以互换。但它是在预编译阶段执行的（先于compile）。 用controller的场景是该指令（a）会被其他指令（b）require 的时候，在 b 的指令里可以传入 a 的这个 controller，目的是为了指令间的复用和交流。而link 只能在指令内部中定义行为，无法做到这样。 controller的形式是这样的： 123controller: function($scope, $ele, $attrs, $transclude)&#123; ...&#125; require（String || Array）一般情况下不需要使用 require，它是和controller结合用的。require 参数用来引入其他指令或一个指令数组，并将引入指令的 controller 传给 link 函数的第四个参数。 编译 和 链接AngularJS 应用启动后，会经历两个阶段。一是编译阶段（compile），对模版dom进行转换（指令标签解析和变换），二是链接阶段（link），将作用域和 dom进行链接（数据绑定）。 编译在编译阶段，AngularJS 会遍历整个 HTML 文档并根据 JavaScript 中的指令定义来处理页面上声明的指令。 编译阶段可以改变原始的 dom（template element），由于此阶段还未对dom树进行数据绑定，所以此时对 dom树操作只需要较少的性能开销。比如ng-repeat（改变原始 dom生成多个 dom 节点） 和 ng-transclude（嵌入模版到指令中） 都是在这个阶段对 dom进行操作。 compile后，返回一个函数（link）或对象（preLink和postLink）。 compile 函数形式： 123456789/*** Compile function* * @param tElem - template element* @param tAttrs - attributes of the template element*/function(tEle, tAttrs)&#123; ...&#125; 链接链接阶段完成作用域和 dom 之间数据的绑定，dom事件监听器的注册，也是在这个阶段做。 link 函数形式： 1234function(scope, iElem, iAttrs, ctrl)&#123; ...&#125; 如果指令定义中有require 选项，link的函数签名中还会有第四个参数，代表控制器或所依赖指令的控制器。 声明指令123456789101112131415161718192021222324//默认不会产生任何作用域app.directive('direName',function()&#123; return &#123; require:'^?group', //^表示当前找不到则向上一级找，找不到则报错？找不到则不报错，注入进来的东西是null controller:function($scope)&#123;&#125;, restrict:'EA',//限制替换的范围 template:'',//要替换的模板/templateUrl:'tmpl/open.html' replace:false,//不替换外部的标签 transclude:true,//保留指令中的内容插入到带有ng-transclude的标签中 link:function(scope,element,attrs,ctrl)&#123; //操作dom元素 //scope当前指令所在的作用域，自己没有作用域则向上查找 //element jq对象（angular内置的），jquery要引入到angular之前，angular发现自己加载过了jquery，就不会加载自己的jquery了 //attrs 当前指令所有属性的集合 //ctrl代表的就是当前依赖的指令的控制器的实例 &#125;, scope:&#123; title:'@',//通过属性传递 获取的是属性对应的字符串 name:'=n',//通过属性传递 获取的是属性对应作用域上的变量 fn:'&amp;say' //通过属性传递一个方法，必须以对象的方式传递 say(&#123;n:1&#125;); &#125;/true //1.&#123;&#125; 完全和父作用域断绝关系 //2.true 产生作用域但是不断绝作用域的关系 &#125;&#125;); 两者区别 compile 是对指令的模板进行转换，link 是在模型和视图之间建立关联（包括注册事件监听） compile 对同一个指令的多个实例只会执行一次，link 对于指令的每个实例都会执行一次 compile 和 link 是互斥的，编写了 compile，自定义的 link 将无效 一般情况下只需要编写 link 栗子举个简单的行内编辑的栗子，默认显示，双击可编辑。 directive 文件 1234567891011121314151617181920212223242526272829app.directive('inlineEdit', inlineEdit);inlineEdit.$inject = ['$document'];function inlineEdit($document)&#123; return &#123; restrict: 'A', templateUrl: 'inline-edit.html', scope: &#123; desc: '=ngModel' &#125;, link: function(scope, ele, attrs)&#123; scope.isEdit = false; ele.on('dblclick', function()&#123; scope.isEdit = true; scope.$digest(); &#125;) $document.on('click', function(evt)&#123; var src = evt.srcElement || evt.target, parent = src.parentNode; if(parent.classList &amp;&amp; parent.classList[0] == 'inline-container')&#123; return; &#125; scope.isEdit = false; scope.$digest(); &#125;) &#125; &#125;&#125; template 文件 123456&lt;div class=\"inline-container\" ng-show=\"isEdit\"&gt; &lt;input type=\"text\" ng-model=\"desc\"&gt;&lt;/div&gt;&lt;div ng-if=\"!isEdit\"&gt; &#123;&#123;desc&#125;&#125;&lt;/div&gt; 然后，可以这样使用 1&lt;div ng-model=\"desc\" inline-edit&gt;&lt;/div&gt;","tags":[{"name":"Angular","slug":"Angular","permalink":"http://yutaiwei.github.io/tags/Angular/"},{"name":"前端","slug":"前端","permalink":"http://yutaiwei.github.io/tags/前端/"}]},{"title":"AngularJS入门篇","date":"2015-11-02T11:53:09.000Z","path":"2015/11/02/AngularJS入门篇/","text":"前言AngularJS是一个JavaScript框架，它通过指令扩展了HTML，且通过表达式绑定数据到 HTML。顺便一提，什么是框架？比如struts2、spring、hibernate、thinkphp、wordpress等等。那么，什么是组件？比如jdbc、jquery、swiper、layer、arttemplate等等。 一般来说，那些可复用的、用于简化开发工作的代码集合，大的叫框架，小的叫组件。有人说jquery是框架？当然可以，大小并没有明确边界。不要太纠结于概念，如无必要，勿增实体。 本文，主要学习归纳一下Angular的各种特性，包括双向数据绑定、定义应用和控制器、优化模板渲染延迟、自定义指令、作用域、HTTP请求获取数据、自定义服务、依赖注入、路由控制等。最后，会给出一个综合实例。 双向数据绑定单向数据绑定的原理：模板+数据=&gt;视图。目前大多数前端框架都是单向数据绑定，比如jQueryUI、BackBone、Flex。 双向数据绑定原理：模板+数据=&gt;视图，模板+视图=&gt;数据。 Angular采用的，就是双向数据绑定。 123456789101112131415&lt;!--helloworld.html--&gt;&lt;!DOCTYPE html&gt;&lt;html ng-app&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;双向数据绑定&lt;/title&gt; &lt;script src=\"http://code.angularjs.org/angular-1.0.1.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; Hello &#123;&#123;'World'&#125;&#125;!&lt;br/&gt; Your name: &lt;input type=\"text\" ng-model=\"yourname\" placeholder=\"World\"&gt; &lt;hr&gt; Hello &#123;&#123;yourname || 'World'&#125;&#125;!&lt;/body&gt;&lt;/html&gt; 定义应用和控制器angular对象，是Angular的根对象。类似于express框架中的express对象，类似于seajs框架的seajs对象，类似于浏览器的window对象。如果说angular对象是Angular中的班主任，那么应用（或者叫模块，app）就是Angular中的班长！而班主任不常出没，管事的就是班长。控制器（controller），就是普通同学小明，负责控制Angular应用程序中的数据。 123456789101112131415161718192021222324252627282930313233343536&lt;!--app.html--&gt;&lt;!DOCTYPE html&gt;&lt;html ng-app=\"myApp\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;定义应用和控制器&lt;/title&gt; &lt;style&gt; [ng\\:cloak], [ng-cloak], [data-ng-cloak], [x-ng-cloak], .ng-cloak, .x-ng-cloak &#123; display: none !important; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div ng-controller=\"myCtrl\"&gt; 名: &lt;input type=\"text\" ng-model=\"firstName\"&gt;&lt;br&gt; 姓: &lt;input type=\"text\" ng-model=\"lastName\"&gt;&lt;br&gt; &lt;br&gt; 姓名: &lt;span&gt;&#123;&#123;firstName + \" \" + lastName&#125;&#125;&lt;/span&gt;&lt;br&gt; 姓名2: &lt;span class=\"ng-cloak\"&gt;&#123;&#123;fullName()&#125;&#125;&lt;/span&gt;&lt;br&gt; 姓名3: &lt;span ng-bind=\"fullName()\"&gt;&lt;/span&gt; &lt;/div&gt; &lt;script src=\"http://code.angularjs.org/angular-1.0.1.min.js\"&gt;&lt;/script&gt; &lt;script&gt; var app = angular.module('myApp', []); app.controller('myCtrl', function($scope) &#123; $scope.firstName= \"John\"; $scope.lastName= \"Doe\"; $scope.fullName = function() &#123; return $scope.firstName + \" \" + $scope.lastName; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 优化模板渲染延迟在定义应用和控制器的例子中，我们看到，页面上先出现了表达式，之后才出现我们期望的结果。解决这个问题，常用的有两个办法。一个是使用ng-bind，另一个是添加ng-cloak样式。 自定义指令12345678910111213141516171819202122232425262728&lt;!--directive.html--&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;自定义指令&lt;/title&gt; &lt;script src=\"http://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js\"&gt;&lt;/script&gt; &lt;/head&gt;&lt;body ng-app=\"myApp\"&gt; &lt;runoob-directive&gt;&lt;/runoob-directive&gt; &lt;div runoob-directive&gt;&lt;/div&gt; &lt;div class=\"runoob-directive\"&gt;&lt;/div&gt; &lt;!-- 指令: runoob-directive --&gt; &lt;script&gt; var app = angular.module(\"myApp\", []); app.directive(\"runoobDirective\", function() &#123; return &#123; //restrict : \"A\", //restrict : \"C\", //restrict : \"M\", //replace : true, template : \"&lt;h1&gt;自定义指令!&lt;/h1&gt;\" &#125;; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 作用域12345678910111213141516171819202122232425262728&lt;!--scope.html--&gt;&lt;!DOCTYPE html&gt;&lt;html ng-app=\"myApp\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;作用域&lt;/title&gt; &lt;script src=\"http://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div ng-controller=\"myCtrl\"&gt; &lt;h1&gt;姓氏为 &#123;&#123;lastname&#125;&#125; 家族成员:&lt;/h1&gt; &lt;ul&gt; &lt;li ng-repeat=\"x in names\"&gt;&#123;&#123;x&#125;&#125; &#123;&#123;lastname&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; var app = angular.module('myApp', []); app.controller('myCtrl', function($scope, $rootScope) &#123; $scope.names = [\"Emil\", \"Tobias\", \"Linus\"]; $rootScope.lastname = \"Refsnes\"; &#125;); &lt;/script&gt; &lt;p&gt;注意 $rootScope 在循环对象内外都可以访问。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 上面的例子中，$scope的作用域为myCtrl这个ng-controller的范围，$rootScope的作用域为myApp这个ng-app的范围。 HTTP请求获取数据获取本地数据123456789101112131415161718192021222324&lt;!--http.html--&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;HTTP请求&lt;/title&gt; &lt;script src=\"http://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body ng-app=\"myApp\" &gt; &lt;div ng-controller=\"myCtrl\"&gt; &lt;h1&gt;欢迎你！&#123;&#123;username&#125;&#125;&lt;/h1&gt; &lt;/div&gt; &lt;p&gt; $http 服务向服务器请求信息，返回的值放入变量 \"username\" 中。&lt;/p&gt;&lt;script&gt; var app = angular.module('myApp', []); app.controller('myCtrl', function($scope, $http) &#123; $http.get(\"http.json\").then(function (response) &#123; $scope.username = response.data.username; &#125;); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; http.json中的内容为：123&#123; \"username\":\"voidking\" &#125; 需要注意的是，本例需要在服务器中访问。因为Angular的HTTP请求封装了XMLHttpRequest，而XMLHttpRequest的使用需要服务器环境。 获取服务器数据123456789101112131415161718192021222324252627282930313233343536373839&lt;!--http2.html--&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;HTTP请求服务器数据&lt;/title&gt; &lt;script src=\"http://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body ng-app=\"myApp\" &gt; &lt;div ng-controller=\"myCtrl\"&gt; &lt;h1&gt;欢迎你！&#123;&#123;username&#125;&#125;&lt;/h1&gt; &lt;/div&gt; &lt;p&gt; $http 服务向服务器请求信息，返回的值放入变量 \"username\" 中。&lt;/p&gt;&lt;script&gt; var app = angular.module('myApp', []); app.controller('myCtrl', function($scope, $http, $httpParamSerializer) &#123; $http(&#123; method:'POST', url:'/angulardemo/http.php', headers:&#123; 'Content-Type':'application/x-www-form-urlencoded' &#125;, dataType: 'json', data: $httpParamSerializer(&#123;username:'voidking'&#125;) &#125;).then(function successCallback(response) &#123; console.log(response.data); $scope.username = response.data.username; &#125;, function errorCallback(response) &#123; console.log(response.data); &#125;);; &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 新建http.php，内容如下：123456789&lt;?php $username = $_POST['username']; $result = array( 'code' =&gt; '0', 'ext' =&gt; 'success', 'username' =&gt; $username ); echo json_encode($result);?&gt; 自定义服务123456789101112131415161718192021222324252627282930313233343536373839&lt;!--service.html--&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;自定义Service&lt;/title&gt; &lt;script src=\"http://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body ng-app=\"myApp\" &gt; &lt;div ng-controller=\"myCtrl\"&gt; &lt;p&gt;自定义服务，用于转换16进制数：&lt;/p&gt; &lt;p&gt;255 的16进制是:&lt;/p&gt; &lt;h1&gt;&#123;&#123;hex&#125;&#125;&lt;/h1&gt; &lt;hr&gt; &lt;p&gt;在获取数组 [255, 251, 200] 值时使用过滤器:&lt;/p&gt; &lt;ul&gt; &lt;li ng-repeat=\"x in counts\"&gt;&#123;&#123;x | myFormat&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;script&gt; var app = angular.module('myApp', []); app.service('hexafy', function() &#123; this.myFunc = function (x) &#123; return x.toString(16); &#125; &#125;); app.controller('myCtrl', function($scope, hexafy) &#123; $scope.hex = hexafy.myFunc(255); $scope.counts = [255, 251, 200]; &#125;); app.filter('myFormat',['hexafy', function(hexafy) &#123; return function(x) &#123; return hexafy.myFunc(x); &#125;; &#125;]);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 当创建了自定义服务，并连接到应用上后，我们可以在控制器，指令，过滤器或其他服务中使用它。 依赖注入AngularJS 提供很好的依赖注入机制。什么是依赖注入？wiki 上的解释是：依赖注入（Dependency Injection，简称DI）是一种软件设计模式，在这种模式下，一个或更多的依赖（或服务）被注入（或者通过引用传递）到一个独立的对象（或客户端）中，然后成为了该客户端状态的一部分。该模式分离了客户端依赖本身行为的创建，这使得程序设计变得松耦合，并遵循了依赖反转和单一职责原则。与服务定位器模式形成直接对比的是，它允许客户端了解客户端如何使用该系统找到依赖。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293&lt;!--di.html--&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;AngularJS依赖注入&lt;/title&gt;&lt;/head&gt; &lt;body ng-app=\"mainApp\" &gt; &lt;h2&gt;AngularJS 简单应用&lt;/h2&gt; &lt;div ng-controller=\"CalcController\"&gt; &lt;p&gt;配置：&#123;&#123;constant&#125;&#125;&lt;/p&gt; &lt;p&gt;输入一个数字: &lt;input type = \"number\" ng-model = \"number\" /&gt;&lt;/p&gt; &lt;button ng-click = \"square()\"&gt;X&lt;sup&gt;2&lt;/sup&gt;&lt;/button&gt; &lt;p&gt;结果: &#123;&#123;result&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;hr&gt; &lt;div ng-controller=\"CalcController2\"&gt; &lt;p&gt;再输入一个数字: &lt;input type = \"number\" ng-model = \"number\" /&gt;&lt;/p&gt; &lt;button ng-click = \"square()\"&gt;X&lt;sup&gt;2&lt;/sup&gt;&lt;/button&gt; &lt;p&gt;结果: &#123;&#123;result&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script src=\"http://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js\"&gt;&lt;/script&gt;&lt;script&gt; var mainApp = angular.module(\"mainApp\", []); mainApp.config(function($provide) &#123; // 创建一个名叫MathService的provider $provide.provider('MathService', function() &#123; this.$get = function() &#123; var factory = &#123;&#125;; factory.multiply = function(a, b) &#123; return a * b; &#125; return factory; &#125;; &#125;); &#125;); // 创建一个名叫defaultInput的value mainApp.value(\"defaultInput\", 5); // 创建一个名叫constant的constant value mainApp.constant(\"constant\", \"constant value\"); // 将MathService、defaultInput、constant注入到控制器 mainApp.controller('CalcController', function($scope, MathService, defaultInput, constant) &#123; $scope.number = defaultInput; $scope.constant = constant; $scope.result = MathService.multiply($scope.number,$scope.number); $scope.square = function() &#123; $scope.result = MathService.multiply($scope.number,$scope.number); &#125; &#125;); /*--------以下是CalcController2的内容--------*/ // 创建一个名叫MathService2的factory mainApp.factory('MathService2', function() &#123; var factory = &#123;&#125;; factory.multiply = function(a, b) &#123; return a * b; &#125; return factory; &#125;); // 创建一个名叫CalcService2的service，并且注入MathService2 mainApp.service('CalcService2', function(MathService2)&#123; this.square = function(a) &#123; return MathService2.multiply(a,a); &#125; &#125;); // 将CalcService2注入到控制器 mainApp.controller('CalcController2',function($scope,CalcService2)&#123; $scope.number = 6; $scope.result = CalcService2.square($scope.number); $scope.square = function() &#123; $scope.result = CalcService2.square($scope.number,$scope.number); &#125; &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; provider()函数是用来创建provider对象的标准方法。 实际上，value()、constant()、factory()、service()全都是用来创建一个provider对象的方法，它们提供了一种方式来定义一个provider，而无需输入所有的复杂的代码。 路由控制AngularJS 路由允许我们通过不同的 URL 访问不同的内容。通过 AngularJS 可以实现多视图的单页Web应用（single page web application，SPA）。通常我们的URL形式为http://runoob.com/first/page ，但在单页Web应用中AngularJS 通过 # + 标记 实现，例如：123http://runoob.com/#/firsthttp://runoob.com/#/secondhttp://runoob.com/#/third 当我们点击以上的任意一个链接时，向服务端请的地址都是一样的 (http://runoob.com/)。 因为 # 号之后的内容在向服务端请求时会被浏览器忽略掉。 所以我们就需要在客户端实现 # 号后面内容的功能实现。 AngularJS 路由 就通过 # + 标记 帮助我们区分不同的逻辑页面并将不同的页面绑定到对应的控制器上。 AngularJS 模块的 config 函数用于配置路由规则。通过使用 configAPI，我们请求把$routeProvider注入到我们的配置函数并且使用$routeProvider.whenAPI来定义我们的路由规则。$routeProvider 为我们提供了 when(path,object) &amp; otherwise(object) 函数按顺序定义所有路由，函数包含两个参数:第一个参数是 URL 或者 URL 正则规则。第二个参数是路由配置对象。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!--router.html--&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"zh\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;路由控制&lt;/title&gt;&lt;/head&gt;&lt;body ng-app=\"ngRouteExample\" class=\"ng-scope\"&gt; &lt;div&gt; &lt;div id=\"navigation\"&gt; &lt;a href=\"#/home\"&gt;Home&lt;/a&gt; &lt;a href=\"#/about\"&gt;About&lt;/a&gt; &lt;/div&gt; &lt;div ng-view=\"\"&gt; &lt;/div&gt;&lt;script type=\"text/ng-template\" id=\"embedded.home.html\"&gt; &lt;h1&gt; Home &lt;/h1&gt;&lt;/script&gt;&lt;script src=\"http://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js\"&gt;&lt;/script&gt;&lt;script src=\"http://apps.bdimg.com/libs/angular-route/1.3.13/angular-route.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; angular.module('ngRouteExample', ['ngRoute']) .controller('HomeController', function ($scope, $route) &#123; $scope.$route = $route;&#125;) .controller('AboutController', function ($scope, $route) &#123; $scope.$route = $route;&#125;) .config(function ($routeProvider) &#123; $routeProvider. when('/home', &#123; templateUrl: 'embedded.home.html', controller: 'HomeController' &#125;). when('/about', &#123; templateUrl: 'about.html', controller: 'AboutController' &#125;). otherwise(&#123; redirectTo: '/home' &#125;); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 12&lt;!--about.html--&gt;&lt;h1&gt; About &lt;/h1&gt; 综合123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!--complex.html--&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"zh\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;综合实例&lt;/title&gt;&lt;/head&gt;&lt;body ng-app=\"ngRouteExample\" class=\"ng-scope\"&gt; &lt;div&gt; &lt;div id=\"navigation\"&gt; &lt;a href=\"#/page1\"&gt;Page1&lt;/a&gt; &lt;a href=\"#/page2\"&gt;Page2&lt;/a&gt; &lt;/div&gt; &lt;div ng-view=\"\"&gt; &lt;/div&gt;&lt;script src=\"http://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js\"&gt;&lt;/script&gt;&lt;script src=\"http://apps.bdimg.com/libs/angular-route/1.3.13/angular-route.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; var myApp = angular.module('ngRouteExample', ['ngRoute']); myApp.controller('Page1Controller', function ($scope, $route) &#123; $scope.$route = $route; $scope.content = '这是page1的内容'; &#125;); myApp.controller('Page2Controller', function ($scope, $route) &#123; $scope.$route = $route; $scope.content = '这是page2的内容'; &#125;) myApp.config(function ($routeProvider) &#123; $routeProvider. when('/page1', &#123; templateUrl: 'complex-page1.html', controller: 'Page1Controller' &#125;). when('/page2', &#123; templateUrl: 'complex-page2.html', controller: 'Page2Controller' &#125;). otherwise(&#123; redirectTo: '/page1' &#125;); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 12345&lt;!--complex-page1.html--&gt;&lt;div id=\"page1\" ng-controller=\"Page1Controller\"&gt; &lt;h1&gt;Page1&lt;/h1&gt; &lt;p&gt;&#123;&#123;content&#125;&#125;&lt;/p&gt;&lt;/div&gt; 12345&lt;!--complex-page2.html--&gt;&lt;div id=\"page2\" ng-controller=\"Page2Controller\"&gt; &lt;h1&gt;Page2&lt;/h1&gt; &lt;p&gt;&#123;&#123;content&#125;&#125;&lt;/p&gt;&lt;/div&gt; 后记至于输入验证、事件、动画、API等，本文不再讨论，用到时自行查阅文档。本文完整源码地址：https://github.com/voidking/angulardemo 记录一个hexo的坑：如果文中出现了双括号，而且双括号没有被代码块包含，那么解析会报错，无法生成页面。 查找到的解决办法：123&#123;% raw %&#125;内容&#123;% endraw %&#125; 经测试，无效，就用汉字代替好了。 书签AngularJS实战http://www.imooc.com/learn/156 AngularJS 教程 | 菜鸟教程http://www.runoob.com/angularjs/angularjs-tutorial.html AngularJS中文网http://www.apjs.net/ AngularJS中文社区http://angularjs.cn/ 图灵社区: 合集 : AngularJS入门教程http://www.ituring.com.cn/minibook/303 AngularJS: API: API Referencehttps://docs.angularjs.org/api ngCloakhttps://docs.angularjs.org/api/ng/directive/ngCloak AngularJS : Why ng-bind is better than 双括号 in angular?http://stackoverflow.com/questions/16125872/angularjs-why-ng-bind-is-better-than-in-angular Metronic3.3网页模板在线演示http://metronic.kp7.cn/ 框架到底是个什么东西？https://www.zhihu.com/question/32069908 理解AngularJS中的依赖注入http://sentsin.com/web/663.html Hexo的一个小BUG(Template render error)http://www.jianshu.com/p/738ebe02029b","tags":[{"name":"前端","slug":"前端","permalink":"http://yutaiwei.github.io/tags/前端/"},{"name":"angular","slug":"angular","permalink":"http://yutaiwei.github.io/tags/angular/"},{"name":"hexo","slug":"hexo","permalink":"http://yutaiwei.github.io/tags/hexo/"}]},{"title":"Cookie、localStorage和sessionStorage","date":"2015-08-03T03:18:09.000Z","path":"2015/08/03/Cookie、localStorage和sessionStorage/","text":"前言在《使用accessToken记录登录状态》一文中，已经讨论了Cookie的增删查改。本文详细探讨一下Cookie、localStorage和sessionStorage的概念差别，以及localStorage的用法。 CookieCookie的特点是小，只有4k，常用来存储辨别用户信息的数据，比如accessToken。而且，Cookie有数量限制，每个特定的域名下，最多生成50个Cookie（IE7+）。最大的优势是几乎所有的浏览器都支持。 localStoragelocalStorage 是 HTML5 标准中新加入的技术，拥有5M的存储空间，主流浏览器都支持。 存储123456789101112if(window.localStorage)&#123; var x = window.localStorage.userInfo? JSON.parse(window.localStorage.userInfo):&#123;&#125;; if((x.unionid == undefined) || (x.unionid == \"undefined\"))&#123; var temp = &#123; unionid: $('#unionid').val(), openid: $('#openid').val(), nickname: $('#nickname').val(), headimgurl:$ ('#headimgurl').val() &#125;; window.localStorage.userInfo = JSON.stringify(temp); &#125;&#125; 读取123var temp = (window.localStorage &amp;&amp; window.localStorage.userInfo)?JSON.parse(window.localStorage.userInfo):&#123;&#125;var unionid = temp.unionid;console.log(unionid); sessionStoragesessionStorage和localStorage非常相似，最主要的差别，是生命周期。localStorage除非被清除，否则永久保存；sessionStorage关闭页面或浏览器后被清除。 异同 特性 Cookie localStorage sessionStorage 数据的生命期 可设置失效时间，默认是关闭浏览器后失效 除非被清除，否则永久保存 仅在当前会话下有效，关闭页面或浏览器后被清除 存放数据大小 4K左右 一般为5MB 一般为5MB 与服务器端通信 每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题 仅在客户端（即浏览器）中保存，不参与和服务器的通信 仅在客户端（即浏览器）中保存，不参与和服务器的通信 易用性 需要程序员自己封装，源生的Cookie接口不友好 源生接口可以接受，亦可再次封装来对Object和Array有更好的支持 源生接口可以接受，亦可再次封装来对Object和Array有更好的支持 书签详说 Cookie, LocalStorage 与 SessionStoragehttps://segmentfault.com/a/1190000002723469 HTML5 localStorage本地存储实际应用举例 谈谈本地存储利弊Cookie、localStorage、sessionStoragehttp://www.tuicool.com/articles/fM32ier","tags":[{"name":"前端","slug":"前端","permalink":"http://yutaiwei.github.io/tags/前端/"},{"name":"html","slug":"html","permalink":"http://yutaiwei.github.io/tags/html/"}]}]