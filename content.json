[{"title":"我的生活","date":"2018-03-12T06:53:59.000Z","path":"2018/03/12/我的生活/","text":"","tags":[]},{"title":"AngularJS 中的服务Provider","date":"2016-05-25T14:01:59.000Z","path":"2016/05/25/AngularJS 中的服务Provider/","text":"AngularJS 中的服务Provider在一个分层良好的 Angular 应用中，Controller 这一层应该很薄。也就是说，应用里大部分的业务逻辑和持久化数据都应该放在 Service 里。 为此，理解 AngularJS 中的几个 Provider 之间的区别很有必要。Provider 创建的新服务都可以用来注入。包括： provider factory service constant value 另外，内建的服务$controller和$filter 也可以被注入，同时也可以使用这些服务来获得新的过滤器和控制器。 下面介绍一下各自的用法和 provider、factory、value 三者之间的区别。 provider用于产生一个可配置的 Service，由两部分组成。第一部分的变量和函数是可以在app.config函数中访问的，可以在它们被其他地方访问到之前来修改它们。定义方式如下： 1234app.provider('myProvider', function()&#123; var a = ''; var func = function()&#123;&#125;;&#125;) 在 app.config函数对 a进行修改： 123app.config(function(myProviderProvider)&#123; myProvider.a = 'hello world';&#125;) 这也是在有如此简单的 factory 的情况下还使用 provider 的原因。 第二部分的变量和函数是通过$get()函数返回的，可以在任何传入了该 provider 的控制器中进行访问的。 12345678app.provider('myProvider', function()&#123; this.$get = function()&#123; return &#123; foo: function()&#123;&#125;, a: a &#125; &#125;&#125;) factoryfactory 返回一个对象。只需要创建一个对象，为它添加属性，然后返回这个对象。在控制器中注入该 factory，即可使用它的所有属性。 123456app.factory('myFactory', function()&#123; var fac = &#123;&#125;; fac.a = 'hello world'; fac.foo = function()&#123;&#125;; return fac;&#125;) 看得出来，factory 的第二个参数就是 provider 中$get要对应的函数实现。 serviceservice 类似于一个构造器， 通过new关键字实例化对象，将一些属性和方法直接添加到 this上，在创建 service 对象时，this会被作为返回值返回。 123456app.service('myService', function()&#123; var a = ''; this.setA = function()&#123;&#125;; this.getA = function()&#123;&#125;; this.foo = function()&#123;&#125;;&#125;) 注入myService 的控制器可以访问到绑定在myService 中 this上的 setA(),getA() 和 foo()三个方法。 constantconstant 用于定义常量，一旦定义就不能被改变。可以被注入到任何地方，但是不能被装饰器(decorator)装饰。 app.constant(‘APP_KEY’, ‘a1s2d3f4’) value与 constant 一样，可以用来定义值。但与 constant 的区别是：可以被修改，可以被 decorator 装饰，不能被注入到 config 中。 app.value(‘version’, ‘1.0’) value 通常用来为应用设置初始值。 decorator比较特殊，它不是 provider 。它是用来装饰其他 provider 的，不过 constant 除外，因为从源码可以看出，constant 不是通过 provider()方法创建的。 下面是一个用 decorator 装饰 value 的栗子。 1234app.value('version', '1.0');app.decorator('version', function ($delegate) &#123; return $delegate + '.1';&#125;) 那如果要使用前面的myService service，但是其中缺少一个你想要的 greet 函数。可以修改 service 吗？答案是不行！但是可以装饰它： 12345app.decorator('myService', function($delegate)&#123; $delegate.greet = function()&#123; return \"Hello, I am a new function of 'myService'\"; &#125;&#125;) $delegate代表实际上的 service 实例。 装饰一个 service 的能力是非常实用的，尤其是当我们想要使用第三方的 service 时，此时不需要将代码复制到我们的项目中，而只需要进行一些修改即可。 什么时候使用 provider 而不用 factory ？provider 是 factory 的加强版。当需要一个可配置的 factory 的时候，使用 provider。 简单介绍一下 AngularJS 运行应用的过程，分两个阶段，config 阶段和 run 阶段。config 阶段是设置任何的 provider 的阶段。也是设置任何的指令，控制器，过滤器以及其它东西的阶段。在 run 阶段，AngularJS 会编译你的 DOM 并启动应用。 factory 和 service 的区别是什么？factory 是普通 function，而 service 是一个构造器(constructor)，这样 Angular 在调用 service 时会用 new 关键字，而调用 factory 时只是调用普通的 function，所以 factory 可以返回任何东西，而 service 可以不返回。 参考 AngularJS 之 Factory vs Service vs Provider 理解AngularJS中的Service类型 AngularJS中的Provider们：Service和Factory等的区别","tags":[{"name":"Angular","slug":"Angular","permalink":"http://yutaiwei.github.io/tags/Angular/"},{"name":"前端","slug":"前端","permalink":"http://yutaiwei.github.io/tags/前端/"}]},{"title":"AngularJS 中 Controller 之间的通信","date":"2016-03-22T14:01:59.000Z","path":"2016/03/22/AngularJS 中 Controller 之间的通信/","text":"用 Angular 进行开发，基本上都会遇到 Controller 之间通信的问题，本文对此进行一个总结。 在 Angular 中，Controller 之间通信的方式主要有三种： 作用域继承。利用子 Controller 控制父 Controller 上的数据。（父 Controller 中的数据要为引用类型，不能是基本类型） 注入服务。把需要共享的数据注册为一个service，在需要的 Controller 中注入。 基于事件。利用 Angular 的事件机制，使用 $on、$emit和 $boardcast 其中，作用域继承仅限于上下级之间的通信，注入服务和基于事件的机制可以实现任意级别的 Controller 通信。 作用域继承这里直接上栗子。 页面： 123456&lt;div ng-controller=\"parentCtrl\"&gt; &lt;p&gt;data in parent controller : &#123;&#123;data.name&#125;&#125;&lt;/p&gt; &lt;div ng-controller=\"childCtrl\"&gt; &lt;input type=\"text\" ng-model=\"data.name\"&gt; &lt;/div&gt;&lt;/div&gt; 控制器： 1234567891011angular.module('demo', []).controller('parentCtrl', ['$scope', function($scope)&#123; $scope.data = &#123; name: 'htf' &#125;&#125;]).controller('childCtrl', ['$scope', function($scope)&#123; &#125;]) 以上是父 Controller 中的数据是引用类型的情况。如果父 Controller 中的数据是基本类型，可通过$scope.$parent.data 访问。 很显然，这种方式仅适用于父子级间 Controller 的通信。 注入服务在 Angular 中，服务是一个单例，所以在服务中生成一个对象，该对象就可以利用依赖注入的方式在所有的控制器中共享。 看个栗子，先定义一个service: 123456angular.module('demo') .factory('Data', function()&#123; return &#123; name: 'htf' &#125;; &#125;) 页面： 12345678&lt;div ng-controller=\"childCtrl1\"&gt; &lt;h3&gt;data in child controller 1 : &#123;&#123;data.name&#125;&#125;&lt;/h3&gt; &lt;input class=\"form-control\" type=\"text\" ng-model=\"data.name\"&gt;&lt;/div&gt;&lt;div ng-controller=\"childCtrl2\"&gt; &lt;h3&gt;data in child controller 2 : &#123;&#123;data.name&#125;&#125;&lt;/h3&gt; &lt;input class=\"form-control\" type=\"text\" ng-model=\"data.name\"&gt;&lt;/div&gt; 控制器： 1234567.controller('childCtrl1', ['$scope', 'Data', function($scope, Data)&#123; $scope.data = Data;&#125;]).controller('childCtrl2', ['$scope', 'Data', function($scope, Data)&#123; $scope.data = Data;&#125;]) 这种方式适用于任何需要通信的 Controller 之间。 基于事件Angular 为$scope 提供了冒泡和隧道机制，$broadcast会把事件广播给所有子 Controller，而$emit则会将事件冒泡传递给父 Controller，$on则是 Angular 的事件监听函数，利用这三者，可以实现上下级和同级（需要构造一个共同的父级 Controller）之间的通信。 上下级之间这种情况下比较简单。 如果是子 Controller 往父 Controller 上发送事件（从作用域往上发送事件），使用scope.$emit $scope.$emit&#40;”someEvent”, {}&#41;; 如果是父 Controller 往子 Controller 上发送事件（从作用域往下发送事件），使用 scope.$broadcast $scope.$broadcast(“someEvent”, {}); 无论是 $emit还是 $broadcast发送的事件，都用 $scope.$on接收：123$scope.$on(\"someEvent\", function(event, data) &#123; // 这里取到发送过来的数据 data&#125;); 同级之间同级之间利用事件通信有两种方法。一种是利用上下级之间事件传播的变形，另一种是借助 $rootScope 。 借助父 controller 先看第一种，在子 Controller 中向父 Controller 触发一个事件，然后在父 Controller 中监听事件，再广播给子 Controller ，这样通过事件携带的参数，实现了数据经过父 Controller，在同级 Controller 之间传播。 但是要注意，通过父 Controller 作为中介进行传递的话，子 Controller 触发的事件名和父 Controller 广播用的事件名不能一样，否则会进入死循环。 看代码：123456789&lt;div ng-controller=\"outerCtrl\"&gt; &lt;h3&gt;data in outer controller: &#123;&#123;name&#125;&#125;&lt;/h3&gt; &lt;div ng-controller=\"innerCtrl1\"&gt; &lt;input class=\"form-control\" type=\"text\" ng-model=\"name\" ng-change=\"change()\"&gt; &lt;/div&gt; &lt;div ng-controller=\"innerCtrl2\"&gt; &lt;input class=\"form-control\" type=\"text\" ng-model=\"name\" ng-change=\"change()\"&gt; &lt;/div&gt;&lt;/div&gt; 关键部分在控制器： 12345678910111213141516171819202122232425262728.controller('outerCtrl', ['$scope', function($scope)&#123; $scope.name = 'htf'; $scope.$on('dataChanged', function(event, data)&#123; $scope.name = data; // 2. 父 Ctrl 监听到 dataChanged 时间后，触发 changeData 事件 $scope.$broadcast('changeData', data); &#125;)&#125;]).controller('innerCtrl1', ['$scope', function($scope)&#123; $scope.change = function()&#123; // 1. 子 Ctrl1 中数据改变之后触发 dataChanged 事件 $scope.$emit('dataChanged', $scope.name); &#125; $scope.$on('changeData', function(event, data)&#123; $scope.name = data; &#125;)&#125;]).controller('innerCtrl2', ['$scope', function($scope)&#123; $scope.change = function()&#123; $scope.$emit('dataChanged', $scope.name); &#125; // 3. 监听到 changeData 事件后，改变子 Ctrl2 中 数据 $scope.$on('changeData', function(event, data)&#123; $scope.name = data; &#125;)&#125;]) 借助 $rootScope 每个 Angular 应用默认有一个根作用域$rootScope， 根作用域位于最顶层，从它往下挂着各级作用域。 所以，如果子控制器直接使用 $rootScope广播和接收事件，那么就可实现同级之间的通信。 看栗子： 123456&lt;div ng-controller=\"innerCtrlA\"&gt; &lt;input class=\"form-control\" type=\"text\" ng-model=\"name\" ng-change=\"change()\"&gt;&lt;/div&gt;&lt;div ng-controller=\"innerCtrlB\"&gt; &lt;input class=\"form-control\" type=\"text\" ng-model=\"name\" ng-change=\"change()\"&gt;&lt;/div&gt; 控制器： 12345678910111213141516171819.controller('innerCtrlA', ['$scope', '$rootScope', function($scope, $rootScope)&#123; $scope.change = function()&#123; // 广播事件 $rootScope.$broadcast('nameChanged', $scope.name); &#125; $rootScope.$on('nameChanged', function(event, data)&#123; $scope.name = data; &#125;)&#125;]).controller('innerCtrlB', ['$scope', '$rootScope', function($scope, $rootScope)&#123; $scope.change = function()&#123; $rootScope.$broadcast('nameChanged', $scope.name); &#125; // 监听事件 $rootScope.$on('nameChanged', function(event, data)&#123; $scope.name = data; &#125;)&#125;]) 参考 作用域与事件 Angularjs Controller 间通信机制 AngularJS控制器controller如何通信？ controller 间共享数据","tags":[{"name":"Angular","slug":"Angular","permalink":"http://yutaiwei.github.io/tags/Angular/"},{"name":"前端","slug":"前端","permalink":"http://yutaiwei.github.io/tags/前端/"}]}]