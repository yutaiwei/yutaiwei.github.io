[{"title":"AngularJS按需加载js","date":"2016-08-02T15:57:39.000Z","path":"2016/08/02/AngularJS按需加载js/","text":"前言Angular是一个单页面应用，随着系统的迭代，首屏代码会越来越大，所以对《AngularJS入门》中的代码进行改造，实现AngularJS可以按需加载js和css。 实现这个需求，有三个方案：1、利用requirejs。requirejs并不是按照angular规范开发的第三方插件，后期估计会有很多坑，放弃。 2、利用ui-router和ocLazyLoad。 每次“页面跳转”都要额外请求js并加载，浪费带宽增加页面加载时间，基本抛弃了预加载。 每一个路由都需要配置resolve属性，太low。 模块化程度太低，不利于以后代码移植和维护。 3、自己写需要的组件。最好的方案，然而技术要求太高，放弃。 综上，第三种方案暂时无法实现，放弃；第一种方案坑太多，放弃；第二种方案也不好，但是相对容易，而且是针对angular的插件，就它了。1234bower install angular#1.5.8bower install angular-ui-routerbower install oclazyloadbower install bootstrap 核心代码123456789101112131415161718192021222324252627282930313233&lt;!--dynamic/index.html--&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"zh\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;link rel=\"stylesheet\" href=\"bower_components/bootstrap/dist/css/bootstrap.min.css\"&gt; &lt;style&gt; body&#123; font-family: \"Microsoft Yahei\"; &#125; .navigator&#123; width: 500px;margin: 0 auto &#125; .navigator li&#123; color: #000;font-size: 14px; &#125; &lt;/style&gt; &lt;title&gt;按需加载js&lt;/title&gt;&lt;/head&gt;&lt;body ng-app=\"myApp\"&gt; &lt;ul class=\"navigator nav nav-pills\"&gt; &lt;li role=\"presentation\" class=\"active\"&gt;&lt;a href=\"#home\" ng-click=\"isActive($event)\"&gt;主页&lt;/a&gt;&lt;/li&gt; &lt;li role=\"presentation\" class=\"active\"&gt;&lt;a href=\"#page2\"&gt;Page2&lt;/a&gt;&lt;/li&gt; &lt;li role=\"presentation\" class=\"active\"&gt;&lt;a href=\"#page3\" ng-click=\"isActive($event)\"&gt;Page3&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div ui-view style=\"width: 500px;margin: 50px auto 0\"&gt;&lt;/div&gt;&lt;script src=\"bower_components/angular/angular.min.js\"&gt;&lt;/script&gt;&lt;script src=\"bower_components/angular-ui-router/release/angular-ui-router.min.js\"&gt;&lt;/script&gt;&lt;script src=\"bower_components/oclazyload/dist/ocLazyLoad.min.js\"&gt;&lt;/script&gt;&lt;script src=\"public/js/index.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/* *dynamic/public/js/index.js*/var myApp=angular.module(\"myApp\",[\"ui.router\",\"oc.lazyLoad\"]);myApp.config(function ($stateProvider,$urlRouterProvider) &#123; $urlRouterProvider.when(\"\",\"/home\"); $stateProvider.state('home',&#123; url:\"/home\", templateUrl: 'views/homepage.html', controller: 'homeController', resolve:&#123; loadMyCtrl:['$ocLazyLoad',function ($ocLazyLoad) &#123; return $ocLazyLoad.load(&#123; name:\"homeApp\", files:[\"public/js/homepage.js\"] &#125;) &#125;] &#125; &#125;); $stateProvider.state('page2',&#123; url:\"/page2\", templateUrl:'views/page2.html', resolve:&#123; loadMyCtrl:function ($ocLazyLoad) &#123; return $ocLazyLoad.load(&#123; name:'page2App', files:[\"public/js/page2.js\"] &#125;) &#125; &#125; &#125;) $stateProvider.state('page3',&#123; url:\"/page3\", templateUrl:'views/page3.html', resolve:&#123; loadMyCtrl:function ($ocLazyLoad) &#123; return $ocLazyLoad.load(&#123; name:'page3App', files:[\"public/js/page3.js\",\"public/js/page3-ext.js\"] &#125;) &#125; &#125; &#125;) &#125;); 12345&lt;!--dynamic/views/homepage.html--&gt;&lt;div id=\"home\" ng-controller=\"homeController\"&gt; &lt;h1&gt;首页&lt;/h1&gt; &#123;&#123;content&#125;&#125;&lt;/div&gt; 123456/* *dynamic/public/js/homepage.js*/angular.module('myApp').controller('homeController', function ($scope) &#123; $scope.content = '这是主页的内容';&#125;); 完整代码github自取：https://github.com/voidking/angulardemo/tree/master/dynamic 书签RequireJS官方文档http://requirejs.org/docs/start.html Dynamically Loading Controllers and Views with AngularJShttp://weblogs.asp.net/dwahlin/dynamically-loading-controllers-and-views-with-angularjs-and-requirejs angular应用如何实现按需加载http://www.alloyteam.com/2015/10/angular-application-how-to-load-on-demand/ 尝试通过AngularJS模块按需加载搭建大型应用（上）http://web.jobbole.com/86915/ 尝试通过AngularJS模块按需加载搭建大型应用（下）http://web.jobbole.com/87025/ angularjs ocLazyLoad分步加载js文件,angularjs ocLazyLoad按需加载jshttp://m.w2bc.com/article/158713 按需加载 AngularJS 的 Controllerhttp://beginor.github.io/2014/12/20/angularjs-controller-load-on-demand.html","tags":[{"name":"前端","slug":"前端","permalink":"http://yutaiwei.github.io/tags/前端/"},{"name":"angularjs","slug":"angularjs","permalink":"http://yutaiwei.github.io/tags/angularjs/"}]},{"title":"Express入门","date":"2016-07-13T14:09:59.000Z","path":"2016/07/13/Express入门/","text":"Express是node的后台快速开发框架创建http服务 12345678910111213141516171819let http = require('http');let fs = require('fs');let url = require('url');http.createServer(function (req,res) &#123; var urlObj = url.parse(req.url,true); var pathname = urlObj.pathname; if (pathname == '/')&#123; res.end('首页') &#125; else if(pathname == '/user')&#123; res.end('用户') &#125; else &#123; res.statusCode = 404; res.end('Not Found') &#125;&#125;).listen(3000,function () &#123; console.log('3000端口成功监听')&#125;); 也可以写成12345let express = require('express');let app = express();app.listen(8080,function()&#123; console.log('8080端口已经成功启动，服务器监听正常')&#125;) express 是一个node模块12- npm install express//安装express方法 注意文件夹名字不能与module模块名字相同 1234567891011121314151617let express = require('express');let app = express();app.get('/',function (req,res) &#123; res.end('首页');&#125;);app.get('user',function (req,res) &#123; res.end('用户');&#125;);app.get('*',function (req,res) &#123; res.end('页面未找到'); //*代表所有路径&#125;);//get方法对应http的方法名 /对应于根路径express.listen(9090,function () &#123; console.log('9090监听成功')&#125;); 中间件 中间件的含义： 是一个函数,可以设置一些公共的逻辑，对所有的路由生效，next也是一个函数，调用它表示继续向下执行 中间件的作用：进行权限判断，添加一些公共的方法 1234app.use(function (req,res，next) &#123; res.setHeader('Content-Type','text/html,charset:utf-8'); next();&#125;); 路由中间件 是一个中间件，但是里面包含了路由规则，把路由进行分类，把不同的路由写在不同的模块里例如 12345678let express = require('express');let app = express();let user = require('./routes/user');let article = require('./routes/article');app.use('/user',user);app.use('/article',article);app.listen(9090);// 有请求到来的时候，先匹配路径前缀 如果匹配才交由后面的路由中间件来处理 ==使用cmd命令模拟发送post请求==1curl -v http://www.baidu.com node实现页面跳转(重定向) 返回到来时的页面 1res.redirect('back'); 跳到指定的页面 1234app.post('/signup',function(req,res)&#123; res.redirect('/signin'); //参数是一个URL地址，不是文件路径&#125;); express 中经常用到的模块汇总请求体解析模块——body-parser 可以将前台get方法传过来的路径内容，或者post方法传过来的参数直接解析 1234567891011npm install body-parser --savelet bodyParser = require('body-parser');app.use(bodyParser.urlencoded(&#123;extended:true&#125;));//extended:true 当extended为false的时候，键值对中的值就为'String'或'Array'形式，为true的时候，则可为任何数据类型。//请求体解析还有这种写法app.use(bodyParser.json());//urlencoded解析body中的urlencoded字符， 只支持utf-8的编码的字符,也支持自动的解析gzip和 zlib，.json这个方法返回一个仅仅用来解析json格式的中间件，能接受任何body中任何Unicode编码的字符。 ==一般请求中有json发送的时候就需要调用bodyParser.json的方法==以上内容写完之后，可以直接在如果是get方法传进来的参数可以用1res.qurey.xxx中获取到 如果是post方法传进来的参数可以用1res.body.xxx中获取到 1234567可以获取的请求内容console.log(req.method); console.log(req.url); console.log(req.path);// req.path = pathname console.log(req.query); console.log(req.headers); console.log(req.body); ==node还可以通过自带的req.params来获取请求url中的参数值== 路径解析模块——path 处理有关文件路径的内容 1let path = require('path'); 绝对路径：==path.resolve== 123456789path.resolve('foo/bar', '/tmp/file/', '..', 'a/../subfile');// 返回 /tmp/subfile// 此方法的参数类似于命令行中的cd命令eg:cd foo/barcd /tmp/file/cd ..cd a/../subfile// cd ..返回上一层 使用适合当前系统的链接符号，连接多个路径：==path-join== 12345console.log(path.join(__dirname,'path.js'));//参数只能是字符串eg：var str = path.join('./path/./', './upload', '/file', '123.jpg');console.log(str); // path/upload/file/123.jpg 路径整理：==path.normalize== 123var str = path.normalize('./path//upload/data/../file/./123.jpg');console.log(str); // path/upload/file/123.jpg//将杂乱的路径例如： path//upload/../file/./123.jpg整理为 path/upload/file/123.jpg正常路径 解析路径：==path.parse== 把一个路径解析为一个 {root:’’, dir:’’, base:’’, ext:’’, name:’’} 这样的对象。 123456789path.parse('/home/user/dir/file.txt')// returns&#123; root : \"/\", dir : \"/home/user/dir\", base : \"file.txt\", ext : \".txt\", name : \"file\"&#125; 更多path模块的使用方法参见：http://www.cnblogs.com/52cik/p/learn-node-path.html 在node环境中每个模块下，都可以通过1234__dirname// 获取当前文件所在的目录的绝对路径__filename//当前文件所在的绝对路径 express路由：Router 可以通过router配置路由 123456789101112131415let router = express.Router();eg:let express = require('express');//router也是一个容器，此容器下面可以配置路由let router = express.Router();router.get('/signup',function(req,res)&#123; res.end('注册');&#125;);router.get('/signin',function(req,res)&#123; res.end('登录');&#125;);router.get('/signout',function(req,res)&#123; res.end('退出');&#125;);module.exports = router; express控制cooike：cookie-parsercookie可以应用在很多场景，例如保存未登录账户的用户的购物车信息引入cookie-parser1let cookiePaser = require('cookie-parser'); 使用cookie-parser需要传入一个秘钥1app.use(cookieParser('mima')); 向客户端写cooike1res.cookie('name','zfpx') 读取客户端的cooike1req.cookies 通过domain来设置向哪个域名发送此次写入的cookie1res.cookie('path-name','zfpx',&#123;domain:'a.zfpx.cn'&#125;); path路径是指向哪个路径发请求的时候会发送此cookie1res.cookie('path-name','zfpx',&#123;path:'/read1'&#125;); 获取服务器时间12expires的参数是一个绝对的时间 2017年1月15日12:33:29res.cookie('expire-name','zfpx',&#123;expires:new Date(Date.now()+10*1000)&#125;); 设置cooike的生命周期12开始倒计时，到10秒后销毁此cookieres.cookie('maxAge-name','zfpx',&#123;maxAge:10*1000&#125;); eg：利用express实现一个访问量统计12345678910let express = require('express');let cookieParser = require('cookie-parser');let app = express();app.use(cookieParser());app.get('/visit',function(req,res)&#123; var visit = isNaN(req.cookies.visit)?1:parseInt(req.cookies.visit)+1; res.cookie('visit',visit); res.send(`欢迎您第$&#123;visit&#125;次访问`);&#125;);app.listen(3333); express的静态资源节点 static通过设置中间件的方式，将客户端发送来的静态资源请求找到设置的对应的文件路径，并将该路径下找到的同名文件返回给客户端。1234567eg:app.use(express.static(path.join(__dirname, 'public')));//解析public文件夹在服务器上的绝对路径，并将客户端发送的所有静态文件请求都从public上查找，并将找到的同名文件返回给客户端eg2:var resolve =file=&gt;path.resolve(__dirname, file);app.use('/dist',express.static(resolve('./dist')));//客户端访问时，带有/dist的路径的进行解析，并将/dist路径下的同名文件进行返回。","tags":[]},{"title":"input绑定回车事件","date":"2016-06-10T02:26:43.000Z","path":"2016/06/10/input绑定回车事件/","text":"html部分：1&lt;input id=\"search-key\" type=\"text\" placeholder=\"请输入关键字\"&gt; JavaScript部分：1234567$('#search-key').keypress(function(event) &#123; var key = event.which; console.log(key); if(key == 13)&#123; //do something &#125;&#125;);","tags":[{"name":"前端","slug":"前端","permalink":"http://yutaiwei.github.io/tags/前端/"},{"name":"jquery","slug":"jquery","permalink":"http://yutaiwei.github.io/tags/jquery/"}]},{"title":"AngularJS 表单验证","date":"2016-06-02T14:01:59.000Z","path":"2016/06/02/AngularJS 表单验证/","text":"AngularJS 表单验证在使用 AngularJS 进行开发的时候，表单填写是一个很常见的需求，而表单验证又是比较让人头疼的部分，本文对此做一个总结。 在 Angular 的视图中使用的 form 已经不是 HTML 中的普通 form 了，而是一个被 Angular 封装过的指令。它可以完成普通 form 无法实现的功能，比如 form 嵌套，而且自带强大的验证功能。Angular 在对表单进行校验的时候会使用 ngModelController上的属性，如果不设置ng-model，则 Angular 无法知道form.$invalid 这个值是否为真。后面在自定义验证有对它的介绍。 本文在对表单的验证时使用了ng-messages，在文章最后也有对它的介绍。 input元素的type属性值： checkbox 创建一个复选框 email 创建一个接受邮件地址作为值的文本输入框 number 创建一个接收数值类型作为值的文本输入框 radio 创建一个单选框 text 创建一个接收任何值的标准文本输入框 url 创建一个接收URL作为值的文本输入框 监控表单的有效性 $pristine 如果用户没有与元素/表单产生交互，则返回true $dirty 如果用户与元素/表单产生过交互，则返回true $valid 当元素/表单内容的校验结果为有效时则返回true $invalid 当元素/表单内容的校验结果为无效时则返回true $error 提供校验错误的详情信息 原生表单验证在 form 层面，可以使用 ng-disabled来控制提交按钮的状态，在 form 表单项全部验证通过前不可点击，下面介绍一下通用的表单项验证选项。 input 验证选项AngularJS 的 input 标签 自带的验证选项有以下这些。 1234567891011&lt;input ng-model=\"\" [name=\"\"] [required=\"\"] [ng-required=\"\"] [ng-minlength=\"\"] [ng-maxlength=\"\"] [ng-pattern=\"\"] [ng-change=\"\"]&gt;...&lt;/input&gt; a. 必填 1&lt;input type=\"text\" name=\"myName\" ng-model=\"username\" required /&gt; 使用ng-required可以根据后面表达式的值设置是否 required。 在不满足required时form.myName.$error 为 {required: true} 。b. 长度 1&lt;input type=\"text\" name=\"myName\" ng-model=\"username\" ng-minlength=\"2\" ng-maxlength=\"10\" /&gt; 在不满足 ng-minlength/ng-maxlength时 form.myName.$error为 {minlength: true, maxlength: true}。 直接使用minlength/maxlength也有相同效果，而且 maxlength 可以设置最多输入 x 个字符，超过之后无法再输入。 c. 模式匹配 1&lt;input type=\"text\" name=\"myDesc\" ng-model=\"desc\" ng-pattern=\"/^[a-zA-Z]&#123;1,20&#125;$/\" /&gt; 在不满足 ng-pattern时 form.myName.$error为 {pattern: true}。 d. 其他 AngularJS 对特定格式也进行了校验。比如将 type设置为 url，email等，在没有特殊验证要求的情况下，可以直接使用这些自带的校验，或者通过自定义指令修改 Angular 内建验证器。不同 type 有不同的验证选项。 CSS ClassesAngular 会根据表单状态自动给表单和表单项添加以下几组样式： ng-valid 验证通过，与之相对的是ng-invalid-ng-valid-[key]通过自定义验证器添加的验证通过的值，与之相对的是ng-invalid-[key] ng-pristine未交互状态，与之相对的是 ng-dirty ng-touched未访问状态，与之相对的是ng-untouched ng-pending 满足 $asyncValidators的情况 这些在 ngModelController 的属性中都有对应值。 根据这些 class，可以为不同状态设置不同的样式，比如这样： 1234567input.ng-valid.ng-dirty &#123; border-color: #78FA89;&#125;input.ng-invalid.ng-dirty &#123; border-color: #FA787E;&#125; 自定义验证在 AngularJS 指令入门 一文中，提到过通过 require 属性和 controller 参数，可以实现指令之间的交互。那么，在自定义指令中使用 require: &#39;ngModel&#39;就可以使用 ngModel 指令的 controller 属性的实例了。 ngModelControllerngModel 提供了数据绑定、验证、CSS更新、数据格式化和编译等操作。下面简单介绍一下 ngModelController 常用的属性和方法。 核心属性a. $viewValue视图里的值 b. $modelValue数据模型里值 在 input事件触发的时候，$viewValue会同步到 $modelValue。默认情况下，这个是一旦 input中的内容有改变就触发。AngularJS 1.3 引入了 ng-model-options，可以让这个同步延迟到 blur 或者延迟一定的时间之后。 12&lt;input type=\"text\" name=\"username\" ng-model=\"username\" ng-model-options=\"&#123;updateOn:'blur'&#125;\"&gt;&lt;input type=\"text\" name=\"username\" ng-model=\"username\" ng-model-options=\"&#123; debounce: 500 &#125;\"&gt; 在$viewValue的值同步到 $modelValue时，会经过 $parsers、$validators 和 $asyncValidators三个核心管道（后两个是 AngularJS 1.3 以后新加的）进行处理，通过后才更新到 $modelValue上（如果验证器管道没通过，不会更新）。 核心管道a. $parsers改变视图值的格式，并更新的到模型（$viewValue -&gt; $modelValue），与之相对的是 $formatters，刚好反过来。 b. $validators用来添加同步验证器 c. $asyncValidators用来添加异步验证器 常用属性a. $error没有通过的验证器名称及对应的错误信息 b. $valid表单项是否都通过验证，都通过时为 true，与之相对的是$invalid c. $touched 表单项是否被访问过，如果获得过焦点，在失去时该值为 true，与之相对的是 $untouched d.$dirty 表示用户是否和表单项交互过（比如输入一些东西），只要有任何改变，该值为 true，与之相对的是 $pristine 常用方法a. $render定义视图具体的渲染方式 b. $setViewValue设置视图值（需要手动触发一个 $digest），使用场景是在自定义指令中监听自定义事件（比如使用具有回调的 jQuery 插件） ngMessagesng-messages是 AngularJS 1.3 提供的一个用来增强模版显示的模块，主要用在处理复杂的错误信息。 在以前的版本中，如果想处理错误信息的显示，可能需要定义一堆code再结合复杂的ng-if语句来实现。而且在输入同时满足多条错误规则的情况下，无法控制错误信息显示的优先级。这些，使用 ng-messages可以完美解决。 准备工作引入 angular-messages.js添加依赖：angular.module(&#39;app&#39;, [&#39;ngMessages&#39;]) 使用方法有两种使用方法，一是将ng-messages 当作属性指令使用：1234567&lt;form name=\"myForm\"&gt; &lt;input type=\"text\" ng-model=\"field\" name=\"myField\" required minlength=\"5\" /&gt; &lt;div ng-messages=\"myForm.myField.$error\"&gt; &lt;div ng-message=\"required\"&gt;必填&lt;/div&gt; &lt;div ng-message=\"minlength\"&gt;长度不够&lt;/div&gt; &lt;/div&gt;&lt;/form&gt; 这样会按照各个错误信息书写的先后顺序进行单一显示，如果想同时显示所有的错误信息，加个ng-messages-multiple： 1&lt;div ng-messages=\"myForm.myField.$error\" ng-messages-multiple&gt;&lt;/div&gt; 另一种是将 ng-messages 当作元素指令使用：1234&lt;ng-messages for=\"myForm.myField.$error\"&gt; &lt;ng-message when=\"required\"&gt;必填&lt;/ng-message&gt; &lt;ng-message when=\"minlength\"&gt;长度不够&lt;/ng-message&gt;&lt;/ng-messages&gt; 如果很多表单项的错误提示信息都一样，也可以把错误信息放在模版里，使用ng-messages-include指令来引用： 12&lt;div ng-messages=\"myForm.username.$error\" ng-messages-include=\"validateTemplate/error.html\"&gt;&lt;/div&gt; 错误模版文件： 12&lt;div ng-message=\"required\"&gt;必填&lt;/div&gt;&lt;div ng-message=\"minlength\"&gt;长度不够&lt;/div&gt;","tags":[{"name":"Angular","slug":"Angular","permalink":"http://yutaiwei.github.io/tags/Angular/"},{"name":"前端","slug":"前端","permalink":"http://yutaiwei.github.io/tags/前端/"}]},{"title":"AngularJS 中的服务Provider","date":"2016-05-25T14:01:59.000Z","path":"2016/05/25/AngularJS 中的服务Provider/","text":"在一个分层良好的 Angular 应用中，Controller 这一层应该很薄。也就是说，应用里大部分的业务逻辑和持久化数据都应该放在 Service 里。 为此，理解 AngularJS 中的几个 Provider 之间的区别很有必要。Provider 创建的新服务都可以用来注入。包括： provider factory service constant value 另外，内建的服务$controller和$filter 也可以被注入，同时也可以使用这些服务来获得新的过滤器和控制器。 下面介绍一下各自的用法和 provider、factory、value 三者之间的区别。 provider用于产生一个可配置的 Service，由两部分组成。第一部分的变量和函数是可以在app.config函数中访问的，可以在它们被其他地方访问到之前来修改它们。定义方式如下： 1234app.provider('myProvider', function()&#123; var a = ''; var func = function()&#123;&#125;;&#125;) 在 app.config函数对 a进行修改： 123app.config(function(myProviderProvider)&#123; myProvider.a = 'hello world';&#125;) 这也是在有如此简单的 factory 的情况下还使用 provider 的原因。 第二部分的变量和函数是通过$get()函数返回的，可以在任何传入了该 provider 的控制器中进行访问的。 12345678app.provider('myProvider', function()&#123; this.$get = function()&#123; return &#123; foo: function()&#123;&#125;, a: a &#125; &#125;&#125;) factoryfactory 返回一个对象。只需要创建一个对象，为它添加属性，然后返回这个对象。在控制器中注入该 factory，即可使用它的所有属性。 123456app.factory('myFactory', function()&#123; var fac = &#123;&#125;; fac.a = 'hello world'; fac.foo = function()&#123;&#125;; return fac;&#125;) 看得出来，factory 的第二个参数就是 provider 中$get要对应的函数实现。 serviceservice 类似于一个构造器， 通过new关键字实例化对象，将一些属性和方法直接添加到 this上，在创建 service 对象时，this会被作为返回值返回。 123456app.service('myService', function()&#123; var a = ''; this.setA = function()&#123;&#125;; this.getA = function()&#123;&#125;; this.foo = function()&#123;&#125;;&#125;) 注入myService 的控制器可以访问到绑定在myService 中 this上的 setA(),getA() 和 foo()三个方法。 constantconstant 用于定义常量，一旦定义就不能被改变。可以被注入到任何地方，但是不能被装饰器(decorator)装饰。 app.constant(‘APP_KEY’, ‘a1s2d3f4’) value与 constant 一样，可以用来定义值。但与 constant 的区别是：可以被修改，可以被 decorator 装饰，不能被注入到 config 中。 app.value(‘version’, ‘1.0’) value 通常用来为应用设置初始值。 decorator比较特殊，它不是 provider 。它是用来装饰其他 provider 的，不过 constant 除外，因为从源码可以看出，constant 不是通过 provider()方法创建的。 下面是一个用 decorator 装饰 value 的栗子。 1234app.value('version', '1.0');app.decorator('version', function ($delegate) &#123; return $delegate + '.1';&#125;) 那如果要使用前面的myService service，但是其中缺少一个你想要的 greet 函数。可以修改 service 吗？答案是不行！但是可以装饰它： 12345app.decorator('myService', function($delegate)&#123; $delegate.greet = function()&#123; return \"Hello, I am a new function of 'myService'\"; &#125;&#125;) $delegate代表实际上的 service 实例。 装饰一个 service 的能力是非常实用的，尤其是当我们想要使用第三方的 service 时，此时不需要将代码复制到我们的项目中，而只需要进行一些修改即可。 什么时候使用 provider 而不用 factory ？provider 是 factory 的加强版。当需要一个可配置的 factory 的时候，使用 provider。 简单介绍一下 AngularJS 运行应用的过程，分两个阶段，config 阶段和 run 阶段。config 阶段是设置任何的 provider 的阶段。也是设置任何的指令，控制器，过滤器以及其它东西的阶段。在 run 阶段，AngularJS 会编译你的 DOM 并启动应用。 factory 和 service 的区别是什么？factory 是普通 function，而 service 是一个构造器(constructor)，这样 Angular 在调用 service 时会用 new 关键字，而调用 factory 时只是调用普通的 function，所以 factory 可以返回任何东西，而 service 可以不返回。 参考 AngularJS 之 Factory vs Service vs Provider 理解AngularJS中的Service类型 AngularJS中的Provider们：Service和Factory等的区别","tags":[{"name":"Angular","slug":"Angular","permalink":"http://yutaiwei.github.io/tags/Angular/"},{"name":"前端","slug":"前端","permalink":"http://yutaiwei.github.io/tags/前端/"}]},{"title":"AngularJS 中 Controller 之间的通信","date":"2016-03-22T14:01:59.000Z","path":"2016/03/22/AngularJS 中 Controller 之间的通信/","text":"用 Angular 进行开发，基本上都会遇到 Controller 之间通信的问题，本文对此进行一个总结。 在 Angular 中，Controller 之间通信的方式主要有三种： 作用域继承。利用子 Controller 控制父 Controller 上的数据。（父 Controller 中的数据要为引用类型，不能是基本类型） 注入服务。把需要共享的数据注册为一个service，在需要的 Controller 中注入。 基于事件。利用 Angular 的事件机制，使用 $on、$emit和 $boardcast 其中，作用域继承仅限于上下级之间的通信，注入服务和基于事件的机制可以实现任意级别的 Controller 通信。 作用域继承这里直接上栗子。 页面： 123456&lt;div ng-controller=\"parentCtrl\"&gt; &lt;p&gt;data in parent controller : &#123;&#123;data.name&#125;&#125;&lt;/p&gt; &lt;div ng-controller=\"childCtrl\"&gt; &lt;input type=\"text\" ng-model=\"data.name\"&gt; &lt;/div&gt;&lt;/div&gt; 控制器： 1234567891011angular.module('demo', []).controller('parentCtrl', ['$scope', function($scope)&#123; $scope.data = &#123; name: 'htf' &#125;&#125;]).controller('childCtrl', ['$scope', function($scope)&#123; &#125;]) 以上是父 Controller 中的数据是引用类型的情况。如果父 Controller 中的数据是基本类型，可通过$scope.$parent.data 访问。 很显然，这种方式仅适用于父子级间 Controller 的通信。 注入服务在 Angular 中，服务是一个单例，所以在服务中生成一个对象，该对象就可以利用依赖注入的方式在所有的控制器中共享。 看个栗子，先定义一个service: 123456angular.module('demo') .factory('Data', function()&#123; return &#123; name: 'htf' &#125;; &#125;) 页面： 12345678&lt;div ng-controller=\"childCtrl1\"&gt; &lt;h3&gt;data in child controller 1 : &#123;&#123;data.name&#125;&#125;&lt;/h3&gt; &lt;input class=\"form-control\" type=\"text\" ng-model=\"data.name\"&gt;&lt;/div&gt;&lt;div ng-controller=\"childCtrl2\"&gt; &lt;h3&gt;data in child controller 2 : &#123;&#123;data.name&#125;&#125;&lt;/h3&gt; &lt;input class=\"form-control\" type=\"text\" ng-model=\"data.name\"&gt;&lt;/div&gt; 控制器： 1234567.controller('childCtrl1', ['$scope', 'Data', function($scope, Data)&#123; $scope.data = Data;&#125;]).controller('childCtrl2', ['$scope', 'Data', function($scope, Data)&#123; $scope.data = Data;&#125;]) 这种方式适用于任何需要通信的 Controller 之间。 基于事件Angular 为$scope 提供了冒泡和隧道机制，$broadcast会把事件广播给所有子 Controller，而$emit则会将事件冒泡传递给父 Controller，$on则是 Angular 的事件监听函数，利用这三者，可以实现上下级和同级（需要构造一个共同的父级 Controller）之间的通信。 上下级之间这种情况下比较简单。 如果是子 Controller 往父 Controller 上发送事件（从作用域往上发送事件），使用scope.$emit $scope.$emit&#40;”someEvent”, {}&#41;; 如果是父 Controller 往子 Controller 上发送事件（从作用域往下发送事件），使用 scope.$broadcast $scope.$broadcast(“someEvent”, {}); 无论是 $emit还是 $broadcast发送的事件，都用 $scope.$on接收：123$scope.$on(\"someEvent\", function(event, data) &#123; // 这里取到发送过来的数据 data&#125;); 同级之间同级之间利用事件通信有两种方法。一种是利用上下级之间事件传播的变形，另一种是借助 $rootScope 。 借助父 controller 先看第一种，在子 Controller 中向父 Controller 触发一个事件，然后在父 Controller 中监听事件，再广播给子 Controller ，这样通过事件携带的参数，实现了数据经过父 Controller，在同级 Controller 之间传播。 但是要注意，通过父 Controller 作为中介进行传递的话，子 Controller 触发的事件名和父 Controller 广播用的事件名不能一样，否则会进入死循环。 看代码：123456789&lt;div ng-controller=\"outerCtrl\"&gt; &lt;h3&gt;data in outer controller: &#123;&#123;name&#125;&#125;&lt;/h3&gt; &lt;div ng-controller=\"innerCtrl1\"&gt; &lt;input class=\"form-control\" type=\"text\" ng-model=\"name\" ng-change=\"change()\"&gt; &lt;/div&gt; &lt;div ng-controller=\"innerCtrl2\"&gt; &lt;input class=\"form-control\" type=\"text\" ng-model=\"name\" ng-change=\"change()\"&gt; &lt;/div&gt;&lt;/div&gt; 关键部分在控制器： 12345678910111213141516171819202122232425262728.controller('outerCtrl', ['$scope', function($scope)&#123; $scope.name = 'htf'; $scope.$on('dataChanged', function(event, data)&#123; $scope.name = data; // 2. 父 Ctrl 监听到 dataChanged 时间后，触发 changeData 事件 $scope.$broadcast('changeData', data); &#125;)&#125;]).controller('innerCtrl1', ['$scope', function($scope)&#123; $scope.change = function()&#123; // 1. 子 Ctrl1 中数据改变之后触发 dataChanged 事件 $scope.$emit('dataChanged', $scope.name); &#125; $scope.$on('changeData', function(event, data)&#123; $scope.name = data; &#125;)&#125;]).controller('innerCtrl2', ['$scope', function($scope)&#123; $scope.change = function()&#123; $scope.$emit('dataChanged', $scope.name); &#125; // 3. 监听到 changeData 事件后，改变子 Ctrl2 中 数据 $scope.$on('changeData', function(event, data)&#123; $scope.name = data; &#125;)&#125;]) 借助 $rootScope 每个 Angular 应用默认有一个根作用域$rootScope， 根作用域位于最顶层，从它往下挂着各级作用域。 所以，如果子控制器直接使用 $rootScope广播和接收事件，那么就可实现同级之间的通信。 看栗子： 123456&lt;div ng-controller=\"innerCtrlA\"&gt; &lt;input class=\"form-control\" type=\"text\" ng-model=\"name\" ng-change=\"change()\"&gt;&lt;/div&gt;&lt;div ng-controller=\"innerCtrlB\"&gt; &lt;input class=\"form-control\" type=\"text\" ng-model=\"name\" ng-change=\"change()\"&gt;&lt;/div&gt; 控制器： 12345678910111213141516171819.controller('innerCtrlA', ['$scope', '$rootScope', function($scope, $rootScope)&#123; $scope.change = function()&#123; // 广播事件 $rootScope.$broadcast('nameChanged', $scope.name); &#125; $rootScope.$on('nameChanged', function(event, data)&#123; $scope.name = data; &#125;)&#125;]).controller('innerCtrlB', ['$scope', '$rootScope', function($scope, $rootScope)&#123; $scope.change = function()&#123; $rootScope.$broadcast('nameChanged', $scope.name); &#125; // 监听事件 $rootScope.$on('nameChanged', function(event, data)&#123; $scope.name = data; &#125;)&#125;]) 参考 作用域与事件 Angularjs Controller 间通信机制 AngularJS控制器controller如何通信？ controller 间共享数据","tags":[{"name":"Angular","slug":"Angular","permalink":"http://yutaiwei.github.io/tags/Angular/"},{"name":"前端","slug":"前端","permalink":"http://yutaiwei.github.io/tags/前端/"}]},{"title":"AngularJS中的作用域","date":"2015-12-13T14:01:59.000Z","path":"2015/12/13/AngularJS中的作用域/","text":"问题引入使用 Angular 进行过一段时间的开发后，基本上都会遇到一个这样的坑： 123456789101112&lt;div ng-controller=\"TestCtrl\"&gt; &lt;p&gt;&#123;&#123;name&#125;&#125;&lt;/p&gt; &lt;div ng-if=\"show\"&gt; &lt;input type=\"text\" ng-model=\"name\"&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt;function TestCtrl($scope)&#123; $scope.show = true; $scope.name = 'htf';&#125;&lt;/script&gt; 把p 元素和input元素绑定同一个变量，你本以为，在输入框输入内容，p中显示的肯定也是随之变化的。 然而并不是这样，不管input 中的元素怎么变， p元素中的都没变化，WTF。 要说这是什么原因，那就要从 Angular 的作用域说起了。 作用域每个 Angular 应用默认有一个根作用域 $rootScope， 根作用域位于最顶层，从它往下挂着各级作用域。 通常情况下，页面中ng-model 绑定的变量都是在对应的 Controller 中定义的。如果一个变量未在当前作用域中定义，JavaScript 会通过当前 Controller 的 prototype 向上查找，也就是作用域的继承。 这又分两种情况。 基本类型变量 12345678910111213&lt;div ng-controller=\"OuterCtrl\"&gt; &lt;p&gt;&#123;&#123;x&#125;&#125;&lt;/p&gt; &lt;div ng-controller=\"InnerCtrl\"&gt; &lt;input type=\"text\" ng-model=\"x\"&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt;function OuterCtrl($scope)&#123; $scope.x = 'hello';&#125;function InnerCtrl($scope)&#123;&#125;&lt;/script&gt; 运行后会发现跟文章开头一样的问题，里面输入框变了，外面的没跟着变。 原因在于，InnerCtrl中并未定义x这个变量，取值的时候，会沿着原型链向上找，找到了OuterCtrl中定义的 x，然后赋值给自己，在InnerCtrl的输入框输入值时，改变的是InnerCtrl 中的x ，而对 OuterCtrl中的x无影响。此时，两个x是独立的。 不过，如果你不嫌麻烦的话，用$scope.$parent 可以绑定并影响上一层作用域中的基本变量： 1&lt;input type=\"text\" ng-model=\"$parent.x\"&gt; 引用类型变量那么，如果上下级作用域想共用变量怎么办呢？ 答案是使用引用类型变量。 1234567891011121314&lt;div ng-controller=\"OuterCtrl\"&gt; &lt;p&gt;&#123;&#123;x&#125;&#125;&lt;/p&gt; &lt;div ng-controller=\"InnerCtrl\"&gt; &lt;input type=\"text\" ng-model=\"x\"&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt;function OuterCtrl($scope)&#123; $scope.data = &#123;&#125;; $scope.data.x = 'hello';&#125;function InnerCtrl($scope)&#123;&#125;&lt;/script&gt; 在这种情况下，两者的 data是同一个引用，对这个对象上面的属性修改，是可以反映到两级对象上的。 ng-if中的作用域前面讲的是两级控制器之间的作用域，那跟前面提到的问题有什么关系呢？那个看着不是只有一个 Controller 吗？ 其实，并不是只有 Controller 可以创建作用域，ng-if等指令也会（隐式地）产生新作用域。 总结下来就是，ng-if、ng-switch 、ng-include 等会动态创建一块界面的东西，都是自带一级作用域。 因此，在开发过程中，为了避免模板中的变量歧义，应当尽可能使用命名限定，比如data.x，出现歧义的可能性就比单独的x要少得多。 总结始终将页面中的元素绑定到对象的属性（data.x）而不是 直接绑定到基本变量（x）上。 参考AngularJS实例教程（二）——作用域与事件","tags":[{"name":"Angular","slug":"Angular","permalink":"http://yutaiwei.github.io/tags/Angular/"},{"name":"前端","slug":"前端","permalink":"http://yutaiwei.github.io/tags/前端/"}]},{"title":"Angular JS 指令入门","date":"2015-11-05T12:01:59.000Z","path":"2015/11/05/Angular JS 指令入门/","text":"Angular JS 指令入门指令是运行在特定 dom 元素上的函数，用来扩展元素的功能。 一个简版的 directive 的形式是这样的 123456789101112app.directive('myDirective', myDirective);myDirective.$inject = [];function myDirective()&#123; return &#123; restrict: \"AE\", template: '' scope: &#123;&#125;, link: function()&#123;&#125; &#125;&#125; 下面介绍一些常用的选项。 选项restrict &#40;String&#41;表示指令在 dom 中以何种形式被声明 E 元素 A 属性（默认值） C 类名 M 注释（不建议使用） 属性（E）是最常用的声明指令方式，因为能兼容老版本IE，且不引入新标签。元素（A）方式适合创建一个完全独立、完整的组件。 priority（Number）指令优先级，默认为 0（最高1000，比如 ng-repeat ），如果需要同一元素上一个指令比另一个指令先被调用，可给它设置更高的优先级。 在 Angular 1.2 里面，如果使用 checkbox，同时绑定ng-model 和 ng-click，然后根据ng-model 的值在ng-click里进行相应的处理，像下面这样： 123456789&lt;input type=\"checkbox\" ng-model=\"formData.status\" ng-click=\"check()\"&gt;$scope.check = function()&#123; if($scope.formData.status)&#123; alert('true'); &#125;else&#123; alert('false'); &#125;&#125; 会发现，ng-model的值和 check里面的逻辑是相反的。其实这是因为在 Angular 1.2 里面，ng-click 的优先级比 ng-model高，导致在值更新前，ng-click就被触发。修复办法是用 ng-change替换 ng-click 。在 Angular 1.3 以上版本已经修复了这个问题。 template 和 templateUrl（String || Function）HTML 模版文件。 在调用指令后，模版文件是通过 XHR 来加载的，加载后会缓存到 $templateCache 服务中。 通过 AJAX 异步加载大量的模版会拖慢一个 Angular 应用的速度。可以提前将模版缓存到一个定义模版的 js 文件中，或者在加载ng-app 的首页同时将模版以 script 标签加载，然后在配置template的地方通过 js 获取。 123456&lt;script id=\"pagerTpl\" type=\"text/html\"&gt; &lt;div&gt;...&lt;/div&gt;&lt;/script&gt;template: document.querySelector('#pagerTpl').innerHTML transclude（Boolean）当指令定义的标签内部也有标签的时候，transclude设置为true可以让子标签的内容保持不变。 transclude 通常用来创建可复用的组件，可以将整个模版，包括其中的指令通过 transclude 全部传入一个指令中。典型的应用是模态对话框或导航栏。 replace（Boolean）replace 默认为false，表示模版会被当作子元素插入到调用此指令的元素内部。 设置为 true，则指令会被模版替换掉。 scope（Boolean || Object）scope默认为false，表示指令内和指令外共用同一作用域。设置为 true 的时候，表示从父作用域继承并创建一个新的作用域对象（是不是感觉很像 ng-show 和 ng-if 的区别），不过这两种情况用的比较少（作用域污染）。 最常用的通过一个空对象{ }，产生一个隔离作用域，用于创建可复用的组件。组件可以在未知上下文中使用，并且组件所处的外部作用域和内部作用域不会被不经意地污染。 但大多时候并不会直接使用无数据的隔离作用域。有三种办法让内部的隔离作用域同外部的作用域进行数据绑定。 == 是最常用的方式，通过它可以将本地作用域的属性同父级作用域上的属性进行双向绑定。 在元素中使用属性的方式为（不可以使用 {&#123; &#125;} ）： 12345&lt;div my-directive age=\"age\"&gt;&lt;/div&gt;scope: &#123; age: '='&#125; @使用 @可以将本地作用域同 dom 属性的值进行单向绑定，在使用父作用域中的值对指令中的属性初始赋值后，指令中属性值的修改不会影响父作用域中的值。 在元素中的使用方式为（有 {&#123; &#125;}）： 123456&lt;div my-directive my-name=\"&#123;&#123;name&#125;&#125;\"&gt;&lt;/div&gt;// 视图中的 - 连接的属性转换到指令定义中要使用驼峰式scope: &#123; name: '@myName'&#125; &amp;这是一个绑定函数方法的前缀标识符，通过 &amp; 可以对父级作用域进行绑定，以便在其中运行函数。 在元素中的使用方式为： 12345&lt;div my-directive change=\"changeName()\"&gt;&lt;/div&gt;scope: &#123; changeName: '&amp;change'&#125; controller（String || Function）一般情况下不需要使用指令的controller，只要使用 link就够了，controller和 link函数可以互换。但它是在预编译阶段执行的（先于compile）。 用controller的场景是该指令（a）会被其他指令（b）require 的时候，在 b 的指令里可以传入 a 的这个 controller，目的是为了指令间的复用和交流。而link 只能在指令内部中定义行为，无法做到这样。 controller的形式是这样的： 123controller: function($scope, $ele, $attrs, $transclude)&#123; ...&#125; require（String || Array）一般情况下不需要使用 require，它是和controller结合用的。require 参数用来引入其他指令或一个指令数组，并将引入指令的 controller 传给 link 函数的第四个参数。 编译 和 链接AngularJS 应用启动后，会经历两个阶段。一是编译阶段（compile），对模版dom进行转换（指令标签解析和变换），二是链接阶段（link），将作用域和 dom进行链接（数据绑定）。 编译在编译阶段，AngularJS 会遍历整个 HTML 文档并根据 JavaScript 中的指令定义来处理页面上声明的指令。 编译阶段可以改变原始的 dom（template element），由于此阶段还未对dom树进行数据绑定，所以此时对 dom树操作只需要较少的性能开销。比如ng-repeat（改变原始 dom生成多个 dom 节点） 和 ng-transclude（嵌入模版到指令中） 都是在这个阶段对 dom进行操作。 compile后，返回一个函数（link）或对象（preLink和postLink）。 compile 函数形式： 123456789/*** Compile function* * @param tElem - template element* @param tAttrs - attributes of the template element*/function(tEle, tAttrs)&#123; ...&#125; 链接链接阶段完成作用域和 dom 之间数据的绑定，dom事件监听器的注册，也是在这个阶段做。 link 函数形式： 1234function(scope, iElem, iAttrs, ctrl)&#123; ...&#125; 如果指令定义中有require 选项，link的函数签名中还会有第四个参数，代表控制器或所依赖指令的控制器。 声明指令123456789101112131415161718192021222324//默认不会产生任何作用域app.directive('direName',function()&#123; return &#123; require:'^?group', //^表示当前找不到则向上一级找，找不到则报错？找不到则不报错，注入进来的东西是null controller:function($scope)&#123;&#125;, restrict:'EA',//限制替换的范围 template:'',//要替换的模板/templateUrl:'tmpl/open.html' replace:false,//不替换外部的标签 transclude:true,//保留指令中的内容插入到带有ng-transclude的标签中 link:function(scope,element,attrs,ctrl)&#123; //操作dom元素 //scope当前指令所在的作用域，自己没有作用域则向上查找 //element jq对象（angular内置的），jquery要引入到angular之前，angular发现自己加载过了jquery，就不会加载自己的jquery了 //attrs 当前指令所有属性的集合 //ctrl代表的就是当前依赖的指令的控制器的实例 &#125;, scope:&#123; title:'@',//通过属性传递 获取的是属性对应的字符串 name:'=n',//通过属性传递 获取的是属性对应作用域上的变量 fn:'&amp;say' //通过属性传递一个方法，必须以对象的方式传递 say(&#123;n:1&#125;); &#125;/true //1.&#123;&#125; 完全和父作用域断绝关系 //2.true 产生作用域但是不断绝作用域的关系 &#125;&#125;); 两者区别 compile 是对指令的模板进行转换，link 是在模型和视图之间建立关联（包括注册事件监听） compile 对同一个指令的多个实例只会执行一次，link 对于指令的每个实例都会执行一次 compile 和 link 是互斥的，编写了 compile，自定义的 link 将无效 一般情况下只需要编写 link 栗子举个简单的行内编辑的栗子，默认显示，双击可编辑。 directive 文件 1234567891011121314151617181920212223242526272829app.directive('inlineEdit', inlineEdit);inlineEdit.$inject = ['$document'];function inlineEdit($document)&#123; return &#123; restrict: 'A', templateUrl: 'inline-edit.html', scope: &#123; desc: '=ngModel' &#125;, link: function(scope, ele, attrs)&#123; scope.isEdit = false; ele.on('dblclick', function()&#123; scope.isEdit = true; scope.$digest(); &#125;) $document.on('click', function(evt)&#123; var src = evt.srcElement || evt.target, parent = src.parentNode; if(parent.classList &amp;&amp; parent.classList[0] == 'inline-container')&#123; return; &#125; scope.isEdit = false; scope.$digest(); &#125;) &#125; &#125;&#125; template 文件 123456&lt;div class=\"inline-container\" ng-show=\"isEdit\"&gt; &lt;input type=\"text\" ng-model=\"desc\"&gt;&lt;/div&gt;&lt;div ng-if=\"!isEdit\"&gt; &#123;&#123;desc&#125;&#125;&lt;/div&gt; 然后，可以这样使用 1&lt;div ng-model=\"desc\" inline-edit&gt;&lt;/div&gt;","tags":[{"name":"Angular","slug":"Angular","permalink":"http://yutaiwei.github.io/tags/Angular/"},{"name":"前端","slug":"前端","permalink":"http://yutaiwei.github.io/tags/前端/"}]},{"title":"AngularJS入门篇","date":"2015-11-02T11:53:09.000Z","path":"2015/11/02/AngularJS入门篇/","text":"前言AngularJS是一个JavaScript框架，它通过指令扩展了HTML，且通过表达式绑定数据到 HTML。顺便一提，什么是框架？比如struts2、spring、hibernate、thinkphp、wordpress等等。那么，什么是组件？比如jdbc、jquery、swiper、layer、arttemplate等等。 一般来说，那些可复用的、用于简化开发工作的代码集合，大的叫框架，小的叫组件。有人说jquery是框架？当然可以，大小并没有明确边界。不要太纠结于概念，如无必要，勿增实体。 本文，主要学习归纳一下Angular的各种特性，包括双向数据绑定、定义应用和控制器、优化模板渲染延迟、自定义指令、作用域、HTTP请求获取数据、自定义服务、依赖注入、路由控制等。最后，会给出一个综合实例。 双向数据绑定单向数据绑定的原理：模板+数据=&gt;视图。目前大多数前端框架都是单向数据绑定，比如jQueryUI、BackBone、Flex。 双向数据绑定原理：模板+数据=&gt;视图，模板+视图=&gt;数据。 Angular采用的，就是双向数据绑定。 123456789101112131415&lt;!--helloworld.html--&gt;&lt;!DOCTYPE html&gt;&lt;html ng-app&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;双向数据绑定&lt;/title&gt; &lt;script src=\"http://code.angularjs.org/angular-1.0.1.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; Hello &#123;&#123;'World'&#125;&#125;!&lt;br/&gt; Your name: &lt;input type=\"text\" ng-model=\"yourname\" placeholder=\"World\"&gt; &lt;hr&gt; Hello &#123;&#123;yourname || 'World'&#125;&#125;!&lt;/body&gt;&lt;/html&gt; 定义应用和控制器angular对象，是Angular的根对象。类似于express框架中的express对象，类似于seajs框架的seajs对象，类似于浏览器的window对象。如果说angular对象是Angular中的班主任，那么应用（或者叫模块，app）就是Angular中的班长！而班主任不常出没，管事的就是班长。控制器（controller），就是普通同学小明，负责控制Angular应用程序中的数据。 123456789101112131415161718192021222324252627282930313233343536&lt;!--app.html--&gt;&lt;!DOCTYPE html&gt;&lt;html ng-app=\"myApp\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;定义应用和控制器&lt;/title&gt; &lt;style&gt; [ng\\:cloak], [ng-cloak], [data-ng-cloak], [x-ng-cloak], .ng-cloak, .x-ng-cloak &#123; display: none !important; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div ng-controller=\"myCtrl\"&gt; 名: &lt;input type=\"text\" ng-model=\"firstName\"&gt;&lt;br&gt; 姓: &lt;input type=\"text\" ng-model=\"lastName\"&gt;&lt;br&gt; &lt;br&gt; 姓名: &lt;span&gt;&#123;&#123;firstName + \" \" + lastName&#125;&#125;&lt;/span&gt;&lt;br&gt; 姓名2: &lt;span class=\"ng-cloak\"&gt;&#123;&#123;fullName()&#125;&#125;&lt;/span&gt;&lt;br&gt; 姓名3: &lt;span ng-bind=\"fullName()\"&gt;&lt;/span&gt; &lt;/div&gt; &lt;script src=\"http://code.angularjs.org/angular-1.0.1.min.js\"&gt;&lt;/script&gt; &lt;script&gt; var app = angular.module('myApp', []); app.controller('myCtrl', function($scope) &#123; $scope.firstName= \"John\"; $scope.lastName= \"Doe\"; $scope.fullName = function() &#123; return $scope.firstName + \" \" + $scope.lastName; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 优化模板渲染延迟在定义应用和控制器的例子中，我们看到，页面上先出现了表达式，之后才出现我们期望的结果。解决这个问题，常用的有两个办法。一个是使用ng-bind，另一个是添加ng-cloak样式。 自定义指令12345678910111213141516171819202122232425262728&lt;!--directive.html--&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;自定义指令&lt;/title&gt; &lt;script src=\"http://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js\"&gt;&lt;/script&gt; &lt;/head&gt;&lt;body ng-app=\"myApp\"&gt; &lt;runoob-directive&gt;&lt;/runoob-directive&gt; &lt;div runoob-directive&gt;&lt;/div&gt; &lt;div class=\"runoob-directive\"&gt;&lt;/div&gt; &lt;!-- 指令: runoob-directive --&gt; &lt;script&gt; var app = angular.module(\"myApp\", []); app.directive(\"runoobDirective\", function() &#123; return &#123; //restrict : \"A\", //restrict : \"C\", //restrict : \"M\", //replace : true, template : \"&lt;h1&gt;自定义指令!&lt;/h1&gt;\" &#125;; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 作用域12345678910111213141516171819202122232425262728&lt;!--scope.html--&gt;&lt;!DOCTYPE html&gt;&lt;html ng-app=\"myApp\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;作用域&lt;/title&gt; &lt;script src=\"http://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div ng-controller=\"myCtrl\"&gt; &lt;h1&gt;姓氏为 &#123;&#123;lastname&#125;&#125; 家族成员:&lt;/h1&gt; &lt;ul&gt; &lt;li ng-repeat=\"x in names\"&gt;&#123;&#123;x&#125;&#125; &#123;&#123;lastname&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; var app = angular.module('myApp', []); app.controller('myCtrl', function($scope, $rootScope) &#123; $scope.names = [\"Emil\", \"Tobias\", \"Linus\"]; $rootScope.lastname = \"Refsnes\"; &#125;); &lt;/script&gt; &lt;p&gt;注意 $rootScope 在循环对象内外都可以访问。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 上面的例子中，$scope的作用域为myCtrl这个ng-controller的范围，$rootScope的作用域为myApp这个ng-app的范围。 HTTP请求获取数据获取本地数据123456789101112131415161718192021222324&lt;!--http.html--&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;HTTP请求&lt;/title&gt; &lt;script src=\"http://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body ng-app=\"myApp\" &gt; &lt;div ng-controller=\"myCtrl\"&gt; &lt;h1&gt;欢迎你！&#123;&#123;username&#125;&#125;&lt;/h1&gt; &lt;/div&gt; &lt;p&gt; $http 服务向服务器请求信息，返回的值放入变量 \"username\" 中。&lt;/p&gt;&lt;script&gt; var app = angular.module('myApp', []); app.controller('myCtrl', function($scope, $http) &#123; $http.get(\"http.json\").then(function (response) &#123; $scope.username = response.data.username; &#125;); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; http.json中的内容为：123&#123; \"username\":\"voidking\" &#125; 需要注意的是，本例需要在服务器中访问。因为Angular的HTTP请求封装了XMLHttpRequest，而XMLHttpRequest的使用需要服务器环境。 获取服务器数据123456789101112131415161718192021222324252627282930313233343536373839&lt;!--http2.html--&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;HTTP请求服务器数据&lt;/title&gt; &lt;script src=\"http://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body ng-app=\"myApp\" &gt; &lt;div ng-controller=\"myCtrl\"&gt; &lt;h1&gt;欢迎你！&#123;&#123;username&#125;&#125;&lt;/h1&gt; &lt;/div&gt; &lt;p&gt; $http 服务向服务器请求信息，返回的值放入变量 \"username\" 中。&lt;/p&gt;&lt;script&gt; var app = angular.module('myApp', []); app.controller('myCtrl', function($scope, $http, $httpParamSerializer) &#123; $http(&#123; method:'POST', url:'/angulardemo/http.php', headers:&#123; 'Content-Type':'application/x-www-form-urlencoded' &#125;, dataType: 'json', data: $httpParamSerializer(&#123;username:'voidking'&#125;) &#125;).then(function successCallback(response) &#123; console.log(response.data); $scope.username = response.data.username; &#125;, function errorCallback(response) &#123; console.log(response.data); &#125;);; &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 新建http.php，内容如下：123456789&lt;?php $username = $_POST['username']; $result = array( 'code' =&gt; '0', 'ext' =&gt; 'success', 'username' =&gt; $username ); echo json_encode($result);?&gt; 自定义服务123456789101112131415161718192021222324252627282930313233343536373839&lt;!--service.html--&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;自定义Service&lt;/title&gt; &lt;script src=\"http://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body ng-app=\"myApp\" &gt; &lt;div ng-controller=\"myCtrl\"&gt; &lt;p&gt;自定义服务，用于转换16进制数：&lt;/p&gt; &lt;p&gt;255 的16进制是:&lt;/p&gt; &lt;h1&gt;&#123;&#123;hex&#125;&#125;&lt;/h1&gt; &lt;hr&gt; &lt;p&gt;在获取数组 [255, 251, 200] 值时使用过滤器:&lt;/p&gt; &lt;ul&gt; &lt;li ng-repeat=\"x in counts\"&gt;&#123;&#123;x | myFormat&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;script&gt; var app = angular.module('myApp', []); app.service('hexafy', function() &#123; this.myFunc = function (x) &#123; return x.toString(16); &#125; &#125;); app.controller('myCtrl', function($scope, hexafy) &#123; $scope.hex = hexafy.myFunc(255); $scope.counts = [255, 251, 200]; &#125;); app.filter('myFormat',['hexafy', function(hexafy) &#123; return function(x) &#123; return hexafy.myFunc(x); &#125;; &#125;]);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 当创建了自定义服务，并连接到应用上后，我们可以在控制器，指令，过滤器或其他服务中使用它。 依赖注入AngularJS 提供很好的依赖注入机制。什么是依赖注入？wiki 上的解释是：依赖注入（Dependency Injection，简称DI）是一种软件设计模式，在这种模式下，一个或更多的依赖（或服务）被注入（或者通过引用传递）到一个独立的对象（或客户端）中，然后成为了该客户端状态的一部分。该模式分离了客户端依赖本身行为的创建，这使得程序设计变得松耦合，并遵循了依赖反转和单一职责原则。与服务定位器模式形成直接对比的是，它允许客户端了解客户端如何使用该系统找到依赖。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293&lt;!--di.html--&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;AngularJS依赖注入&lt;/title&gt;&lt;/head&gt; &lt;body ng-app=\"mainApp\" &gt; &lt;h2&gt;AngularJS 简单应用&lt;/h2&gt; &lt;div ng-controller=\"CalcController\"&gt; &lt;p&gt;配置：&#123;&#123;constant&#125;&#125;&lt;/p&gt; &lt;p&gt;输入一个数字: &lt;input type = \"number\" ng-model = \"number\" /&gt;&lt;/p&gt; &lt;button ng-click = \"square()\"&gt;X&lt;sup&gt;2&lt;/sup&gt;&lt;/button&gt; &lt;p&gt;结果: &#123;&#123;result&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;hr&gt; &lt;div ng-controller=\"CalcController2\"&gt; &lt;p&gt;再输入一个数字: &lt;input type = \"number\" ng-model = \"number\" /&gt;&lt;/p&gt; &lt;button ng-click = \"square()\"&gt;X&lt;sup&gt;2&lt;/sup&gt;&lt;/button&gt; &lt;p&gt;结果: &#123;&#123;result&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script src=\"http://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js\"&gt;&lt;/script&gt;&lt;script&gt; var mainApp = angular.module(\"mainApp\", []); mainApp.config(function($provide) &#123; // 创建一个名叫MathService的provider $provide.provider('MathService', function() &#123; this.$get = function() &#123; var factory = &#123;&#125;; factory.multiply = function(a, b) &#123; return a * b; &#125; return factory; &#125;; &#125;); &#125;); // 创建一个名叫defaultInput的value mainApp.value(\"defaultInput\", 5); // 创建一个名叫constant的constant value mainApp.constant(\"constant\", \"constant value\"); // 将MathService、defaultInput、constant注入到控制器 mainApp.controller('CalcController', function($scope, MathService, defaultInput, constant) &#123; $scope.number = defaultInput; $scope.constant = constant; $scope.result = MathService.multiply($scope.number,$scope.number); $scope.square = function() &#123; $scope.result = MathService.multiply($scope.number,$scope.number); &#125; &#125;); /*--------以下是CalcController2的内容--------*/ // 创建一个名叫MathService2的factory mainApp.factory('MathService2', function() &#123; var factory = &#123;&#125;; factory.multiply = function(a, b) &#123; return a * b; &#125; return factory; &#125;); // 创建一个名叫CalcService2的service，并且注入MathService2 mainApp.service('CalcService2', function(MathService2)&#123; this.square = function(a) &#123; return MathService2.multiply(a,a); &#125; &#125;); // 将CalcService2注入到控制器 mainApp.controller('CalcController2',function($scope,CalcService2)&#123; $scope.number = 6; $scope.result = CalcService2.square($scope.number); $scope.square = function() &#123; $scope.result = CalcService2.square($scope.number,$scope.number); &#125; &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; provider()函数是用来创建provider对象的标准方法。 实际上，value()、constant()、factory()、service()全都是用来创建一个provider对象的方法，它们提供了一种方式来定义一个provider，而无需输入所有的复杂的代码。 路由控制AngularJS 路由允许我们通过不同的 URL 访问不同的内容。通过 AngularJS 可以实现多视图的单页Web应用（single page web application，SPA）。通常我们的URL形式为http://runoob.com/first/page ，但在单页Web应用中AngularJS 通过 # + 标记 实现，例如：123http://runoob.com/#/firsthttp://runoob.com/#/secondhttp://runoob.com/#/third 当我们点击以上的任意一个链接时，向服务端请的地址都是一样的 (http://runoob.com/)。 因为 # 号之后的内容在向服务端请求时会被浏览器忽略掉。 所以我们就需要在客户端实现 # 号后面内容的功能实现。 AngularJS 路由 就通过 # + 标记 帮助我们区分不同的逻辑页面并将不同的页面绑定到对应的控制器上。 AngularJS 模块的 config 函数用于配置路由规则。通过使用 configAPI，我们请求把$routeProvider注入到我们的配置函数并且使用$routeProvider.whenAPI来定义我们的路由规则。$routeProvider 为我们提供了 when(path,object) &amp; otherwise(object) 函数按顺序定义所有路由，函数包含两个参数:第一个参数是 URL 或者 URL 正则规则。第二个参数是路由配置对象。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!--router.html--&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"zh\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;路由控制&lt;/title&gt;&lt;/head&gt;&lt;body ng-app=\"ngRouteExample\" class=\"ng-scope\"&gt; &lt;div&gt; &lt;div id=\"navigation\"&gt; &lt;a href=\"#/home\"&gt;Home&lt;/a&gt; &lt;a href=\"#/about\"&gt;About&lt;/a&gt; &lt;/div&gt; &lt;div ng-view=\"\"&gt; &lt;/div&gt;&lt;script type=\"text/ng-template\" id=\"embedded.home.html\"&gt; &lt;h1&gt; Home &lt;/h1&gt;&lt;/script&gt;&lt;script src=\"http://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js\"&gt;&lt;/script&gt;&lt;script src=\"http://apps.bdimg.com/libs/angular-route/1.3.13/angular-route.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; angular.module('ngRouteExample', ['ngRoute']) .controller('HomeController', function ($scope, $route) &#123; $scope.$route = $route;&#125;) .controller('AboutController', function ($scope, $route) &#123; $scope.$route = $route;&#125;) .config(function ($routeProvider) &#123; $routeProvider. when('/home', &#123; templateUrl: 'embedded.home.html', controller: 'HomeController' &#125;). when('/about', &#123; templateUrl: 'about.html', controller: 'AboutController' &#125;). otherwise(&#123; redirectTo: '/home' &#125;); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 12&lt;!--about.html--&gt;&lt;h1&gt; About &lt;/h1&gt; 综合123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!--complex.html--&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"zh\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;综合实例&lt;/title&gt;&lt;/head&gt;&lt;body ng-app=\"ngRouteExample\" class=\"ng-scope\"&gt; &lt;div&gt; &lt;div id=\"navigation\"&gt; &lt;a href=\"#/page1\"&gt;Page1&lt;/a&gt; &lt;a href=\"#/page2\"&gt;Page2&lt;/a&gt; &lt;/div&gt; &lt;div ng-view=\"\"&gt; &lt;/div&gt;&lt;script src=\"http://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js\"&gt;&lt;/script&gt;&lt;script src=\"http://apps.bdimg.com/libs/angular-route/1.3.13/angular-route.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; var myApp = angular.module('ngRouteExample', ['ngRoute']); myApp.controller('Page1Controller', function ($scope, $route) &#123; $scope.$route = $route; $scope.content = '这是page1的内容'; &#125;); myApp.controller('Page2Controller', function ($scope, $route) &#123; $scope.$route = $route; $scope.content = '这是page2的内容'; &#125;) myApp.config(function ($routeProvider) &#123; $routeProvider. when('/page1', &#123; templateUrl: 'complex-page1.html', controller: 'Page1Controller' &#125;). when('/page2', &#123; templateUrl: 'complex-page2.html', controller: 'Page2Controller' &#125;). otherwise(&#123; redirectTo: '/page1' &#125;); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 12345&lt;!--complex-page1.html--&gt;&lt;div id=\"page1\" ng-controller=\"Page1Controller\"&gt; &lt;h1&gt;Page1&lt;/h1&gt; &lt;p&gt;&#123;&#123;content&#125;&#125;&lt;/p&gt;&lt;/div&gt; 12345&lt;!--complex-page2.html--&gt;&lt;div id=\"page2\" ng-controller=\"Page2Controller\"&gt; &lt;h1&gt;Page2&lt;/h1&gt; &lt;p&gt;&#123;&#123;content&#125;&#125;&lt;/p&gt;&lt;/div&gt; 后记至于输入验证、事件、动画、API等，本文不再讨论，用到时自行查阅文档。本文完整源码地址：https://github.com/voidking/angulardemo 记录一个hexo的坑：如果文中出现了双括号，而且双括号没有被代码块包含，那么解析会报错，无法生成页面。 查找到的解决办法：123&#123;% raw %&#125;内容&#123;% endraw %&#125; 经测试，无效，就用汉字代替好了。 书签AngularJS实战http://www.imooc.com/learn/156 AngularJS 教程 | 菜鸟教程http://www.runoob.com/angularjs/angularjs-tutorial.html AngularJS中文网http://www.apjs.net/ AngularJS中文社区http://angularjs.cn/ 图灵社区: 合集 : AngularJS入门教程http://www.ituring.com.cn/minibook/303 AngularJS: API: API Referencehttps://docs.angularjs.org/api ngCloakhttps://docs.angularjs.org/api/ng/directive/ngCloak AngularJS : Why ng-bind is better than 双括号 in angular?http://stackoverflow.com/questions/16125872/angularjs-why-ng-bind-is-better-than-in-angular Metronic3.3网页模板在线演示http://metronic.kp7.cn/ 框架到底是个什么东西？https://www.zhihu.com/question/32069908 理解AngularJS中的依赖注入http://sentsin.com/web/663.html Hexo的一个小BUG(Template render error)http://www.jianshu.com/p/738ebe02029b","tags":[{"name":"前端","slug":"前端","permalink":"http://yutaiwei.github.io/tags/前端/"},{"name":"angular","slug":"angular","permalink":"http://yutaiwei.github.io/tags/angular/"},{"name":"hexo","slug":"hexo","permalink":"http://yutaiwei.github.io/tags/hexo/"}]},{"title":"ES6对数组的扩展","date":"2015-10-23T11:57:30.000Z","path":"2015/10/23/ES6对数组的扩展/","text":"ECMAScript6对数组进行了扩展，为数组Array构造函数添加了from()、of()等静态方法，也为数组实例添加了find()、findIndex()等方法。下面一起来看一下这些方法的用法。 Array.from()Array.from()将类数组(array-like)对象与可遍历的对象转化为数组并返回。例如将dom节点集合转化为数组，以前我们可能都会这样写： 1234var divs = document.querySelectAll(\"div\");[].slice.call(divs).forEach(function (node) &#123; console.log(node);&#125;) 现在我们可以这样写： 1234var divs = document.querySelectAll(\"div\");Array.from(divs).forEach(function (node) &#123; console.log(node);&#125;) 上面两种写法基本上是相同的。 Array.from()也可以将ES6中新增的Set、Map等结构转化为数组： 12// 将Set结构转化为数组Array.from(new Set([1, 2, 3, 4])); // [1, 2, 3, 4] 12//将Map结构转化为数组Array.from(new Map([\"name\", \"zlw\"])); // [\"name\", \"zlw\"] 字符串既是类数组又是可遍历的，所以Array.from()也可将字符串转化为数组： 1Array.from(\"zlw\"); // [\"z\", \"l\", \"w\"] Array.from()还有两个可选参数，完整语法如下： 1Array.from(obj, mapFn, thisArg) mapFn其实就是数组的map方法，对数组的每个元素处理。thisArg是执行环境的上下文。Array.from(obj, mapFn, thisArg)等同于Array.from(obj).map(mapFn, thisArg)。 Array.of()Array.of()将其参数转化为数组。如： 1Array.of(1, 2, 3); // [1, 2, 3] 我们知道用Array构造函数也可以实现同样功能： 1Array(1, 2, 3) // [1, 2, 3] 他们的不同之处在于： 123Array.of(3); // [3]Array(3) // [undefined, undefined, undefined] 当传入一个参数时，Array.of()会返回只有一个元素的数组，而Array()会返回长度为传入参数而元素都为undefined的数组。 Array.prototype.fill()fill()方法用一个值填充数组给定开始和结束位置之间的的所有值，语法如下： 1fill(value, start, end) 参数start、end是填充区间，包含start位置，但不包含end位置。如果省略，则start默认值为0，end默认值为数组长度。如果两个可选参数中有一个是负数，则用数组长度加上该数来确定相应的位置。例： 123[1, 2, 3].fill(4) // [4, 4, 4][1, 2, 3].fill(4, 1, 2) // [1, 4, 3][1, 2, 3].fill(4, -3, -2) // [4, 2, 3] Array.prototype.find()与Array.prototype.findIndex()find()方法返回数组中符合条件的第一个元素，如果没有则返回undefind。语法如下： 1array.find(callback, context); 参数包括一个回调函数和一个可选参数(执行环境上下文）。回调函数会遍历数组的所有元素，直到找到符合条件的元素，然后find()方法返回该元素。例： 1234567[1, 2, 3, 4].find(function(el, index, arr) &#123; return el &gt; 2;&#125;) // 3[1, 2, 3, 4].find(function(el, index, arr) &#123; return el &gt; 4;&#125;) // undefined findIndex()方法与find()方法用法类似，返回的是第一个符合条件的元素的索引，如果没有则返回-1。例： 1234567[1, 2, 3, 4].findIndex(function(el, index, arr) &#123; return el &gt; 2;&#125;) // 2[1, 2, 3, 4].findIndex(function(el, index, arr) &#123; return el &gt; 4;&#125;) // -1 Array.prototype.entries()、Array.prototype.keys与Array.prototype.values()entries()、keys与values都返回一个数组迭代器对象。例： 1234567891011121314var entries = [1, 2, 3].entries();console.log(entries.next().value); // [0, 1]console.log(entries.next().value); // [1, 2]console.log(entries.next().value); // [2, 3]var keys = [1, 2, 3].keys();console.log(keys.next().value); // 0console.log(keys.next().value); // 1console.log(keys.next().value); // 2var valuess = [1, 2, 3].values();console.log(values.next().value); // 1console.log(values.next().value); // 2console.log(values.next().value); // 3 迭代器的next()方法返回的是一个包含value属性与done属性的对象，而value属性是当前遍历位置的值，done属性是一个布尔值，表示遍历是否结束。 我们也可以用for...of来遍历迭代器： 123456789101112131415for (let i of entries) &#123; console.log(i)&#125; // [0, 1]、[1, 2]、[2, 3]for (let [index, value] of entries) &#123; console.log(index, value)&#125; // 0 1、1 2、2 3for (let key of keys) &#123; console.log(key)&#125; // 0, 1, 2for (let value of values) &#123; console.log(value)&#125; // 1, 2, 3 Array.prototype.copyWithin()copyWithin()方法语法如下： 1arr.copyWithin(target, start, end = this.length) 最后一个参数为可选参数，省略则为数组长度。该方法在数组内复制从start(包含start)位置到end(不包含end)位置的一组元素覆盖到以target为开始位置的地方。例： 123[1, 2, 3, 4].copyWithin(0, 1) // [2, 3, 4, 4][1, 2, 3, 4].copyWithin(0, 1, 2) // [2, 2, 3, 4] 如果start、end参数是负数，则用数组长度加上该参数来确定相应的位置： 1[1, 2, 3, 4].copyWithin(0, -2, -1) // [3, 2, 3, 4] 需要注意copyWithin()改变的是数组本身，并返回改变后的数组，而不是返回原数组的副本。 数组推导(array comprehensions)数组推导就是利用for...of循环基于现有的数组生成新数组。例： 1[for (i of [1, 2, 3]) i * i] // [1, 4, 9] 数组推导允许使用if语句： 12345// 单个if语句[for (i of [1, 2, 3]) if (i &lt; 3) i] // [1, 2]//多重if语句[for (i of [1, 2, 3]) if (i &lt; 3) if (i &gt; 1) i] // [2] 需要注意的是for...of总是写在最前面。 数组推导也允许使用多重for..of循环： 1[for (i of [1, 2, 3]) for (j of [4, 5, 6]) i * j] // [4, 5, 6, 8, 10, 12, 12, 15, 18] 数组推导中还可以包含数组推导： 1[for (i of [1, 2, 3]) [for (j of [4, 5, 6]) i * j]] // [[4, 5, 6], [8, 10, 12], [12, 15, 18]] 各大浏览器对ES6的支持可以查看kangax.github.io/es5-compat-table/es6/。","tags":[{"name":"ES6","slug":"ES6","permalink":"http://yutaiwei.github.io/tags/ES6/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yutaiwei.github.io/tags/JavaScript/"}]},{"title":"ES6的新写法","date":"2015-08-29T14:08:15.000Z","path":"2015/08/29/ES6的新写法/","text":"Let声明变量 let没有预解释 let定义的是块级作用域 123456789101112for(var i = 0;i&lt;3;i++)&#123; for(var i = 0;i&lt;3;i++)&#123; console.log(i) &#125;&#125;//i同时变化，输出012for(let i = 0;i&lt;3;i++)&#123; for(let i = 0;i&lt;3;i++)&#123; console.log(i) &#125;&#125;//形成块级作用域 输出012012012 let一个作用域内不可以重复声明 私有所用域的新写法 老写法 123~function()&#123;&#125; 新写法 12&#123;&#125;//一个花括号一个作用域 解构赋值 数组的解构 1234var [num1,num2] = arrconsole.log(num1,num2)//则num1等于arr[0]//num2等于arr[1] 对象的解构 123456let obj = &#123;name:'lkp',age:19,home:&#123;&#125;&#125;let name = obj.namelet age = obj.agelet&#123;name:name1,age:age1&#125; = obj;console.log(name1,age1)let&#123;name:&#123;province,city&#125;,hoddy:[one]&#125; 模板字符串1`此处添加一个变量$&#123;变量名&#125;` 箭头函数1234567891011let double = num =&gt; num*2;//声明一个函数名：箭头左边是参数右边是返回值，一进一出//如果多于一个参数，或者没有参数得话，左边要用小括号包裹let add = (a,b) =&gt; a+b//如果不只有返回值的话，需要用花括包裹，如果有返回值需要加returnlet add = (a,b) =&gt; &#123; console.log(a,b); return a+b;&#125;//箭头函数没有自己的this指针，只会引用外层this指针，定义阶段就已经确定箭头函数内部的没有this指针，也无法改变指向 数组的新方法 map filter find sort 声明的短属性12345let obj = &#123; name, age&#125;//当声明的变量名与变量值相等时，只写一个就可以 类123456789101112131415161718192021class Animal &#123; constructor()&#123; this.type = 'animal' &#125; says(say)&#123; console.log(this.type + ' says ' + say) &#125;&#125;let animal = new Animal()animal.says('hello') //animal says helloclass Cat extends Animal &#123; constructor()&#123; super() this.type = 'cat' &#125;&#125;let cat = new Cat()cat.says('hello') //cat says hello promise1234567891011121314151617181920212223242526272829class Promise &#123; //构造函数 constructor(task) &#123; //初始化一个私有变量 this._status = '初始态'; //开始执行task任务并且把绑定后的方法传进去 task(this.resolve.bind(this), this.reject.bind(this)); &#125;//成功方法 1. 把状态改为成功态 2.调用成功的回调 resolve(result) &#123; this._status = '成功态'; this._success(result); &#125;//失败的方法 1. 把状态改为失败态 2. 调用失败的回调 reject(err) &#123; this._status = '失败态'; this._fail(err); &#125; //用来给客户端 传入成功和失败的回调函数并保存在实例内部 then(success, fail) &#123; this._success = success; this._fail = fail; &#125;&#125;module.exports = Promise;promise有且只有一个方法，then方法，可以链式操作，执行一个成功的回调，一个失败的回调。 调用promise的方法123456789101112let promise = new Promise(function(resolve,reject)&#123; //这是我们的异步任务，里面会放一些异步任务代码 fs.readFile('1.txt','utf8',function(err,data)&#123; if(err)&#123; //如果失败了需要告诉 客户失败的原因 reject(err); &#125;else&#123; //如果成功了需要把结果送给客户 resolve(data); &#125; &#125;)&#125;); 同时执行多个并发promise.all请求，提高效率，提高可读性123Promise.all([xxx,xxx]).then(function(result)&#123; //promise参数中放的放的每一个回调函数，result中也是一个数据，为每一个回调的返回值。只有每个回调执行完成之后，才会执行then方法。&#125;) promise.race方法1类似all请求，会将先执行完的请求执行then方法","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yutaiwei.github.io/tags/JavaScript/"}]},{"title":"Cookie、localStorage和sessionStorage","date":"2015-08-03T03:18:09.000Z","path":"2015/08/03/Cookie、localStorage和sessionStorage/","text":"前言在《使用accessToken记录登录状态》一文中，已经讨论了Cookie的增删查改。本文详细探讨一下Cookie、localStorage和sessionStorage的概念差别，以及localStorage的用法。 CookieCookie的特点是小，只有4k，常用来存储辨别用户信息的数据，比如accessToken。而且，Cookie有数量限制，每个特定的域名下，最多生成50个Cookie（IE7+）。最大的优势是几乎所有的浏览器都支持。 localStoragelocalStorage 是 HTML5 标准中新加入的技术，拥有5M的存储空间，主流浏览器都支持。 存储123456789101112if(window.localStorage)&#123; var x = window.localStorage.userInfo? JSON.parse(window.localStorage.userInfo):&#123;&#125;; if((x.unionid == undefined) || (x.unionid == \"undefined\"))&#123; var temp = &#123; unionid: $('#unionid').val(), openid: $('#openid').val(), nickname: $('#nickname').val(), headimgurl:$ ('#headimgurl').val() &#125;; window.localStorage.userInfo = JSON.stringify(temp); &#125;&#125; 读取123var temp = (window.localStorage &amp;&amp; window.localStorage.userInfo)?JSON.parse(window.localStorage.userInfo):&#123;&#125;var unionid = temp.unionid;console.log(unionid); sessionStoragesessionStorage和localStorage非常相似，最主要的差别，是生命周期。localStorage除非被清除，否则永久保存；sessionStorage关闭页面或浏览器后被清除。 异同 特性 Cookie localStorage sessionStorage 数据的生命期 可设置失效时间，默认是关闭浏览器后失效 除非被清除，否则永久保存 仅在当前会话下有效，关闭页面或浏览器后被清除 存放数据大小 4K左右 一般为5MB 一般为5MB 与服务器端通信 每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题 仅在客户端（即浏览器）中保存，不参与和服务器的通信 仅在客户端（即浏览器）中保存，不参与和服务器的通信 易用性 需要程序员自己封装，源生的Cookie接口不友好 源生接口可以接受，亦可再次封装来对Object和Array有更好的支持 源生接口可以接受，亦可再次封装来对Object和Array有更好的支持 书签详说 Cookie, LocalStorage 与 SessionStoragehttps://segmentfault.com/a/1190000002723469 HTML5 localStorage本地存储实际应用举例 谈谈本地存储利弊Cookie、localStorage、sessionStoragehttp://www.tuicool.com/articles/fM32ier","tags":[{"name":"前端","slug":"前端","permalink":"http://yutaiwei.github.io/tags/前端/"},{"name":"html","slug":"html","permalink":"http://yutaiwei.github.io/tags/html/"}]},{"title":"flex布局详解","date":"2015-07-26T14:01:10.000Z","path":"2015/07/26/flex布局详解/","text":"flex布局flex可以指定对齐方式，可以解决所有盒子的对齐方式。并利用上页面中的剩余空间。 首先要给最外层的元素设置 12display:flex//或者display:inlineflex 设定主轴的方向 主轴默认是从左往右的方向 交叉轴默认是从上往下的，与主轴垂直。1flex-direction:row|row-reverse// 超出容器是否换行 1234flex-wrap: wrap;//超出后换行flex-wrap: wrap-reverse;//超出后换行 从下往上 复合属性 12flex-flow: column wrap;//超出后换行并且竖直方向排列 确定主轴的对齐方式 12justify-content: flex-end;//flex-start flex-space-ground flex-space-between 交叉轴对齐方式 1234align-items: flex-end;//在交叉轴方向从底部对齐align-items: baseline;//在交叉轴方向从文字基线对齐 设置子容器在父容器中的对齐方式 会覆盖 align-items的值1align-self: center; 处理交叉轴的空白空间 12align-content: flex-start;//对多行起作用，超出的部分会自动留白，并且向头部靠拢，单行使用 align-items 安排容器的排列顺序 - order 12order: -1;//默认值是0，值越小越在前面，可以为负值 基本步骤为： 设置布局方式 设定主轴方向 子元素超过父容器是否换行 确定子元素在主轴或者交叉轴的对齐方式 order安排子元素的排列顺序 核心属性 flex-grow 扩展比例：当盒子中有剩余空间时起作用 默认值0 flex-shrink 收缩比例：当有溢出内容时起作用 默认值是1 flex-basis 基准值：当扩展容器或者收缩容器 时以此值为基准 默认值为auto//基准值为auto时计算中会默认取宽度 溢出比例计算方式为父元素的总宽度 x 基准值的和 y 扩展比例的总和 k ，如果3个盒子每个扩展比例为a、b、c则每个盒子的宽度为(x-y)*a/k+每个盒子自己的基准值 收缩比例的计算方式为：每个子元素算上收缩比例的基准值/所有子元素算上收缩比例的基准值 = 收缩的内容/溢出的内容 ==注意如果有内容，不能收缩到小于自身内容的宽度==","tags":[{"name":"前端","slug":"前端","permalink":"http://yutaiwei.github.io/tags/前端/"},{"name":"css","slug":"css","permalink":"http://yutaiwei.github.io/tags/css/"}]},{"title":"css雪碧图","date":"2015-07-26T04:58:00.000Z","path":"2015/07/26/css雪碧图/","text":"前言CSS雪碧 即CSS Sprite，也有人叫它CSS精灵，是一种CSS图像合并技术，该方法是将小图标合并到一张图片上，然后利用css的背景定位来显示需要显示的图片部分。优点：减少加载网页图片时对服务器的请求次数，提高页面的加载速度，减少鼠标滑过的一些bug。 制作雪碧图的制作，可以使用PS，也可以使用专门的雪碧图制作工具。制作时，最好制作成一列或者一行，定位时会方便一些。下面这个工具挺好用，分享给大家：https://yunpan.cn/cMKygj2hnrBBe 访问密码 f516 css雪碧图简单制作工具（源码）https://github.com/iwangx/sprite 如果要制作svg雪碧图，推荐使用AI。 定位位置雪碧图定位的关键，在于background-position。诀窍在于“调试”，在页面控制背景图上下左右移动，很快就定位好了。 以上面的雪碧图为例，假设我们要显示微博的图标，那么scss代码如下： 123456.icon-weibo&#123; width: 20px; height: 20px; background: url(../../img/test/index/icon.png) no-repeat; background-position: 0px -60px;&#125; 大小假设我们的要显示的图标比雪碧图大，或者比雪碧图小，该怎么办？background-size。 1234567.icon-weibo&#123; width: 40px; height: 40px; background: url(../../img/test/index/icon.png) no-repeat; background-position: -2px -116px; background-size: 118%;&#125; 移动端很多时候，我们并不使用px作为单位，而是rem或者百分比，这时候，该怎么控制雪碧图的位置和大小？利用svg图片。 1&lt;span class=\"i i_menu_0\"&gt;&lt;/span&gt; 123456789101112.i &#123; width: 0.8rem; height: 0.8rem; background: url(../images/ico_global.svg) no-repeat; display: inline-block; background-size: 1100%;&#125;.i_menu_0 &#123; background-position: 0% 0%; &#125;.i_menu_1 &#123; background-position: 10% 0%; &#125;.i_menu_2 &#123; background-position: 20% 0%; &#125;.i_menu_3 &#123; background-position: 30% 0%; &#125;.i_menu_4 &#123; background-position: 40% 0%; &#125;.i_menu_5 &#123; background-position: 50% 0%; &#125; 后记至于PS和AI的使用，在慕课网和网易云课堂上有很多优秀教程，不要错过。 书签CSS雪碧图的实现方法（即背景定位）http://www.suixin8.com/59.html CSS3技术-雪碧图自适应缩放http://www.imooc.com/wiki/detail/id/183 利用动态viewport+rem制作一张自适应的svg雪碧图iconhttp://www.open-open.com/lib/view/open1452229325136.html SVG的用法http://www.webhek.com/svg/","tags":[{"name":"前端","slug":"前端","permalink":"http://yutaiwei.github.io/tags/前端/"},{"name":"css","slug":"css","permalink":"http://yutaiwei.github.io/tags/css/"}]},{"title":"CSS实现文本溢出显示省略号","date":"2015-07-25T13:43:53.000Z","path":"2015/07/25/CSS实现文本溢出显示省略号/","text":"单行文本溢出显示省略号1234width: 300px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; 如果字符串长度超过300px，那么超出部分就变成...。 多行文本溢出显示省略号1234display: -webkit-box;-webkit-box-orient: vertical;-webkit-line-clamp: 3;overflow: hidden; 因为使用了WebKit的CSS扩展属性，该方法适用于WebKit浏览器及移动端； -webkit-line-clamp用来限制在一个块元素显示的文本的行数。为了实现该效果，它需要组合其他的WebKit属性。常见结合属性：display: -webkit-box; 必须结合的属性 ，将对象作为弹性伸缩盒子模型显示 。-webkit-box-orient 必须结合的属性 ，设置或检索伸缩盒对象的子元素的排列方式 。 怎样在js中判断文本是否溢出问题描述：一段文字限定行数，使用css把多余文字显示为省略号，请问怎么通过js判断这段文字是否有文字显示为省略号？ 思路一王晨帅哥提供了一个思路：取消css的-webkit-line-clamp属性，看看元素高度是否发生了变化，变化了就是有文字显示为省略号。 好想法，最后小编改进后如下：这段文字在页面上放两份，一份限定行数，正常显示；另一份不限定行数，隐藏起来。然后，对比这两段文字的高度是否相同。具体实现：1234567891011121314151617181920212223242526272829// scss部分.info&#123; font-size: 1.2rem; margin-top: .6rem; display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: 4; overflow: hidden; p&#123; &amp;:not(:first-child)&#123; margin-top: .4rem; &#125;; line-height: 1.8rem; &#125;&#125;.info-hidden&#123; position: fixed; z-index: -10; visibility: hidden; font-size: 1.2rem; margin-top: .6rem; p&#123; &amp;:not(:first-child)&#123; margin-top: .4rem; &#125;; line-height: 1.8rem; &#125;&#125; 123456// js部分var $info = $('.info');var $info_hidden = $('.info-hidden');if($info.height() === $info_hidden.height())&#123; $('.more').hide();&#125; 思路二后来张伟林帅哥提供了一个更好的思路：既然已经知道了限定的行数，那么判断一个高度就可以了。结合line-height，高度用scrollheight，判断scrollheight &gt; line-height*你决定的行数。 小编马上搜索了一个scrollheight，发现，原来scrollHeight可以返回元素的完整高度。那么，比较一下scrollHeight和height不就可以了么？具体实现：1234567// js部分var $info = $('.info');console.log($info.height());console.log($info[0].scrollHeight);if($info.height() &gt;= $info[0].scrollHeight)&#123; $('.more').hide();&#125; 后记利用js也可以实现文本溢出显示省略号，可以参考书签中的dotdotdot，很形象的名字。。。 书签CSS实现单行、多行文本溢出显示省略号（…）http://www.daqianduan.com/6179.html jQuery.dotdotdothttp://www.bootcdn.cn/jQuery.dotdotdot/","tags":[{"name":"前端","slug":"前端","permalink":"http://yutaiwei.github.io/tags/前端/"},{"name":"css","slug":"css","permalink":"http://yutaiwei.github.io/tags/css/"}]},{"title":"css阴影效果","date":"2015-07-25T02:50:25.000Z","path":"2015/07/25/css阴影效果/","text":"有阴影的图，看上去高大上些？不管怎样，UI设计了阴影，咱就照做好了。语法：1box-shadow: h-shadow v-shadow blur spread color inset; 解释： 值 描述 h-shadow 必需。水平阴影的位置。允许负值。 v-shadow 必需。垂直阴影的位置。允许负值。 blur 可选。模糊距离。 spread 可选。阴影的尺寸。 color 可选。阴影的颜色。请参阅 CSS 颜色值。 inset 可选。将外部阴影 (outset) 改为内部阴影。 常见用法：123div&#123; box-shadow: 10px 10px 5px #0cc;&#125; 四个值分别是水平阴影位置、垂直阴影位置、模糊距离、颜色。 实际案例：123&lt;a href=\"\" class=\"confirm\"&gt; &lt;span&gt;马上去抢2G流量&lt;/span&gt;&lt;/a&gt; 12345678910111213141516.confirm&#123; display: inline-block; box-shadow: 0 .5rem 1.5rem #0cc; border-radius: 5px; margin-top: 12%; width: 98%; height: 17%; background: url(../../img/flowrate/blue.jpg) no-repeat; background-size: 100% 100%; color: #fff; span&#123; display: inline-block; margin-top: 3%; font-size: 1.5rem; &#125;&#125; 最终效果如下：","tags":[{"name":"前端","slug":"前端","permalink":"http://yutaiwei.github.io/tags/前端/"},{"name":"css","slug":"css","permalink":"http://yutaiwei.github.io/tags/css/"}]},{"title":"CSS3的了解","date":"2015-07-21T14:39:19.000Z","path":"2015/07/21/CSS3之初体验/","text":"自CSS3流行以来，虽然以前看过一遍所有的新增属性，但其实在实际项目中用到的少之又少。所以没有形成系统性的认识，以及看到效果立马就能想到解决方案的能力。然后最近正好遇到一个需要绘制大量动画的需求，所以决定趁此机会好好研究一下这个既熟悉又陌生的css3。 在正式开始css3之前，先来介绍一些比较经典的css3实例，让大家好好感受一下css3的魅力，本文会提到以下几个css3的属性： border-radius、::after、attr和content、box-sizing、linear-gradient、radial-gradient、box-shadow border-radius 相信这个属性，写过css的同学都知道，用来产生圆角，比如画一个圆形： 123456div &#123; width:100px; height:100px; background:red; border-radius:100px; //border-radius:100%;&#125; 然后我们来看看它的语法：border-radius: [左上] [右上] [右下] [左下]，于是我们来画一个半圆 123456div &#123; width: 100px; height: 50px; background: red; border-radius: 50px 50px 0 0;&#125; 那如果要画一个椭圆该怎么办呢？你会发现上面的语法貌似做不到了，其实border-radius的值还有一种语法: x半径/y半径： 123456div &#123; width: 100px; height: 50px; background: red; border-radius: 50px/25px;&#125; 如果我要画半个椭圆，又要咋办呢？ 123456div &#123; width: 100px; height: 50px; background: red; border-radius: 100% 0 0 100% /50%;&#125; ::after这里拿个简单的例子来看，我们要画一个放大镜，如下图： 分析一下，这个放大镜可以由两个div组成，一个是黑色的圆环，一个是黑色把手（旋转45度）。所以我们就需要用两个div来实现吗？答案是NO，一个div也是可以的，我们可以借助::after来添加一个元素。同理如果需要三个div，我们还可以使用::before再添加一个元素。下面看一下代码： 12345678910111213141516171819div &#123; width: 50px; height: 50px; border-radius: 50%; border: 5px solid #333; position: relative;&#125;div::after &#123; content: ''; display: block; width: 8px; height: 60px; border-radius: 5px; background: #333; position: absolute; right: -22px; top: 38px; transform: rotate(-45deg);&#125; attr和content比如我们要实现一个悬浮提示的功能。传统方法，使用title属性就能实现，但是现在我们要更美观，可以使用css3提供的attr：能够在css中获取到元素的某个属性值，然后插入到伪元素的content中去。 假如我们的html代码如下： 1&lt;div data-title=\"hello, world\"&gt;hello...&lt;/div&gt; 我们来看看实现这个插件的css代码： 12345678910111213div &#123; position: relative;&#125;div:hover::after &#123; content: attr(data-title); //取到data-title属性的值 display: inline-block; padding: 10px 14px; border: 1px solid #ddd; border-radius: 5px; position: absolute; top: -50px; left: -30px;&#125; 当hover的时候，在元素尾部添加一个内容为data-title属性值的元素，所以就实现了hover显示的效果，如下图所示： box-sizing我们知道，在标准盒子模型中，元素的总宽＝content + padding + border + margin。 css中的盒子模型大家可能都知道，但是这个盒子模型的属性可能没有那么多人知道，box-sizing属性就是用来重定义这个计算方式的，它有三个取值，分别是：content-box（默认）、border-box、padding-box 一般来说，假如我们需要有一个占宽200px、padding10px、border5px的div，经过计算，要这么定义样式。 123456div &#123; width: 170px; //这里的宽度要使用200-10*2-5*2 = 170得到。 height: 50px; padding: 10px; border: 5px solid red;&#125; 然后我们来使用一下box-sizing属性。 1234567div &#123; box-sizing: border-box; width: 200px; //这里的宽度就是元素所占总宽度，不需要计算 height: 50px; padding: 10px; border: 5px solid red;&#125; linear-gradient做活动页面的时候我们经常会遇到这样的需求： 顶部的中间一张大banner图片，然后整个区域的背景色要根据图片背景色渐变。就可以使用这个属性了。 12345div &#123; width: 200px; height: 50px; background: linear-gradient(to right, red, yellow, black, green);&#125; 是不是很有趣？其实，linear-gradient还有更多有趣的功能，你可以根据下面的动图去感受一下： 你以为这就完了？等等，还有更强大的呢！repeating-linear-gradient，来感受一下： linear-gradient还有更加强大的功能，比如它可以给元素添加多个渐变，从而达到更NB的效果。 radial-gradient上面的linear-gradient是线性渐变，这个属性是径向渐变。下面的代码实现了一个chrome的logo。 1234567891011121314151617div.chrome &#123; width: 180px; height: 180px; border-radius: 50%; box-shadow: 0 0 4px #999, 0 0 2px #ddd inset; background: radial-gradient(circle, #4FACF5 0, #2196F3 28%, transparent 28%), radial-gradient(circle, #fff 33%, transparent 33%), linear-gradient(-50deg, #FFEB3B 34%, transparent 34%), linear-gradient(60deg, #4CAF50 33%, transparent 33%), linear-gradient(180deg, #FF756B 0, #F44336 30%, transparent 30%), linear-gradient(-120deg, #FFEB3B 40%, transparent 40%), linear-gradient(-60deg, #FFEB3B 30%, transparent 30%), linear-gradient(0deg, #4CAF50 45%, transparent 45%), linear-gradient(60deg, #4CAF50 30%, transparent 30%), linear-gradient(120deg, #F44336 50%, transparent 50%), linear-gradient(180deg, #F44336 30%, transparent 30%);&#125; 实现原理就是使用了多个渐变色放在div上，友协被遮住，视觉上就产生了想要的效果，是不是很强大！看了下图你就知道其实就是在div上加了很多个渐变。 box-shadow上面的例子大都是对css3新属性的了解和认识，这个实例则是有关于解决方案的例子。 需求：我们要实现下面这个效果图（三个边框：黑色，绿色，红色）： 解法一：假如没有css3知识，我们可以做这样做：用三个div，分别设置边框，然后分别控制宽高和位置来达到这个效果。显然，很复杂，这里就不贴代码了。 解法二：现在我们有css3的知识了，借助box-shadow就可以轻松解决这个问题。先来看看它的语法：box-shadow: [x偏移] [y偏移] [阴影模糊宽度] [阴影宽度] [颜色]，并且还能添加多个阴影，使用逗号隔开。 当然你还可以继续增加，四重边框，五重边框……都不再是问题啦。另外，还能加圆角，阴影会贴紧内层div。 使用这种方法，有一个缺点就是，不支持虚线边框。 解法三： 使用outline（只能支持两重边框） 使用这种方法的缺点就是，只能支持两层的边框，而且还不能根据容器的border-radius自动贴合。 总结通过这段时间对css3的深入了解，发现css3真的很强大，研究起来还是挺有趣的，只有想不到，感觉没有做不到。不过为了实现很酷炫的效果，可能需要编写大量的css代码，这个时候使用什么技术就需要我们自己来衡量了。","tags":[{"name":"CSS3","slug":"CSS3","permalink":"http://yutaiwei.github.io/tags/CSS3/"},{"name":"实例","slug":"实例","permalink":"http://yutaiwei.github.io/tags/实例/"}]}]